<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
    <meta name="color-scheme" content="light dark" />
    <meta http-equiv="Content-Security-Policy" content="default-src 'self'; img-src 'self' data: blob:; style-src 'self' 'unsafe-inline'; script-src 'self' 'unsafe-inline'; connect-src 'self'; media-src 'self' data: blob:; font-src 'self' data:" />
    <title>Betaspray Climber</title>
    <style>
      html, body, #app { height: 100%; margin: 0; } body { background: #0a0f1a; }
      #mobile-controls { position: fixed; inset: auto 0 10px 0; display: none; grid-template-columns: 1fr auto 1fr; align-items: center; justify-items: center; padding: env(safe-area-inset-bottom) 12px 12px 24px; pointer-events: none; }
      :root { --rock-size: clamp(72px, 18vw, 136px); }
      .btn { pointer-events: auto; background: none; border: 0; color: #fff; font: 700 18px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; }
      .rock-btn { width: var(--rock-size); height: var(--rock-size); border-radius: 50%; border: 3px solid #2f2724; position: relative; display: inline-block; box-shadow: inset 0 8px 14px #0005, 0 8px 18px #0007; background: radial-gradient(120% 120% at 30% 28%, #a0897a 0%, #7a6256 55%, #5b4a42 100%); }
      .rock-btn::after { content: ""; position: absolute; inset: 0; border-radius: 50%; background: radial-gradient(closest-side at 70% 30%, #ffffff22, transparent 60%); pointer-events: none; }
      .rock-btn::before { content: ""; position: absolute; left: 50%; top: 50%; width: 48%; height: 40%; transform: translate(-50%, -50%); background: #f2f5f7; border-radius: 6px; box-shadow: 0 2px 0 #0002, inset 0 -2px 0 #0001; }
      .rock-right::before { clip-path: polygon(0% 35%, 58% 35%, 58% 20%, 100% 50%, 58% 80%, 58% 65%, 0% 65%); } .rock-left::before { clip-path: polygon(100% 35%, 42% 35%, 42% 20%, 0% 50%, 42% 80%, 42% 65%, 100% 65%); }
      .rock-btn:active { transform: translateY(2px) scale(0.98); filter: brightness(0.95); } #spacer { width: clamp(64px, 14vw, 120px); height: 1px; }
    </style>
    <script type="module" crossorigin>var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var _a, _b, _c, _d, _e2, _f, _g, _h, _i, _j, _k, _l, _m, _n2, _o, _p, _q, _r2, _s, _t, _u, _v, _w, _x, _y;
(function polyfill() {
  const relList = document.createElement("link").relList;
  if (relList && relList.supports && relList.supports("modulepreload")) {
    return;
  }
  for (const link of document.querySelectorAll('link[rel="modulepreload"]')) {
    processPreload(link);
  }
  new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      if (mutation.type !== "childList") {
        continue;
      }
      for (const node of mutation.addedNodes) {
        if (node.tagName === "LINK" && node.rel === "modulepreload")
          processPreload(node);
      }
    }
  }).observe(document, { childList: true, subtree: true });
  function getFetchOpts(link) {
    const fetchOpts = {};
    if (link.integrity) fetchOpts.integrity = link.integrity;
    if (link.referrerPolicy) fetchOpts.referrerPolicy = link.referrerPolicy;
    if (link.crossOrigin === "use-credentials")
      fetchOpts.credentials = "include";
    else if (link.crossOrigin === "anonymous") fetchOpts.credentials = "omit";
    else fetchOpts.credentials = "same-origin";
    return fetchOpts;
  }
  function processPreload(link) {
    if (link.ep)
      return;
    link.ep = true;
    const fetchOpts = getFetchOpts(link);
    fetch(link.href, fetchOpts);
  }
})();
var yi = Object.defineProperty;
var i = (n, e) => yi(n, "name", { value: e, configurable: true });
var gr = (() => {
  for (var n = new Uint8Array(128), e = 0; e < 64; e++) n[e < 26 ? e + 65 : e < 52 ? e + 71 : e < 62 ? e - 4 : e * 4 - 205] = e;
  return (o) => {
    for (var c = o.length, g = new Uint8Array((c - (o[c - 1] == "=") - (o[c - 2] == "=")) * 3 / 4 | 0), m = 0, P = 0; m < c; ) {
      var I = n[o.charCodeAt(m++)], j = n[o.charCodeAt(m++)], y = n[o.charCodeAt(m++)], X = n[o.charCodeAt(m++)];
      g[P++] = I << 2 | j >> 4, g[P++] = j << 4 | y >> 2, g[P++] = y << 6 | X;
    }
    return g;
  };
})();
function Ge(n) {
  return n * Math.PI / 180;
}
i(Ge, "deg2rad");
function ot(n) {
  return n * 180 / Math.PI;
}
i(ot, "rad2deg");
function Le(n, e, o) {
  return e > o ? Le(n, o, e) : Math.min(Math.max(n, e), o);
}
i(Le, "clamp");
function Ve(n, e, o) {
  if (typeof n == "number" && typeof e == "number") return n + (e - n) * o;
  if (n instanceof v && e instanceof v) return n.lerp(e, o);
  if (n instanceof W && e instanceof W) return n.lerp(e, o);
  throw new Error(`Bad value for lerp(): ${n}, ${e}. Only number, Vec2 and Color is supported.`);
}
i(Ve, "lerp");
function _e(n, e, o, c, g) {
  return c + (n - e) / (o - e) * (g - c);
}
i(_e, "map");
function br(n, e, o, c, g) {
  return Le(_e(n, e, o, c, g), c, g);
}
i(br, "mapc");
var v = (_a = class {
  constructor(e = 0, o = e) {
    __publicField(this, "x", 0);
    __publicField(this, "y", 0);
    this.x = e, this.y = o;
  }
  static fromAngle(e) {
    let o = Ge(e);
    return new _a(Math.cos(o), Math.sin(o));
  }
  clone() {
    return new _a(this.x, this.y);
  }
  add(...e) {
    let o = T(...e);
    return new _a(this.x + o.x, this.y + o.y);
  }
  sub(...e) {
    let o = T(...e);
    return new _a(this.x - o.x, this.y - o.y);
  }
  scale(...e) {
    let o = T(...e);
    return new _a(this.x * o.x, this.y * o.y);
  }
  dist(...e) {
    let o = T(...e);
    return this.sub(o).len();
  }
  sdist(...e) {
    let o = T(...e);
    return this.sub(o).slen();
  }
  len() {
    return Math.sqrt(this.dot(this));
  }
  slen() {
    return this.dot(this);
  }
  unit() {
    let e = this.len();
    return e === 0 ? new _a(0) : this.scale(1 / e);
  }
  normal() {
    return new _a(this.y, -this.x);
  }
  reflect(e) {
    return this.sub(e.scale(2 * this.dot(e)));
  }
  project(e) {
    return e.scale(e.dot(this) / e.len());
  }
  reject(e) {
    return this.sub(this.project(e));
  }
  dot(e) {
    return this.x * e.x + this.y * e.y;
  }
  cross(e) {
    return this.x * e.y - this.y * e.x;
  }
  angle(...e) {
    let o = T(...e);
    return ot(Math.atan2(this.y - o.y, this.x - o.x));
  }
  angleBetween(...e) {
    let o = T(...e);
    return ot(Math.atan2(this.cross(o), this.dot(o)));
  }
  lerp(e, o) {
    return new _a(Ve(this.x, e.x, o), Ve(this.y, e.y, o));
  }
  slerp(e, o) {
    let c = this.dot(e), g = this.cross(e), m = Math.atan2(g, c);
    return this.scale(Math.sin((1 - o) * m)).add(e.scale(Math.sin(o * m))).scale(1 / g);
  }
  isZero() {
    return this.x === 0 && this.y === 0;
  }
  toFixed(e) {
    return new _a(Number(this.x.toFixed(e)), Number(this.y.toFixed(e)));
  }
  transform(e) {
    return e.multVec2(this);
  }
  eq(e) {
    return this.x === e.x && this.y === e.y;
  }
  bbox() {
    return new de(this, 0, 0);
  }
  toString() {
    return `vec2(${this.x.toFixed(2)}, ${this.y.toFixed(2)})`;
  }
}, i(_a, "Vec2"), __publicField(_a, "LEFT", new _a(-1, 0)), __publicField(_a, "RIGHT", new _a(1, 0)), __publicField(_a, "UP", new _a(0, -1)), __publicField(_a, "DOWN", new _a(0, 1)), _a);
function T(...n) {
  if (n.length === 1) {
    if (n[0] instanceof v) return new v(n[0].x, n[0].y);
    if (Array.isArray(n[0]) && n[0].length === 2) return new v(...n[0]);
  }
  return new v(...n);
}
i(T, "vec2");
var W = (_b = class {
  constructor(e, o, c) {
    __publicField(this, "r", 255);
    __publicField(this, "g", 255);
    __publicField(this, "b", 255);
    this.r = Le(e, 0, 255), this.g = Le(o, 0, 255), this.b = Le(c, 0, 255);
  }
  static fromArray(e) {
    return new _b(e[0], e[1], e[2]);
  }
  static fromHex(e) {
    if (typeof e == "number") return new _b(e >> 16 & 255, e >> 8 & 255, e >> 0 & 255);
    if (typeof e == "string") {
      let o = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(e);
      return new _b(parseInt(o[1], 16), parseInt(o[2], 16), parseInt(o[3], 16));
    } else throw new Error("Invalid hex color format");
  }
  static fromHSL(e, o, c) {
    if (o == 0) return new _b(255 * c, 255 * c, 255 * c);
    let g = i((X, S, q) => (q < 0 && (q += 1), q > 1 && (q -= 1), q < 1 / 6 ? X + (S - X) * 6 * q : q < 1 / 2 ? S : q < 2 / 3 ? X + (S - X) * (2 / 3 - q) * 6 : X), "hue2rgb"), m = c < 0.5 ? c * (1 + o) : c + o - c * o, P = 2 * c - m, I = g(P, m, e + 1 / 3), j = g(P, m, e), y = g(P, m, e - 1 / 3);
    return new _b(Math.round(I * 255), Math.round(j * 255), Math.round(y * 255));
  }
  clone() {
    return new _b(this.r, this.g, this.b);
  }
  lighten(e) {
    return new _b(this.r + e, this.g + e, this.b + e);
  }
  darken(e) {
    return this.lighten(-e);
  }
  invert() {
    return new _b(255 - this.r, 255 - this.g, 255 - this.b);
  }
  mult(e) {
    return new _b(this.r * e.r / 255, this.g * e.g / 255, this.b * e.b / 255);
  }
  lerp(e, o) {
    return new _b(Ve(this.r, e.r, o), Ve(this.g, e.g, o), Ve(this.b, e.b, o));
  }
  toHSL() {
    let e = this.r / 255, o = this.g / 255, c = this.b / 255, g = Math.max(e, o, c), m = Math.min(e, o, c), P = (g + m) / 2, I = P, j = P;
    if (g == m) P = I = 0;
    else {
      let y = g - m;
      switch (I = j > 0.5 ? y / (2 - g - m) : y / (g + m), g) {
        case e:
          P = (o - c) / y + (o < c ? 6 : 0);
          break;
        case o:
          P = (c - e) / y + 2;
          break;
        case c:
          P = (e - o) / y + 4;
          break;
      }
      P /= 6;
    }
    return [P, I, j];
  }
  eq(e) {
    return this.r === e.r && this.g === e.g && this.b === e.b;
  }
  toString() {
    return `rgb(${this.r}, ${this.g}, ${this.b})`;
  }
  toHex() {
    return "#" + ((1 << 24) + (this.r << 16) + (this.g << 8) + this.b).toString(16).slice(1);
  }
}, i(_b, "Color"), __publicField(_b, "RED", new _b(255, 0, 0)), __publicField(_b, "GREEN", new _b(0, 255, 0)), __publicField(_b, "BLUE", new _b(0, 0, 255)), __publicField(_b, "YELLOW", new _b(255, 255, 0)), __publicField(_b, "MAGENTA", new _b(255, 0, 255)), __publicField(_b, "CYAN", new _b(0, 255, 255)), __publicField(_b, "WHITE", new _b(255, 255, 255)), __publicField(_b, "BLACK", new _b(0, 0, 0)), _b);
function J(...n) {
  if (n.length === 0) return new W(255, 255, 255);
  if (n.length === 1) {
    if (n[0] instanceof W) return n[0].clone();
    if (typeof n[0] == "string") return W.fromHex(n[0]);
    if (Array.isArray(n[0]) && n[0].length === 3) return W.fromArray(n[0]);
  }
  return new W(...n);
}
i(J, "rgb");
var vr = i((n, e, o) => W.fromHSL(n, e, o), "hsl2rgb"), oe = (_c = class {
  constructor(e, o, c, g) {
    __publicField(this, "x", 0);
    __publicField(this, "y", 0);
    __publicField(this, "w", 1);
    __publicField(this, "h", 1);
    this.x = e, this.y = o, this.w = c, this.h = g;
  }
  scale(e) {
    return new _c(this.x + this.w * e.x, this.y + this.h * e.y, this.w * e.w, this.h * e.h);
  }
  pos() {
    return new v(this.x, this.y);
  }
  clone() {
    return new _c(this.x, this.y, this.w, this.h);
  }
  eq(e) {
    return this.x === e.x && this.y === e.y && this.w === e.w && this.h === e.h;
  }
  toString() {
    return `quad(${this.x}, ${this.y}, ${this.w}, ${this.h})`;
  }
}, i(_c, "Quad"), _c);
function ce(n, e, o, c) {
  return new oe(n, e, o, c);
}
i(ce, "quad");
var Ue = (_d = class {
  constructor(e) {
    __publicField(this, "m", [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
    e && (this.m = e);
  }
  static translate(e) {
    return new _d([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, e.x, e.y, 0, 1]);
  }
  static scale(e) {
    return new _d([e.x, 0, 0, 0, 0, e.y, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
  }
  static rotateX(e) {
    e = Ge(-e);
    let o = Math.cos(e), c = Math.sin(e);
    return new _d([1, 0, 0, 0, 0, o, -c, 0, 0, c, o, 0, 0, 0, 0, 1]);
  }
  static rotateY(e) {
    e = Ge(-e);
    let o = Math.cos(e), c = Math.sin(e);
    return new _d([o, 0, c, 0, 0, 1, 0, 0, -c, 0, o, 0, 0, 0, 0, 1]);
  }
  static rotateZ(e) {
    e = Ge(-e);
    let o = Math.cos(e), c = Math.sin(e);
    return new _d([o, -c, 0, 0, c, o, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
  }
  translate(e) {
    return this.m[12] += this.m[0] * e.x + this.m[4] * e.y, this.m[13] += this.m[1] * e.x + this.m[5] * e.y, this.m[14] += this.m[2] * e.x + this.m[6] * e.y, this.m[15] += this.m[3] * e.x + this.m[7] * e.y, this;
  }
  scale(e) {
    return this.m[0] *= e.x, this.m[4] *= e.y, this.m[1] *= e.x, this.m[5] *= e.y, this.m[2] *= e.x, this.m[6] *= e.y, this.m[3] *= e.x, this.m[7] *= e.y, this;
  }
  rotate(e) {
    e = Ge(-e);
    let o = Math.cos(e), c = Math.sin(e), g = this.m[0], m = this.m[1], P = this.m[4], I = this.m[5];
    return this.m[0] = g * o + m * c, this.m[1] = -g * c + m * o, this.m[4] = P * o + I * c, this.m[5] = -P * c + I * o, this;
  }
  mult(e) {
    let o = [];
    for (let c = 0; c < 4; c++) for (let g = 0; g < 4; g++) o[c * 4 + g] = this.m[0 * 4 + g] * e.m[c * 4 + 0] + this.m[1 * 4 + g] * e.m[c * 4 + 1] + this.m[2 * 4 + g] * e.m[c * 4 + 2] + this.m[3 * 4 + g] * e.m[c * 4 + 3];
    return new _d(o);
  }
  multVec2(e) {
    return new v(e.x * this.m[0] + e.y * this.m[4] + this.m[12], e.x * this.m[1] + e.y * this.m[5] + this.m[13]);
  }
  getTranslation() {
    return new v(this.m[12], this.m[13]);
  }
  getScale() {
    if (this.m[0] != 0 || this.m[1] != 0) {
      let e = this.m[0] * this.m[5] - this.m[1] * this.m[4], o = Math.sqrt(this.m[0] * this.m[0] + this.m[1] * this.m[1]);
      return new v(o, e / o);
    } else if (this.m[4] != 0 || this.m[5] != 0) {
      let e = this.m[0] * this.m[5] - this.m[1] * this.m[4], o = Math.sqrt(this.m[4] * this.m[4] + this.m[5] * this.m[5]);
      return new v(e / o, o);
    } else return new v(0, 0);
  }
  getRotation() {
    if (this.m[0] != 0 || this.m[1] != 0) {
      let e = Math.sqrt(this.m[0] * this.m[0] + this.m[1] * this.m[1]);
      return ot(this.m[1] > 0 ? Math.acos(this.m[0] / e) : -Math.acos(this.m[0] / e));
    } else if (this.m[4] != 0 || this.m[5] != 0) {
      let e = Math.sqrt(this.m[4] * this.m[4] + this.m[5] * this.m[5]);
      return ot(Math.PI / 2 - (this.m[5] > 0 ? Math.acos(-this.m[4] / e) : -Math.acos(this.m[4] / e)));
    } else return 0;
  }
  getSkew() {
    if (this.m[0] != 0 || this.m[1] != 0) {
      let e = Math.sqrt(this.m[0] * this.m[0] + this.m[1] * this.m[1]);
      return new v(Math.atan(this.m[0] * this.m[4] + this.m[1] * this.m[5]) / (e * e), 0);
    } else if (this.m[4] != 0 || this.m[5] != 0) {
      let e = Math.sqrt(this.m[4] * this.m[4] + this.m[5] * this.m[5]);
      return new v(0, Math.atan(this.m[0] * this.m[4] + this.m[1] * this.m[5]) / (e * e));
    } else return new v(0, 0);
  }
  invert() {
    let e = [], o = this.m[10] * this.m[15] - this.m[14] * this.m[11], c = this.m[9] * this.m[15] - this.m[13] * this.m[11], g = this.m[9] * this.m[14] - this.m[13] * this.m[10], m = this.m[8] * this.m[15] - this.m[12] * this.m[11], P = this.m[8] * this.m[14] - this.m[12] * this.m[10], I = this.m[8] * this.m[13] - this.m[12] * this.m[9], j = this.m[6] * this.m[15] - this.m[14] * this.m[7], y = this.m[5] * this.m[15] - this.m[13] * this.m[7], X = this.m[5] * this.m[14] - this.m[13] * this.m[6], S = this.m[4] * this.m[15] - this.m[12] * this.m[7], q = this.m[4] * this.m[14] - this.m[12] * this.m[6], E = this.m[5] * this.m[15] - this.m[13] * this.m[7], K = this.m[4] * this.m[13] - this.m[12] * this.m[5], Q = this.m[6] * this.m[11] - this.m[10] * this.m[7], te = this.m[5] * this.m[11] - this.m[9] * this.m[7], k = this.m[5] * this.m[10] - this.m[9] * this.m[6], pe = this.m[4] * this.m[11] - this.m[8] * this.m[7], C = this.m[4] * this.m[10] - this.m[8] * this.m[6], Ae = this.m[4] * this.m[9] - this.m[8] * this.m[5];
    e[0] = this.m[5] * o - this.m[6] * c + this.m[7] * g, e[4] = -(this.m[4] * o - this.m[6] * m + this.m[7] * P), e[8] = this.m[4] * c - this.m[5] * m + this.m[7] * I, e[12] = -(this.m[4] * g - this.m[5] * P + this.m[6] * I), e[1] = -(this.m[1] * o - this.m[2] * c + this.m[3] * g), e[5] = this.m[0] * o - this.m[2] * m + this.m[3] * P, e[9] = -(this.m[0] * c - this.m[1] * m + this.m[3] * I), e[13] = this.m[0] * g - this.m[1] * P + this.m[2] * I, e[2] = this.m[1] * j - this.m[2] * y + this.m[3] * X, e[6] = -(this.m[0] * j - this.m[2] * S + this.m[3] * q), e[10] = this.m[0] * E - this.m[1] * S + this.m[3] * K, e[14] = -(this.m[0] * X - this.m[1] * q + this.m[2] * K), e[3] = -(this.m[1] * Q - this.m[2] * te + this.m[3] * k), e[7] = this.m[0] * Q - this.m[2] * pe + this.m[3] * C, e[11] = -(this.m[0] * te - this.m[1] * pe + this.m[3] * Ae), e[15] = this.m[0] * k - this.m[1] * C + this.m[2] * Ae;
    let $ = this.m[0] * e[0] + this.m[1] * e[4] + this.m[2] * e[8] + this.m[3] * e[12];
    for (let Te = 0; Te < 4; Te++) for (let ye = 0; ye < 4; ye++) e[Te * 4 + ye] *= 1 / $;
    return new _d(e);
  }
  clone() {
    return new _d([...this.m]);
  }
  toString() {
    return this.m.toString();
  }
}, i(_d, "Mat4"), _d);
function In(n, e, o, c = (g) => -Math.cos(g)) {
  return n + (c(o) + 1) / 2 * (e - n);
}
i(In, "wave");
var xi = 1103515245, Ui = 12345, wr = 2147483648, bt = (_e2 = class {
  constructor(e) {
    __publicField(this, "seed");
    this.seed = e;
  }
  gen() {
    return this.seed = (xi * this.seed + Ui) % wr, this.seed / wr;
  }
  genNumber(e, o) {
    return e + this.gen() * (o - e);
  }
  genVec2(e, o) {
    return new v(this.genNumber(e.x, o.x), this.genNumber(e.y, o.y));
  }
  genColor(e, o) {
    return new W(this.genNumber(e.r, o.r), this.genNumber(e.g, o.g), this.genNumber(e.b, o.b));
  }
  genAny(...e) {
    if (e.length === 0) return this.gen();
    if (e.length === 1) {
      if (typeof e[0] == "number") return this.genNumber(0, e[0]);
      if (e[0] instanceof v) return this.genVec2(T(0, 0), e[0]);
      if (e[0] instanceof W) return this.genColor(J(0, 0, 0), e[0]);
    } else if (e.length === 2) {
      if (typeof e[0] == "number" && typeof e[1] == "number") return this.genNumber(e[0], e[1]);
      if (e[0] instanceof v && e[1] instanceof v) return this.genVec2(e[0], e[1]);
      if (e[0] instanceof W && e[1] instanceof W) return this.genColor(e[0], e[1]);
    }
  }
}, i(_e2, "RNG"), _e2), Bn = new bt(Date.now());
function yr(n) {
  return n != null && (Bn.seed = n), Bn.seed;
}
i(yr, "randSeed");
function xt(...n) {
  return Bn.genAny(...n);
}
i(xt, "rand");
function Ln(...n) {
  return Math.floor(xt(...n));
}
i(Ln, "randi");
function xr(n) {
  return xt() <= n;
}
i(xr, "chance");
function Ur(n) {
  return n[Ln(n.length)];
}
i(Ur, "choose");
function Er(n, e) {
  return n.pos.x + n.width > e.pos.x && n.pos.x < e.pos.x + e.width && n.pos.y + n.height > e.pos.y && n.pos.y < e.pos.y + e.height;
}
i(Er, "testRectRect");
function Ei(n, e) {
  if (n.p1.x === n.p2.x && n.p1.y === n.p2.y || e.p1.x === e.p2.x && e.p1.y === e.p2.y) return null;
  let o = (e.p2.y - e.p1.y) * (n.p2.x - n.p1.x) - (e.p2.x - e.p1.x) * (n.p2.y - n.p1.y);
  if (o === 0) return null;
  let c = ((e.p2.x - e.p1.x) * (n.p1.y - e.p1.y) - (e.p2.y - e.p1.y) * (n.p1.x - e.p1.x)) / o, g = ((n.p2.x - n.p1.x) * (n.p1.y - e.p1.y) - (n.p2.y - n.p1.y) * (n.p1.x - e.p1.x)) / o;
  return c < 0 || c > 1 || g < 0 || g > 1 ? null : c;
}
i(Ei, "testLineLineT");
function it(n, e) {
  let o = Ei(n, e);
  return o ? T(n.p1.x + o * (n.p2.x - n.p1.x), n.p1.y + o * (n.p2.y - n.p1.y)) : null;
}
i(it, "testLineLine");
function Sr(n, e) {
  if (vt(n, e.p1) || vt(n, e.p2)) return true;
  let o = n.points();
  return !!it(e, new Ie(o[0], o[1])) || !!it(e, new Ie(o[1], o[2])) || !!it(e, new Ie(o[2], o[3])) || !!it(e, new Ie(o[3], o[0]));
}
i(Sr, "testRectLine");
function vt(n, e) {
  return e.x > n.pos.x && e.x < n.pos.x + n.width && e.y > n.pos.y && e.y < n.pos.y + n.height;
}
i(vt, "testRectPoint");
function Cr(n, e) {
  let o = e.sub(n.p1), c = n.p2.sub(n.p1);
  if (Math.abs(o.cross(c)) > Number.EPSILON) return false;
  let g = o.dot(c) / c.dot(c);
  return g >= 0 && g <= 1;
}
i(Cr, "testLinePoint");
function Vn(n, e) {
  let o = n.p2.sub(n.p1), c = o.dot(o), g = n.p1.sub(e.center), m = 2 * o.dot(g), P = g.dot(g) - e.radius * e.radius, I = m * m - 4 * c * P;
  if (c <= Number.EPSILON || I < 0) return false;
  if (I == 0) {
    let j = -m / (2 * c);
    if (j >= 0 && j <= 1) return true;
  } else {
    let j = (-m + Math.sqrt(I)) / (2 * c), y = (-m - Math.sqrt(I)) / (2 * c);
    if (j >= 0 && j <= 1 || y >= 0 && y <= 1) return true;
  }
  return Ar(e, n.p1);
}
i(Vn, "testLineCircle");
function Ar(n, e) {
  return n.center.sdist(e) < n.radius * n.radius;
}
i(Ar, "testCirclePoint");
function Tr(n, e) {
  let o = e.pts[e.pts.length - 1];
  for (let c of e.pts) {
    if (Vn(new Ie(o, c), n)) return true;
    o = c;
  }
  return Ar(n, e.pts[0]) ? true : _n(e, n.center);
}
i(Tr, "testCirclePolygon");
function _n(n, e) {
  let o = false, c = n.pts;
  for (let g = 0, m = c.length - 1; g < c.length; m = g++) c[g].y > e.y != c[m].y > e.y && e.x < (c[m].x - c[g].x) * (e.y - c[g].y) / (c[m].y - c[g].y) + c[g].x && (o = !o);
  return o;
}
i(_n, "testPolygonPoint");
var Ie = (_f = class {
  constructor(e, o) {
    __publicField(this, "p1");
    __publicField(this, "p2");
    this.p1 = e.clone(), this.p2 = o.clone();
  }
  transform(e) {
    return new _f(e.multVec2(this.p1), e.multVec2(this.p2));
  }
  bbox() {
    return de.fromPoints(this.p1, this.p2);
  }
  area() {
    return this.p1.dist(this.p2);
  }
  clone() {
    return new _f(this.p1, this.p2);
  }
}, i(_f, "Line"), _f), de = (_g = class {
  constructor(e, o, c) {
    __publicField(this, "pos");
    __publicField(this, "width");
    __publicField(this, "height");
    this.pos = e.clone(), this.width = o, this.height = c;
  }
  static fromPoints(e, o) {
    return new _g(e.clone(), o.x - e.x, o.y - e.y);
  }
  center() {
    return new v(this.pos.x + this.width / 2, this.pos.y + this.height / 2);
  }
  points() {
    return [this.pos, this.pos.add(this.width, 0), this.pos.add(this.width, this.height), this.pos.add(0, this.height)];
  }
  transform(e) {
    return new Ke(this.points().map((o) => e.multVec2(o)));
  }
  bbox() {
    return this.clone();
  }
  area() {
    return this.width * this.height;
  }
  clone() {
    return new _g(this.pos.clone(), this.width, this.height);
  }
  distToPoint(e) {
    return Math.sqrt(this.sdistToPoint(e));
  }
  sdistToPoint(e) {
    let o = this.pos, c = this.pos.add(this.width, this.height), g = Math.max(o.x - e.x, 0, e.x - c.x), m = Math.max(o.y - e.y, 0, e.y - c.y);
    return g * g + m * m;
  }
}, i(_g, "Rect"), _g), yt = (_h = class {
  constructor(e, o) {
    __publicField(this, "center");
    __publicField(this, "radius");
    this.center = e.clone(), this.radius = o;
  }
  transform(e) {
    return new Fn(this.center, this.radius, this.radius).transform(e);
  }
  bbox() {
    return de.fromPoints(this.center.sub(T(this.radius)), this.center.add(T(this.radius)));
  }
  area() {
    return this.radius * this.radius * Math.PI;
  }
  clone() {
    return new _h(this.center, this.radius);
  }
}, i(_h, "Circle"), _h), Fn = (_i = class {
  constructor(e, o, c) {
    __publicField(this, "center");
    __publicField(this, "radiusX");
    __publicField(this, "radiusY");
    this.center = e.clone(), this.radiusX = o, this.radiusY = c;
  }
  transform(e) {
    return new _i(e.multVec2(this.center), e.m[0] * this.radiusX, e.m[5] * this.radiusY);
  }
  bbox() {
    return de.fromPoints(this.center.sub(T(this.radiusX, this.radiusY)), this.center.add(T(this.radiusX, this.radiusY)));
  }
  area() {
    return this.radiusX * this.radiusY * Math.PI;
  }
  clone() {
    return new _i(this.center, this.radiusX, this.radiusY);
  }
}, i(_i, "Ellipse"), _i), Ke = (_j = class {
  constructor(e) {
    __publicField(this, "pts");
    if (e.length < 3) throw new Error("Polygons should have at least 3 vertices");
    this.pts = e;
  }
  transform(e) {
    return new _j(this.pts.map((o) => e.multVec2(o)));
  }
  bbox() {
    let e = T(Number.MAX_VALUE), o = T(-Number.MAX_VALUE);
    for (let c of this.pts) e.x = Math.min(e.x, c.x), o.x = Math.max(o.x, c.x), e.y = Math.min(e.y, c.y), o.y = Math.max(o.y, c.y);
    return de.fromPoints(e, o);
  }
  area() {
    let e = 0, o = this.pts.length;
    for (let c = 0; c < o; c++) {
      let g = this.pts[c], m = this.pts[(c + 1) % o];
      e += g.x * m.y * 0.5, e -= m.x * g.y * 0.5;
    }
    return Math.abs(e);
  }
  clone() {
    return new _j(this.pts.map((e) => e.clone()));
  }
}, i(_j, "Polygon"), _j);
function Or(n, e) {
  let o = Number.MAX_VALUE, c = T(0);
  for (let g of [n, e]) for (let m = 0; m < g.pts.length; m++) {
    let P = g.pts[m], j = g.pts[(m + 1) % g.pts.length].sub(P).normal().unit(), y = Number.MAX_VALUE, X = -Number.MAX_VALUE;
    for (let K = 0; K < n.pts.length; K++) {
      let Q = n.pts[K].dot(j);
      y = Math.min(y, Q), X = Math.max(X, Q);
    }
    let S = Number.MAX_VALUE, q = -Number.MAX_VALUE;
    for (let K = 0; K < e.pts.length; K++) {
      let Q = e.pts[K].dot(j);
      S = Math.min(S, Q), q = Math.max(q, Q);
    }
    let E = Math.min(X, q) - Math.max(y, S);
    if (E < 0) return null;
    if (E < Math.abs(o)) {
      let K = q - y, Q = S - X;
      o = Math.abs(K) < Math.abs(Q) ? K : Q, c = j.scale(o);
    }
  }
  return c;
}
i(Or, "sat");
var Ut = (_k = class extends Map {
  constructor(...e) {
    super(...e);
    __publicField(this, "lastID");
    this.lastID = 0;
  }
  push(e) {
    let o = this.lastID;
    return this.set(o, e), this.lastID++, o;
  }
  pushd(e) {
    let o = this.push(e);
    return () => this.delete(o);
  }
}, i(_k, "Registry"), _k), ke = (_l = class {
  constructor(e) {
    __publicField(this, "paused", false);
    __publicField(this, "cancel");
    this.cancel = e;
  }
  static join(e) {
    let o = new _l(() => e.forEach((c) => c.cancel()));
    return Object.defineProperty(o, "paused", { get: () => e[0].paused, set: (c) => e.forEach((g) => g.paused = c) }), o.paused = false, o;
  }
}, i(_l, "EventController"), _l), be = (_m = class {
  constructor() {
    __publicField(this, "handlers", new Ut());
  }
  add(e) {
    let o = this.handlers.pushd((...g) => {
      c.paused || e(...g);
    }), c = new ke(o);
    return c;
  }
  addOnce(e) {
    let o = this.add((...c) => {
      o.cancel(), e(...c);
    });
    return o;
  }
  next() {
    return new Promise((e) => this.addOnce(e));
  }
  trigger(...e) {
    this.handlers.forEach((o) => o(...e));
  }
  numListeners() {
    return this.handlers.size;
  }
  clear() {
    this.handlers.clear();
  }
}, i(_m, "Event"), _m), Ne = (_n2 = class {
  constructor() {
    __publicField(this, "handlers", {});
  }
  on(e, o) {
    return this.handlers[e] || (this.handlers[e] = new be()), this.handlers[e].add(o);
  }
  onOnce(e, o) {
    let c = this.on(e, (...g) => {
      c.cancel(), o(...g);
    });
    return c;
  }
  next(e) {
    return new Promise((o) => {
      this.onOnce(e, (...c) => o(c[0]));
    });
  }
  trigger(e, ...o) {
    this.handlers[e] && this.handlers[e].trigger(...o);
  }
  remove(e) {
    delete this.handlers[e];
  }
  clear() {
    this.handlers = {};
  }
  numListeners(e) {
    return this.handlers[e]?.numListeners() ?? 0;
  }
}, i(_n2, "EventHandler"), _n2);
function Wt(n, e) {
  if (n === e) return true;
  let o = typeof n, c = typeof e;
  if (o !== c) return false;
  if (o === "object" && c === "object" && n !== null && e !== null) {
    if (Array.isArray(n) !== Array.isArray(e)) return false;
    let g = Object.keys(n), m = Object.keys(e);
    if (g.length !== m.length) return false;
    for (let P of g) {
      let I = n[P], j = e[P];
      if (!Wt(I, j)) return false;
    }
    return true;
  }
  return false;
}
i(Wt, "deepEq");
function Si(n) {
  let e = window.atob(n), o = e.length, c = new Uint8Array(o);
  for (let g = 0; g < o; g++) c[g] = e.charCodeAt(g);
  return c.buffer;
}
i(Si, "base64ToArrayBuffer");
function Pr(n) {
  return Si(n.split(",")[1]);
}
i(Pr, "dataURLToArrayBuffer");
function Xt(n, e) {
  let o = document.createElement("a");
  o.href = e, o.download = n, o.click();
}
i(Xt, "download");
function kn(n, e) {
  Xt(n, "data:text/plain;charset=utf-8," + e);
}
i(kn, "downloadText");
function Dr(n, e) {
  kn(n, JSON.stringify(e));
}
i(Dr, "downloadJSON");
function Nn(n, e) {
  let o = URL.createObjectURL(e);
  Xt(n, o), URL.revokeObjectURL(o);
}
i(Nn, "downloadBlob");
var jn = i((n) => n.match(/^data:\w+\/\w+;base64,.+/), "isDataURL");
var Mr = i((n) => n.split(".").slice(0, -1).join("."), "getFileName");
function Ee(n, e) {
  return (...o) => {
    let c = o.length;
    if (c === n.length) return n(...o);
    if (c === e.length) return e(...o);
  };
}
i(Ee, "overload2");
var Gr = /* @__PURE__ */ (() => {
  let n = 0;
  return () => n++;
})(), Br = i((n) => n instanceof Error ? n.message : String(n), "getErrorMessage");
var Yt = (_o = class {
  constructor(e = (o, c) => o < c) {
    __publicField(this, "_items");
    __publicField(this, "_compareFn");
    this._compareFn = e, this._items = [];
  }
  insert(e) {
    this._items.push(e), this.moveUp(this._items.length - 1);
  }
  remove() {
    if (this._items.length === 0) return null;
    let e = this._items[0], o = this._items.pop();
    return this._items.length !== 0 && (this._items[0] = o, this.moveDown(0)), e;
  }
  clear() {
    this._items.splice(0, this._items.length);
  }
  moveUp(e) {
    for (; e > 0; ) {
      let o = Math.floor((e - 1) / 2);
      if (!this._compareFn(this._items[e], this._items[o]) && this._items[e] >= this._items[o]) break;
      this.swap(e, o), e = o;
    }
  }
  moveDown(e) {
    for (; e < Math.floor(this._items.length / 2); ) {
      let o = 2 * e + 1;
      if (o < this._items.length - 1 && !this._compareFn(this._items[o], this._items[o + 1]) && ++o, this._compareFn(this._items[e], this._items[o])) break;
      this.swap(e, o), e = o;
    }
  }
  swap(e, o) {
    [this._items[e], this._items[o]] = [this._items[o], this._items[e]];
  }
  get length() {
    return this._items.length;
  }
}, i(_o, "BinaryHeap"), _o);
var Ci = Object.freeze([776, 2359, 2367, 2984, 3007, 3021, 3633, 3635, 3648, 3657, 4352, 4449, 4520]);
function Fr(n) {
  if (typeof n != "string") throw new TypeError("string cannot be undefined or null");
  let e = [], o = 0, c = 0;
  for (; o < n.length; ) {
    if (c += Ai(o + c, n), Gi(n[o + c]) && c++, Pi(n[o + c]) && c++, Di(n[o + c]) && c++, Bi(n[o + c])) {
      c++;
      continue;
    }
    e.push(n.substring(o, o + c)), o += c, c = 0;
  }
  return e;
}
i(Fr, "runes");
function Ai(n, e) {
  let o = e[n];
  if (!Ti(o) || n === e.length - 1) return 1;
  let c = o + e[n + 1], g = e.substring(n + 2, n + 5);
  return Rr(c) && Rr(g) ? 4 : Oi(c) && Mi(g) ? e.slice(n).indexOf(String.fromCodePoint(917631)) + 2 : Ri(g) ? 4 : 2;
}
i(Ai, "nextUnits");
function Ti(n) {
  return n && tt(n[0].charCodeAt(0), 55296, 56319);
}
i(Ti, "isFirstOfSurrogatePair");
function Rr(n) {
  return tt(Hn(n), 127462, 127487);
}
i(Rr, "isRegionalIndicator");
function Oi(n) {
  return tt(Hn(n), 127988, 127988);
}
i(Oi, "isSubdivisionFlag");
function Ri(n) {
  return tt(Hn(n), 127995, 127999);
}
i(Ri, "isFitzpatrickModifier");
function Pi(n) {
  return typeof n == "string" && tt(n.charCodeAt(0), 65024, 65039);
}
i(Pi, "isVariationSelector");
function Di(n) {
  return typeof n == "string" && tt(n.charCodeAt(0), 8400, 8447);
}
i(Di, "isDiacriticalMark");
function Mi(n) {
  let e = n.codePointAt(0);
  return typeof n == "string" && typeof e == "number" && tt(e, 917504, 917631);
}
i(Mi, "isSupplementarySpecialpurposePlane");
function Gi(n) {
  return typeof n == "string" && Ci.includes(n.charCodeAt(0));
}
i(Gi, "isGrapheme");
function Bi(n) {
  return typeof n == "string" && n.charCodeAt(0) === 8205;
}
i(Bi, "isZeroWidthJoiner");
function Hn(n) {
  let e = n.charCodeAt(0) - 55296, o = n.charCodeAt(1) - 56320;
  return (e << 10) + o + 65536;
}
i(Hn, "codePointFromSurrogatePair");
function tt(n, e, o) {
  return n >= e && n <= o;
}
i(tt, "betweenInclusive");
var qn = { "Joy-Con L+R (STANDARD GAMEPAD Vendor: 057e Product: 200e)": { buttons: { "0": "south", "1": "east", "2": "west", "3": "north", "4": "lshoulder", "5": "rshoulder", "6": "ltrigger", "7": "rtrigger", "8": "select", "9": "start", "10": "lstick", "11": "rstick", "12": "dpad-up", "13": "dpad-down", "14": "dpad-left", "15": "dpad-right", "16": "home", "17": "capture" }, sticks: { left: { x: 0, y: 1 }, right: { x: 2, y: 3 } } }, "Joy-Con (L) (STANDARD GAMEPAD Vendor: 057e Product: 2006)": { buttons: { "0": "south", "1": "east", "2": "west", "3": "north", "4": "lshoulder", "5": "rshoulder", "9": "select", "10": "lstick", "16": "start" }, sticks: { left: { x: 0, y: 1 } } }, "Joy-Con (R) (STANDARD GAMEPAD Vendor: 057e Product: 2007)": { buttons: { "0": "south", "1": "east", "2": "west", "3": "north", "4": "lshoulder", "5": "rshoulder", "9": "start", "10": "lstick", "16": "select" }, sticks: { left: { x: 0, y: 1 } } }, "Pro Controller (STANDARD GAMEPAD Vendor: 057e Product: 2009)": { buttons: { "0": "south", "1": "east", "2": "west", "3": "north", "4": "lshoulder", "5": "rshoulder", "6": "ltrigger", "7": "rtrigger", "8": "select", "9": "start", "10": "lstick", "11": "rstick", "12": "dpad-up", "13": "dpad-down", "14": "dpad-left", "15": "dpad-right", "16": "home", "17": "capture" }, sticks: { left: { x: 0, y: 1 }, right: { x: 2, y: 3 } } }, default: { buttons: { "0": "south", "1": "east", "2": "west", "3": "north", "4": "lshoulder", "5": "rshoulder", "6": "ltrigger", "7": "rtrigger", "8": "select", "9": "start", "10": "lstick", "11": "rstick", "12": "dpad-up", "13": "dpad-down", "14": "dpad-left", "15": "dpad-right", "16": "home" }, sticks: { left: { x: 0, y: 1 }, right: { x: 2, y: 3 } } } };
var at = (_p = class {
  constructor() {
    __publicField(this, "pressed", /* @__PURE__ */ new Set([]));
    __publicField(this, "pressedRepeat", /* @__PURE__ */ new Set([]));
    __publicField(this, "released", /* @__PURE__ */ new Set([]));
    __publicField(this, "down", /* @__PURE__ */ new Set([]));
  }
  update() {
    this.pressed.clear(), this.released.clear(), this.pressedRepeat.clear();
  }
  press(e) {
    this.pressed.add(e), this.pressedRepeat.add(e), this.down.add(e);
  }
  pressRepeat(e) {
    this.pressedRepeat.add(e);
  }
  release(e) {
    this.down.delete(e), this.pressed.delete(e), this.released.add(e);
  }
}, i(_p, "ButtonState"), _p), $n = (_q = class {
  constructor() {
    __publicField(this, "buttonState", new at());
    __publicField(this, "stickState", /* @__PURE__ */ new Map());
  }
}, i(_q, "GamepadState"), _q), zn = (_r2 = class {
  constructor() {
    __publicField(this, "dts", []);
    __publicField(this, "timer", 0);
    __publicField(this, "fps", 0);
  }
  tick(e) {
    this.dts.push(e), this.timer += e, this.timer >= 1 && (this.timer = 0, this.fps = Math.round(1 / (this.dts.reduce((o, c) => o + c) / this.dts.length)), this.dts = []);
  }
}, i(_r2, "FPSCounter"), _r2), Ir = i((n) => {
  if (!n.canvas) throw new Error("Please provide a canvas");
  let e = { canvas: n.canvas, loopID: null, stopped: false, dt: 0, time: 0, realTime: 0, fpsCounter: new zn(), timeScale: 1, skipTime: false, numFrames: 0, mousePos: new v(0), mouseDeltaPos: new v(0), keyState: new at(), mouseState: new at(), mergedGamepadState: new $n(), gamepadStates: /* @__PURE__ */ new Map(), gamepads: [], charInputted: [], isMouseMoved: false, lastWidth: n.canvas.offsetWidth, lastHeight: n.canvas.offsetHeight, events: new Ne() };
  function o() {
    return e.dt * e.timeScale;
  }
  i(o, "dt");
  function c() {
    return e.time;
  }
  i(c, "time");
  function g() {
    return e.fpsCounter.fps;
  }
  i(g, "fps");
  function m() {
    return e.numFrames;
  }
  i(m, "numFrames");
  function P() {
    return e.canvas.toDataURL();
  }
  i(P, "screenshot");
  function I(l) {
    e.canvas.style.cursor = l;
  }
  i(I, "setCursor");
  function j() {
    return e.canvas.style.cursor;
  }
  i(j, "getCursor");
  function y(l) {
    if (l) try {
      let x = e.canvas.requestPointerLock();
      x.catch && x.catch((R) => console.error(R));
    } catch (x) {
      console.error(x);
    }
    else document.exitPointerLock();
  }
  i(y, "setCursorLocked");
  function X() {
    return !!document.pointerLockElement;
  }
  i(X, "isCursorLocked");
  function S(l) {
    l.requestFullscreen ? l.requestFullscreen() : l.webkitRequestFullscreen && l.webkitRequestFullscreen();
  }
  i(S, "enterFullscreen");
  function q() {
    document.exitFullscreen ? document.exitFullscreen() : document.webkitExitFullScreen && document.webkitExitFullScreen();
  }
  i(q, "exitFullscreen");
  function E() {
    return document.fullscreenElement || document.webkitFullscreenElement;
  }
  i(E, "getFullscreenElement");
  function K(l = true) {
    l ? S(e.canvas) : q();
  }
  i(K, "setFullscreen");
  function Q() {
    return !!E();
  }
  i(Q, "isFullscreen");
  function te() {
    e.stopped = true;
    for (let l in se) e.canvas.removeEventListener(l, se[l]);
    for (let l in le) document.removeEventListener(l, le[l]);
    for (let l in ae) window.removeEventListener(l, ae[l]);
    ge.disconnect();
  }
  i(te, "quit");
  function k(l) {
    e.loopID !== null && cancelAnimationFrame(e.loopID);
    let x = 0, R = i((L) => {
      if (e.stopped) return;
      if (document.visibilityState !== "visible") {
        e.loopID = requestAnimationFrame(R);
        return;
      }
      let he = L / 1e3, z = he - e.realTime, Oe = n.maxFPS ? 1 / n.maxFPS : 0;
      e.realTime = he, x += z, x > Oe && (e.skipTime || (e.dt = x, e.time += o(), e.fpsCounter.tick(e.dt)), x = 0, e.skipTime = false, e.numFrames++, ft(), l(), vn()), e.loopID = requestAnimationFrame(R);
    }, "frame");
    R(0);
  }
  i(k, "run");
  function pe() {
    return "ontouchstart" in window || navigator.maxTouchPoints > 0;
  }
  i(pe, "isTouchscreen");
  function C() {
    return e.mousePos.clone();
  }
  i(C, "mousePos");
  function Ae() {
    return e.mouseDeltaPos.clone();
  }
  i(Ae, "mouseDeltaPos");
  function $(l = "left") {
    return e.mouseState.pressed.has(l);
  }
  i($, "isMousePressed");
  function Te(l = "left") {
    return e.mouseState.down.has(l);
  }
  i(Te, "isMouseDown");
  function ye(l = "left") {
    return e.mouseState.released.has(l);
  }
  i(ye, "isMouseReleased");
  function Se() {
    return e.isMouseMoved;
  }
  i(Se, "isMouseMoved");
  function st(l) {
    return l === void 0 ? e.keyState.pressed.size > 0 : e.keyState.pressed.has(l);
  }
  i(st, "isKeyPressed");
  function on(l) {
    return l === void 0 ? e.keyState.pressedRepeat.size > 0 : e.keyState.pressedRepeat.has(l);
  }
  i(on, "isKeyPressedRepeat");
  function Tt(l) {
    return l === void 0 ? e.keyState.down.size > 0 : e.keyState.down.has(l);
  }
  i(Tt, "isKeyDown");
  function Ot(l) {
    return l === void 0 ? e.keyState.released.size > 0 : e.keyState.released.has(l);
  }
  i(Ot, "isKeyReleased");
  function Rt(l) {
    return l === void 0 ? e.mergedGamepadState.buttonState.pressed.size > 0 : e.mergedGamepadState.buttonState.pressed.has(l);
  }
  i(Rt, "isGamepadButtonPressed");
  function Ye(l) {
    return l === void 0 ? e.mergedGamepadState.buttonState.down.size > 0 : e.mergedGamepadState.buttonState.down.has(l);
  }
  i(Ye, "isGamepadButtonDown");
  function an(l) {
    return l === void 0 ? e.mergedGamepadState.buttonState.released.size > 0 : e.mergedGamepadState.buttonState.released.has(l);
  }
  i(an, "isGamepadButtonReleased");
  function un(l) {
    return e.events.on("resize", l);
  }
  i(un, "onResize");
  let cn = Ee((l) => e.events.on("keyDown", l), (l, x) => e.events.on("keyDown", (R) => R === l && x(l))), hn = Ee((l) => e.events.on("keyPress", l), (l, x) => e.events.on("keyPress", (R) => R === l && x(l))), ln = Ee((l) => e.events.on("keyPressRepeat", l), (l, x) => e.events.on("keyPressRepeat", (R) => R === l && x(l))), dn = Ee((l) => e.events.on("keyRelease", l), (l, x) => e.events.on("keyRelease", (R) => R === l && x(l))), Pt = Ee((l) => e.events.on("mouseDown", (x) => l(x)), (l, x) => e.events.on("mouseDown", (R) => R === l && x(R))), Dt = Ee((l) => e.events.on("mousePress", (x) => l(x)), (l, x) => e.events.on("mousePress", (R) => R === l && x(R))), Mt = Ee((l) => e.events.on("mouseRelease", (x) => l(x)), (l, x) => e.events.on("mouseRelease", (R) => R === l && x(R)));
  function Gt(l) {
    return e.events.on("mouseMove", () => l(C(), Ae()));
  }
  i(Gt, "onMouseMove");
  function Bt(l) {
    return e.events.on("charInput", l);
  }
  i(Bt, "onCharInput");
  function fn(l) {
    return e.events.on("touchStart", l);
  }
  i(fn, "onTouchStart");
  function ct(l) {
    return e.events.on("touchMove", l);
  }
  i(ct, "onTouchMove");
  function mn(l) {
    return e.events.on("touchEnd", l);
  }
  i(mn, "onTouchEnd");
  function pn(l) {
    return e.events.on("scroll", l);
  }
  i(pn, "onScroll");
  function Ft(l) {
    return e.events.on("hide", l);
  }
  i(Ft, "onHide");
  function gn(l) {
    return e.events.on("show", l);
  }
  i(gn, "onShow");
  function It(l, x) {
    if (typeof l == "function") return e.events.on("gamepadButtonDown", l);
    if (typeof l == "string" && typeof x == "function") return e.events.on("gamepadButtonDown", (R) => R === l && x(l));
  }
  i(It, "onGamepadButtonDown");
  function Lt(l, x) {
    if (typeof l == "function") return e.events.on("gamepadButtonPress", l);
    if (typeof l == "string" && typeof x == "function") return e.events.on("gamepadButtonPress", (R) => R === l && x(l));
  }
  i(Lt, "onGamepadButtonPress");
  function wn(l, x) {
    if (typeof l == "function") return e.events.on("gamepadButtonRelease", l);
    if (typeof l == "string" && typeof x == "function") return e.events.on("gamepadButtonRelease", (R) => R === l && x(l));
  }
  i(wn, "onGamepadButtonRelease");
  function ht(l, x) {
    return e.events.on("gamepadStick", (R, L) => R === l && x(L));
  }
  i(ht, "onGamepadStick");
  function bn(l) {
    e.events.on("gamepadConnect", l);
  }
  i(bn, "onGamepadConnect");
  function lt(l) {
    e.events.on("gamepadDisconnect", l);
  }
  i(lt, "onGamepadDisconnect");
  function Pe(l) {
    return e.mergedGamepadState.stickState.get(l) || new v(0);
  }
  i(Pe, "getGamepadStick");
  function dt() {
    return [...e.charInputted];
  }
  i(dt, "charInputted");
  function Vt() {
    return [...e.gamepads];
  }
  i(Vt, "getGamepads");
  function ft() {
    e.events.trigger("input"), e.keyState.down.forEach((l) => e.events.trigger("keyDown", l)), e.mouseState.down.forEach((l) => e.events.trigger("mouseDown", l)), He();
  }
  i(ft, "processInput");
  function vn() {
    e.keyState.update(), e.mouseState.update(), e.mergedGamepadState.buttonState.update(), e.mergedGamepadState.stickState.forEach((l, x) => {
      e.mergedGamepadState.stickState.set(x, new v(0));
    }), e.charInputted = [], e.isMouseMoved = false, e.gamepadStates.forEach((l) => {
      l.buttonState.update(), l.stickState.forEach((x, R) => {
        l.stickState.set(R, new v(0));
      });
    });
  }
  i(vn, "resetInput");
  function _t2(l) {
    let x = { index: l.index, isPressed: (R) => e.gamepadStates.get(l.index).buttonState.pressed.has(R), isDown: (R) => e.gamepadStates.get(l.index).buttonState.down.has(R), isReleased: (R) => e.gamepadStates.get(l.index).buttonState.released.has(R), getStick: (R) => e.gamepadStates.get(l.index).stickState.get(R) };
    return e.gamepads.push(x), e.gamepadStates.set(l.index, { buttonState: new at(), stickState: /* @__PURE__ */ new Map([["left", new v(0)], ["right", new v(0)]]) }), x;
  }
  i(_t2, "registerGamepad");
  function ne(l) {
    e.gamepads = e.gamepads.filter((x) => x.index !== l.index), e.gamepadStates.delete(l.index);
  }
  i(ne, "removeGamepad");
  function He() {
    for (let l of navigator.getGamepads()) l && !e.gamepadStates.has(l.index) && _t2(l);
    for (let l of e.gamepads) {
      let x = navigator.getGamepads()[l.index], L = (n.gamepads ?? {})[x.id] ?? qn[x.id] ?? qn.default, he = e.gamepadStates.get(l.index);
      for (let z = 0; z < x.buttons.length; z++) x.buttons[z].pressed ? (he.buttonState.down.has(L.buttons[z]) || (e.mergedGamepadState.buttonState.press(L.buttons[z]), he.buttonState.press(L.buttons[z]), e.events.trigger("gamepadButtonPress", L.buttons[z])), e.events.trigger("gamepadButtonDown", L.buttons[z])) : he.buttonState.down.has(L.buttons[z]) && (e.mergedGamepadState.buttonState.release(L.buttons[z]), he.buttonState.release(L.buttons[z]), e.events.trigger("gamepadButtonRelease", L.buttons[z]));
      for (let z in L.sticks) {
        let Oe = L.sticks[z], $e = new v(x.axes[Oe.x], x.axes[Oe.y]);
        he.stickState.set(z, $e), e.mergedGamepadState.stickState.set(z, $e), e.events.trigger("gamepadStick", z, $e);
      }
    }
  }
  i(He, "processGamepad");
  let se = {}, le = {}, ae = {}, Be = n.pixelDensity || window.devicePixelRatio || 1;
  se.mousemove = (l) => {
    let x = new v(l.offsetX, l.offsetY), R = new v(l.movementX, l.movementY);
    if (Q()) {
      let L = e.canvas.width / Be, he = e.canvas.height / Be, z = window.innerWidth, Oe = window.innerHeight, $e = z / Oe, kt = L / he;
      if ($e > kt) {
        let De = Oe / he, Ce = (z - L * De) / 2;
        x.x = _e(l.offsetX - Ce, 0, L * De, 0, L), x.y = _e(l.offsetY, 0, he * De, 0, he);
      } else {
        let De = z / L, Ce = (Oe - he * De) / 2;
        x.x = _e(l.offsetX, 0, L * De, 0, L), x.y = _e(l.offsetY - Ce, 0, he * De, 0, he);
      }
    }
    e.events.onOnce("input", () => {
      e.isMouseMoved = true, e.mousePos = x, e.mouseDeltaPos = R, e.events.trigger("mouseMove");
    });
  };
  let We = ["left", "middle", "right", "back", "forward"];
  se.mousedown = (l) => {
    e.events.onOnce("input", () => {
      let x = We[l.button];
      x && (e.mouseState.press(x), e.events.trigger("mousePress", x));
    });
  }, se.mouseup = (l) => {
    e.events.onOnce("input", () => {
      let x = We[l.button];
      x && (e.mouseState.release(x), e.events.trigger("mouseRelease", x));
    });
  };
  let yn = /* @__PURE__ */ new Set([" ", "ArrowLeft", "ArrowRight", "ArrowUp", "ArrowDown", "Tab"]), qe = { ArrowLeft: "left", ArrowRight: "right", ArrowUp: "up", ArrowDown: "down", " ": "space" };
  se.keydown = (l) => {
    yn.has(l.key) && l.preventDefault(), e.events.onOnce("input", () => {
      let x = qe[l.key] || l.key.toLowerCase();
      x.length === 1 ? (e.events.trigger("charInput", x), e.charInputted.push(x)) : x === "space" && (e.events.trigger("charInput", " "), e.charInputted.push(" ")), l.repeat ? (e.keyState.pressRepeat(x), e.events.trigger("keyPressRepeat", x)) : (e.keyState.press(x), e.events.trigger("keyPressRepeat", x), e.events.trigger("keyPress", x));
    });
  }, se.keyup = (l) => {
    e.events.onOnce("input", () => {
      let x = qe[l.key] || l.key.toLowerCase();
      e.keyState.release(x), e.events.trigger("keyRelease", x);
    });
  }, se.touchstart = (l) => {
    l.preventDefault(), e.events.onOnce("input", () => {
      let x = [...l.changedTouches], R = e.canvas.getBoundingClientRect();
      n.touchToMouse !== false && (e.mousePos = new v(x[0].clientX - R.x, x[0].clientY - R.y), e.mouseState.press("left"), e.events.trigger("mousePress", "left")), x.forEach((L) => {
        e.events.trigger("touchStart", new v(L.clientX - R.x, L.clientY - R.y), L);
      });
    });
  }, se.touchmove = (l) => {
    l.preventDefault(), e.events.onOnce("input", () => {
      let x = [...l.changedTouches], R = e.canvas.getBoundingClientRect();
      n.touchToMouse !== false && (e.mousePos = new v(x[0].clientX - R.x, x[0].clientY - R.y), e.events.trigger("mouseMove")), x.forEach((L) => {
        e.events.trigger("touchMove", new v(L.clientX - R.x, L.clientY - R.y), L);
      });
    });
  }, se.touchend = (l) => {
    e.events.onOnce("input", () => {
      let x = [...l.changedTouches], R = e.canvas.getBoundingClientRect();
      n.touchToMouse !== false && (e.mousePos = new v(x[0].clientX - R.x, x[0].clientY - R.y), e.mouseState.release("left"), e.events.trigger("mouseRelease", "left")), x.forEach((L) => {
        e.events.trigger("touchEnd", new v(L.clientX - R.x, L.clientY - R.y), L);
      });
    });
  }, se.touchcancel = (l) => {
    e.events.onOnce("input", () => {
      let x = [...l.changedTouches], R = e.canvas.getBoundingClientRect();
      n.touchToMouse !== false && (e.mousePos = new v(x[0].clientX - R.x, x[0].clientY - R.y), e.mouseState.release("left"), e.events.trigger("mouseRelease", "left")), x.forEach((L) => {
        e.events.trigger("touchEnd", new v(L.clientX - R.x, L.clientY - R.y), L);
      });
    });
  }, se.wheel = (l) => {
    l.preventDefault(), e.events.onOnce("input", () => {
      e.events.trigger("scroll", new v(l.deltaX, l.deltaY));
    });
  }, se.contextmenu = (l) => l.preventDefault(), le.visibilitychange = () => {
    document.visibilityState === "visible" ? (e.skipTime = true, e.events.trigger("show")) : e.events.trigger("hide");
  }, ae.gamepadconnected = (l) => {
    let x = _t2(l.gamepad);
    e.events.onOnce("input", () => {
      e.events.trigger("gamepadConnect", x);
    });
  }, ae.gamepaddisconnected = (l) => {
    let x = Vt().filter((R) => R.index === l.gamepad.index)[0];
    ne(l.gamepad), e.events.onOnce("input", () => {
      e.events.trigger("gamepadDisconnect", x);
    });
  };
  for (let l in se) e.canvas.addEventListener(l, se[l]);
  for (let l in le) document.addEventListener(l, le[l]);
  for (let l in ae) window.addEventListener(l, ae[l]);
  let ge = new ResizeObserver((l) => {
    for (let x of l) if (x.target === e.canvas) {
      if (e.lastWidth === e.canvas.offsetWidth && e.lastHeight === e.canvas.offsetHeight) return;
      e.lastWidth = e.canvas.offsetWidth, e.lastHeight = e.canvas.offsetHeight, e.events.onOnce("input", () => {
        e.events.trigger("resize");
      });
    }
  });
  return ge.observe(e.canvas), { dt: o, time: c, run: k, canvas: e.canvas, fps: g, numFrames: m, quit: te, setFullscreen: K, isFullscreen: Q, setCursor: I, screenshot: P, getGamepads: Vt, getCursor: j, setCursorLocked: y, isCursorLocked: X, isTouchscreen: pe, mousePos: C, mouseDeltaPos: Ae, isKeyDown: Tt, isKeyPressed: st, isKeyPressedRepeat: on, isKeyReleased: Ot, isMouseDown: Te, isMousePressed: $, isMouseReleased: ye, isMouseMoved: Se, isGamepadButtonPressed: Rt, isGamepadButtonDown: Ye, isGamepadButtonReleased: an, getGamepadStick: Pe, charInputted: dt, onResize: un, onKeyDown: cn, onKeyPress: hn, onKeyPressRepeat: ln, onKeyRelease: dn, onMouseDown: Pt, onMousePress: Dt, onMouseRelease: Mt, onMouseMove: Gt, onCharInput: Bt, onTouchStart: fn, onTouchMove: ct, onTouchEnd: mn, onScroll: pn, onHide: Ft, onShow: gn, onGamepadButtonDown: It, onGamepadButtonPress: Lt, onGamepadButtonRelease: wn, onGamepadStick: ht, onGamepadConnect: bn, onGamepadDisconnect: lt, events: e.events };
}, "default");
var Re = (_s = class {
  constructor(e, o, c, g = {}) {
    __publicField(this, "ctx");
    __publicField(this, "src", null);
    __publicField(this, "glTex");
    __publicField(this, "width");
    __publicField(this, "height");
    this.ctx = e;
    let m = e.gl;
    this.glTex = e.gl.createTexture(), e.onDestroy(() => this.free()), this.width = o, this.height = c;
    let P = { linear: m.LINEAR, nearest: m.NEAREST }[g.filter ?? e.opts.texFilter] ?? m.NEAREST, I = { repeat: m.REPEAT, clampToEadge: m.CLAMP_TO_EDGE }[g.wrap] ?? m.CLAMP_TO_EDGE;
    this.bind(), o && c && m.texImage2D(m.TEXTURE_2D, 0, m.RGBA, o, c, 0, m.RGBA, m.UNSIGNED_BYTE, null), m.texParameteri(m.TEXTURE_2D, m.TEXTURE_MIN_FILTER, P), m.texParameteri(m.TEXTURE_2D, m.TEXTURE_MAG_FILTER, P), m.texParameteri(m.TEXTURE_2D, m.TEXTURE_WRAP_S, I), m.texParameteri(m.TEXTURE_2D, m.TEXTURE_WRAP_T, I), this.unbind();
  }
  static fromImage(e, o, c = {}) {
    let g = new _s(e, o.width, o.height, c);
    return g.update(o), g.src = o, g;
  }
  update(e, o = 0, c = 0) {
    let g = this.ctx.gl;
    this.bind(), g.texSubImage2D(g.TEXTURE_2D, 0, o, c, g.RGBA, g.UNSIGNED_BYTE, e), this.unbind();
  }
  bind() {
    this.ctx.pushTexture2D(this.glTex);
  }
  unbind() {
    this.ctx.popTexture2D();
  }
  free() {
    this.ctx.gl.deleteTexture(this.glTex);
  }
}, i(_s, "Texture"), _s), rt = (_t = class {
  constructor(e, o, c, g = {}) {
    __publicField(this, "ctx");
    __publicField(this, "tex");
    __publicField(this, "glFramebuffer");
    __publicField(this, "glRenderbuffer");
    this.ctx = e;
    let m = e.gl;
    e.onDestroy(() => this.free()), this.tex = new Re(e, o, c, g), this.glFramebuffer = m.createFramebuffer(), this.glRenderbuffer = m.createRenderbuffer(), this.bind(), m.renderbufferStorage(m.RENDERBUFFER, m.DEPTH_STENCIL, o, c), m.framebufferTexture2D(m.FRAMEBUFFER, m.COLOR_ATTACHMENT0, m.TEXTURE_2D, this.tex.glTex, 0), m.framebufferRenderbuffer(m.FRAMEBUFFER, m.DEPTH_STENCIL_ATTACHMENT, m.RENDERBUFFER, this.glRenderbuffer), this.unbind();
  }
  get width() {
    return this.tex.width;
  }
  get height() {
    return this.tex.height;
  }
  toImageData() {
    let e = this.ctx.gl, o = new Uint8ClampedArray(this.width * this.height * 4);
    this.bind(), e.readPixels(0, 0, this.width, this.height, e.RGBA, e.UNSIGNED_BYTE, o), this.unbind();
    let c = this.width * 4, g = new Uint8Array(c);
    for (let m = 0; m < (this.height / 2 | 0); m++) {
      let P = m * c, I = (this.height - m - 1) * c;
      g.set(o.subarray(P, P + c)), o.copyWithin(P, I, I + c), o.set(g, I);
    }
    return new ImageData(o, this.width, this.height);
  }
  toDataURL() {
    let e = document.createElement("canvas"), o = e.getContext("2d");
    return e.width = this.width, e.height = this.height, o.putImageData(this.toImageData(), 0, 0), e.toDataURL();
  }
  draw(e) {
    this.bind(), e(), this.unbind();
  }
  bind() {
    this.ctx.pushFramebuffer(this.glFramebuffer), this.ctx.pushRenderbuffer(this.glRenderbuffer), this.ctx.pushViewport({ x: 0, y: 0, w: this.width, h: this.height });
  }
  unbind() {
    this.ctx.popFramebuffer(), this.ctx.popRenderbuffer(), this.ctx.popViewport();
  }
  free() {
    let e = this.ctx.gl;
    e.deleteFramebuffer(this.glFramebuffer), e.deleteRenderbuffer(this.glRenderbuffer), this.tex.free();
  }
}, i(_t, "FrameBuffer"), _t), Jt = (_u = class {
  constructor(e, o, c, g) {
    __publicField(this, "ctx");
    __publicField(this, "glProgram");
    this.ctx = e, e.onDestroy(() => this.free());
    let m = e.gl, P = m.createShader(m.VERTEX_SHADER), I = m.createShader(m.FRAGMENT_SHADER);
    m.shaderSource(P, o), m.shaderSource(I, c), m.compileShader(P), m.compileShader(I);
    let j = m.createProgram();
    if (this.glProgram = j, m.attachShader(j, P), m.attachShader(j, I), g.forEach((y, X) => m.bindAttribLocation(j, X, y)), m.linkProgram(j), !m.getProgramParameter(j, m.LINK_STATUS)) {
      let y = m.getShaderInfoLog(P);
      if (y) throw new Error("VERTEX SHADER " + y);
      let X = m.getShaderInfoLog(I);
      if (X) throw new Error("FRAGMENT SHADER " + X);
    }
    m.deleteShader(P), m.deleteShader(I);
  }
  bind() {
    this.ctx.pushProgram(this.glProgram);
  }
  unbind() {
    this.ctx.popProgram();
  }
  send(e) {
    let o = this.ctx.gl;
    for (let c in e) {
      let g = e[c], m = o.getUniformLocation(this.glProgram, c);
      typeof g == "number" ? o.uniform1f(m, g) : g instanceof Ue ? o.uniformMatrix4fv(m, false, new Float32Array(g.m)) : g instanceof W ? o.uniform3f(m, g.r, g.g, g.b) : g instanceof v && o.uniform2f(m, g.x, g.y);
    }
  }
  free() {
    this.ctx.gl.deleteProgram(this.glProgram);
  }
}, i(_u, "Shader"), _u), Qt = (_v = class {
  constructor(e, o, c, g) {
    __publicField(this, "ctx");
    __publicField(this, "glVBuf");
    __publicField(this, "glIBuf");
    __publicField(this, "vqueue", []);
    __publicField(this, "iqueue", []);
    __publicField(this, "stride");
    __publicField(this, "maxVertices");
    __publicField(this, "maxIndices");
    __publicField(this, "vertexFormat");
    __publicField(this, "numDraws", 0);
    __publicField(this, "curPrimitive", null);
    __publicField(this, "curTex", null);
    __publicField(this, "curShader", null);
    __publicField(this, "curUniform", {});
    let m = e.gl;
    this.vertexFormat = o, this.ctx = e, this.stride = o.reduce((P, I) => P + I.size, 0), this.maxVertices = c, this.maxIndices = g, this.glVBuf = m.createBuffer(), e.pushArrayBuffer(this.glVBuf), m.bufferData(m.ARRAY_BUFFER, c * 4, m.DYNAMIC_DRAW), e.popArrayBuffer(), this.glIBuf = m.createBuffer(), e.pushElementArrayBuffer(this.glIBuf), m.bufferData(m.ELEMENT_ARRAY_BUFFER, g * 4, m.DYNAMIC_DRAW), e.popElementArrayBuffer();
  }
  push(e, o, c, g, m = null, P = {}) {
    (e !== this.curPrimitive || m !== this.curTex || g !== this.curShader || !Wt(this.curUniform, P) || this.vqueue.length + o.length * this.stride > this.maxVertices || this.iqueue.length + c.length > this.maxIndices) && this.flush();
    let I = this.vqueue.length / this.stride;
    for (let j of o) this.vqueue.push(j);
    for (let j of c) this.iqueue.push(j + I);
    this.curPrimitive = e, this.curShader = g, this.curTex = m, this.curUniform = P;
  }
  flush() {
    if (!this.curPrimitive || !this.curShader || this.vqueue.length === 0 || this.iqueue.length === 0) return;
    let e = this.ctx.gl;
    this.ctx.pushArrayBuffer(this.glVBuf), e.bufferSubData(e.ARRAY_BUFFER, 0, new Float32Array(this.vqueue)), this.ctx.pushElementArrayBuffer(this.glIBuf), e.bufferSubData(e.ELEMENT_ARRAY_BUFFER, 0, new Uint16Array(this.iqueue)), this.ctx.setVertexFormat(this.vertexFormat), this.curShader.bind(), this.curShader.send(this.curUniform), this.curTex?.bind(), e.drawElements(this.curPrimitive, this.iqueue.length, e.UNSIGNED_SHORT, 0), this.curTex?.unbind(), this.curShader.unbind(), this.ctx.popArrayBuffer(), this.ctx.popElementArrayBuffer(), this.vqueue = [], this.iqueue = [], this.numDraws++;
  }
  free() {
    let e = this.ctx.gl;
    e.deleteBuffer(this.glVBuf), e.deleteBuffer(this.glIBuf);
  }
}, i(_v, "BatchRenderer"), _v);
function nt(n) {
  let e = [], o = i((m) => {
    e.push(m), n(m);
  }, "push"), c = i(() => {
    e.pop(), n(g() ?? null);
  }, "pop"), g = i(() => e[e.length - 1], "cur");
  return [o, c, g];
}
i(nt, "genStack");
function Kn(n, e = {}) {
  let o = [];
  function c($) {
    o.push($);
  }
  i(c, "onDestroy");
  function g() {
    o.forEach(($) => $()), n.getExtension("WEBGL_lose_context").loseContext();
  }
  i(g, "destroy");
  let m = null;
  function P($) {
    if (Wt($, m)) return;
    m = $;
    let Te = $.reduce((ye, Se) => ye + Se.size, 0);
    $.reduce((ye, Se, st) => (n.vertexAttribPointer(st, Se.size, n.FLOAT, false, Te * 4, ye), n.enableVertexAttribArray(st), ye + Se.size * 4), 0);
  }
  i(P, "setVertexFormat");
  let [I, j] = nt(($) => n.bindTexture(n.TEXTURE_2D, $)), [y, X] = nt(($) => n.bindBuffer(n.ARRAY_BUFFER, $)), [S, q] = nt(($) => n.bindBuffer(n.ELEMENT_ARRAY_BUFFER, $)), [E, K] = nt(($) => n.bindFramebuffer(n.FRAMEBUFFER, $)), [Q, te] = nt(($) => n.bindRenderbuffer(n.RENDERBUFFER, $)), [k, pe] = nt(({ x: $, y: Te, w: ye, h: Se }) => {
    n.viewport($, Te, ye, Se);
  }), [C, Ae] = nt(($) => n.useProgram($));
  return k({ x: 0, y: 0, w: n.drawingBufferWidth, h: n.drawingBufferHeight }), { gl: n, opts: e, onDestroy: c, destroy: g, pushTexture2D: I, popTexture2D: j, pushArrayBuffer: y, popArrayBuffer: X, pushElementArrayBuffer: S, popElementArrayBuffer: q, pushFramebuffer: E, popFramebuffer: K, pushRenderbuffer: Q, popRenderbuffer: te, pushViewport: k, popViewport: pe, pushProgram: C, popProgram: Ae, setVertexFormat: P };
}
i(Kn, "initGfx");
var ve = (_w = class {
  constructor(e) {
    __publicField(this, "loaded", false);
    __publicField(this, "data", null);
    __publicField(this, "error", null);
    __publicField(this, "onLoadEvents", new be());
    __publicField(this, "onErrorEvents", new be());
    __publicField(this, "onFinishEvents", new be());
    e.then((o) => {
      this.data = o, this.onLoadEvents.trigger(o);
    }).catch((o) => {
      if (this.error = o, this.onErrorEvents.numListeners() > 0) this.onErrorEvents.trigger(o);
      else throw o;
    }).finally(() => {
      this.onFinishEvents.trigger(), this.loaded = true;
    });
  }
  static loaded(e) {
    let o = new _w(Promise.resolve(e));
    return o.data = e, o.loaded = true, o;
  }
  onLoad(e) {
    return this.loaded && this.data ? e(this.data) : this.onLoadEvents.add(e), this;
  }
  onError(e) {
    return this.loaded && this.error ? e(this.error) : this.onErrorEvents.add(e), this;
  }
  onFinish(e) {
    return this.loaded ? e() : this.onFinishEvents.add(e), this;
  }
  then(e) {
    return this.onLoad(e);
  }
  catch(e) {
    return this.onError(e);
  }
  finally(e) {
    return this.onFinish(e);
  }
}, i(_w, "Asset"), _w), je = (_x = class {
  constructor() {
    __publicField(this, "assets", /* @__PURE__ */ new Map());
    __publicField(this, "lastUID", 0);
  }
  add(e, o) {
    let c = e ?? this.lastUID++ + "", g = new ve(o);
    return this.assets.set(c, g), g;
  }
  addLoaded(e, o) {
    let c = e ?? this.lastUID++ + "", g = ve.loaded(o);
    return this.assets.set(c, g), g;
  }
  get(e) {
    return this.assets.get(e);
  }
  progress() {
    if (this.assets.size === 0) return 1;
    let e = 0;
    return this.assets.forEach((o) => {
      o.loaded && e++;
    }), e / this.assets.size;
  }
}, i(_x, "AssetBucket"), _x);
function Yn(n) {
  return fetch(n).then((e) => {
    if (!e.ok) throw new Error(`Failed to fetch "${n}"`);
    return e;
  });
}
i(Yn, "fetchURL");
function Et(n) {
  return Yn(n).then((e) => e.json());
}
i(Et, "fetchJSON");
function Lr(n) {
  return Yn(n).then((e) => e.text());
}
i(Lr, "fetchText");
function Vr(n) {
  return Yn(n).then((e) => e.arrayBuffer());
}
i(Vr, "fetchArrayBuffer");
function St(n) {
  let e = new Image();
  return e.crossOrigin = "anonymous", e.src = n, new Promise((o, c) => {
    e.onload = () => o(e), e.onerror = () => c(new Error(`Failed to load image from "${n}"`));
  });
}
i(St, "loadImg");
var Zt = 2.5949095, _r = 1.70158 + 1, kr = 2 * Math.PI / 3, Nr = 2 * Math.PI / 4.5, en = { linear: (n) => n, easeInSine: (n) => 1 - Math.cos(n * Math.PI / 2), easeOutSine: (n) => Math.sin(n * Math.PI / 2), easeInOutSine: (n) => -(Math.cos(Math.PI * n) - 1) / 2, easeInQuad: (n) => n * n, easeOutQuad: (n) => 1 - (1 - n) * (1 - n), easeInOutQuad: (n) => n < 0.5 ? 2 * n * n : 1 - Math.pow(-2 * n + 2, 2) / 2, easeInCubic: (n) => n * n * n, easeOutCubic: (n) => 1 - Math.pow(1 - n, 3), easeInOutCubic: (n) => n < 0.5 ? 4 * n * n * n : 1 - Math.pow(-2 * n + 2, 3) / 2, easeInQuart: (n) => n * n * n * n, easeOutQuart: (n) => 1 - Math.pow(1 - n, 4), easeInOutQuart: (n) => n < 0.5 ? 8 * n * n * n * n : 1 - Math.pow(-2 * n + 2, 4) / 2, easeInQuint: (n) => n * n * n * n * n, easeOutQuint: (n) => 1 - Math.pow(1 - n, 5), easeInOutQuint: (n) => n < 0.5 ? 16 * n * n * n * n * n : 1 - Math.pow(-2 * n + 2, 5) / 2, easeInExpo: (n) => n === 0 ? 0 : Math.pow(2, 10 * n - 10), easeOutExpo: (n) => n === 1 ? 1 : 1 - Math.pow(2, -10 * n), easeInOutExpo: (n) => n === 0 ? 0 : n === 1 ? 1 : n < 0.5 ? Math.pow(2, 20 * n - 10) / 2 : (2 - Math.pow(2, -20 * n + 10)) / 2, easeInCirc: (n) => 1 - Math.sqrt(1 - Math.pow(n, 2)), easeOutCirc: (n) => Math.sqrt(1 - Math.pow(n - 1, 2)), easeInOutCirc: (n) => n < 0.5 ? (1 - Math.sqrt(1 - Math.pow(2 * n, 2))) / 2 : (Math.sqrt(1 - Math.pow(-2 * n + 2, 2)) + 1) / 2, easeInBack: (n) => _r * n * n * n - 1.70158 * n * n, easeOutBack: (n) => 1 + _r * Math.pow(n - 1, 3) + 1.70158 * Math.pow(n - 1, 2), easeInOutBack: (n) => n < 0.5 ? Math.pow(2 * n, 2) * ((Zt + 1) * 2 * n - Zt) / 2 : (Math.pow(2 * n - 2, 2) * ((Zt + 1) * (n * 2 - 2) + Zt) + 2) / 2, easeInElastic: (n) => n === 0 ? 0 : n === 1 ? 1 : -Math.pow(2, 10 * n - 10) * Math.sin((n * 10 - 10.75) * kr), easeOutElastic: (n) => n === 0 ? 0 : n === 1 ? 1 : Math.pow(2, -10 * n) * Math.sin((n * 10 - 0.75) * kr) + 1, easeInOutElastic: (n) => n === 0 ? 0 : n === 1 ? 1 : n < 0.5 ? -(Math.pow(2, 20 * n - 10) * Math.sin((20 * n - 11.125) * Nr)) / 2 : Math.pow(2, -20 * n + 10) * Math.sin((20 * n - 11.125) * Nr) / 2 + 1, easeInBounce: (n) => 1 - en.easeOutBounce(1 - n), easeOutBounce: (n) => n < 1 / 2.75 ? 7.5625 * n * n : n < 2 / 2.75 ? 7.5625 * (n -= 1.5 / 2.75) * n + 0.75 : n < 2.5 / 2.75 ? 7.5625 * (n -= 2.25 / 2.75) * n + 0.9375 : 7.5625 * (n -= 2.625 / 2.75) * n + 0.984375, easeInOutBounce: (n) => n < 0.5 ? (1 - en.easeOutBounce(1 - 2 * n)) / 2 : (1 + en.easeOutBounce(2 * n - 1)) / 2 }, Ct = en;
var At = (_y = class {
  constructor(e, o, c) {
    __publicField(this, "textures", []);
    __publicField(this, "canvas");
    __publicField(this, "c2d");
    __publicField(this, "x", 0);
    __publicField(this, "y", 0);
    __publicField(this, "curHeight", 0);
    __publicField(this, "gfx");
    this.gfx = e, this.canvas = document.createElement("canvas"), this.canvas.width = o, this.canvas.height = c, this.textures = [Re.fromImage(e, this.canvas)], this.c2d = this.canvas.getContext("2d");
  }
  add(e) {
    if (e.width > this.canvas.width || e.height > this.canvas.height) throw new Error(`Texture size (${e.width} x ${e.height}) exceeds limit (${this.canvas.width} x ${this.canvas.height})`);
    this.x + e.width > this.canvas.width && (this.x = 0, this.y += this.curHeight, this.curHeight = 0), this.y + e.height > this.canvas.height && (this.c2d.clearRect(0, 0, this.canvas.width, this.canvas.height), this.textures.push(Re.fromImage(this.gfx, this.canvas)), this.x = 0, this.y = 0, this.curHeight = 0);
    let o = this.textures[this.textures.length - 1], c = new v(this.x, this.y);
    return this.x += e.width, e.height > this.curHeight && (this.curHeight = e.height), e instanceof ImageData ? this.c2d.putImageData(e, c.x, c.y) : this.c2d.drawImage(e, c.x, c.y), o.update(this.canvas), [o, new oe(c.x / this.canvas.width, c.y / this.canvas.height, e.width / this.canvas.width, e.height / this.canvas.height)];
  }
  free() {
    for (let e of this.textures) e.free();
  }
}, i(_y, "TexPacker"), _y);
var jr = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAD0AAAA1CAYAAADyMeOEAAAAAXNSR0IArs4c6QAAAoVJREFUaIHdm7txwkAQhheGAqACiCHzOKQDQrqgILpwSAeEDBnEUAF0gCMxZ7G72qce/mec2Lpf9+3unaS78wgSNZ8uX5729+d1FNWXUuGmXlBOUUEIMckEpeQJgBu6C+BSFngztBR2vd+ovY+7g+p6LbgaWgJrAeUkDYIUXgXdBBwNi6kpABJwMTQH3AZsXRR8GHTfgEth8E3gjdAUcNewpbTgY85sCMCUuOokozE0YM0YRzM9NGAAXd8+omAF5h4lnmBRvpSnZHyLoLEbaN+aKB9KWv/KWw0tAbbANnlG+UvB2dm77NxxdwgBpjrF/d7rW9cbmpvio2A5z8iAYpVU8pGZlo6/2+MSco2lHfd3rv9jAP038e1xef9o2mjvYb2OqpqKE81028/jeietlSEVO5FRWsxWsJit1G3aFpW8iWe5RwpiCZAk25QvV6nz6fIlynRGuTd5WqpJ4guAlDfVKBK87hXljflgv1ON6fV+4+5gVlA17SfeG0heKqQd4l4jI/wrmaA9N9R4ar+wpHJDZyrrfcH0nB66PqAzPi76pn+faSyJk/vzOorYhGurQrzj/P68jtBMawHaHBIR9xoD5O34dy0qQOSYHvqExq2TpT2nf76+w7y251OYF0CRaU+J920TwLUa6inx6OxE6g80lu2ux7Y2eJLF/rCXE6zEPdnenk9o+4ih9AEdnW2q81HXl5LuU6OTl2fXUhqganbXAGq3g6jJOWV/OnoesO6YqqEB/GdNsjf7uHtwj2DzmRNpp7iOZfm6D9oAxB6Yi1gC4oIYeo4MIPdopEQRB+cAko5J1tW386HpB2Kz1eop4Epdwls/kgZ1sh8gZsEjdcWkr//D8Qu3Z3l5Nl1NtAAAAABJRU5ErkJggg==";
var Hr = gr("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L5QNSqT5iiySS9Ja2SV//5ME0ak//+4KgAAABgQBAADAMDgYCAEgCteQ0fZH6+ICXA357+MPfhR/+ywRf/U///LVTEFNRTMuMTAwVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVX/+5JknQAFoWhGLm5gBClBmT3GiAAAAAGkHAAAIAAANIOAAARVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV");
var qr = "data:image/png;base64,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";
var $r = "data:image/png;base64,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";
var ki = "3000.1.17", zr = " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~", tn = "topleft", Kr = 64, Ni = "monospace", nn = "monospace", ji = 36, rn = 64, sn = 256, Yr = 2048, Wr = 2048, Xr = 2048, Jr = 2048, Qr = 0.1, Hi = 64, Wn = "linear", qi = 8, $i = 4, Qn = [{ name: "a_pos", size: 2 }, { name: "a_uv", size: 2 }, { name: "a_color", size: 4 }], zi = Qn.reduce((n, e) => n + e.size, 0), Zr = 2048, Ki = Zr * 4 * zi, Yi = Zr * 6, Wi = `
attribute vec2 a_pos;
attribute vec2 a_uv;
attribute vec4 a_color;

varying vec2 v_pos;
varying vec2 v_uv;
varying vec4 v_color;

vec4 def_vert() {
	return vec4(a_pos, 0.0, 1.0);
}

{{user}}

void main() {
	vec4 pos = vert(a_pos, a_uv, a_color);
	v_pos = a_pos;
	v_uv = a_uv;
	v_color = a_color;
	gl_Position = pos;
}
`, Xi = `
precision mediump float;

varying vec2 v_pos;
varying vec2 v_uv;
varying vec4 v_color;

uniform sampler2D u_tex;

vec4 def_frag() {
	return v_color * texture2D(u_tex, v_uv);
}

{{user}}

void main() {
	gl_FragColor = frag(v_pos, v_uv, v_color, u_tex);
	if (gl_FragColor.a == 0.0) {
		discard;
	}
}
`, Xn = `
vec4 vert(vec2 pos, vec2 uv, vec4 color) {
	return def_vert();
}
`, Jn = `
vec4 frag(vec2 pos, vec2 uv, vec4 color, sampler2D tex) {
	return def_frag();
}
`, Ji = /* @__PURE__ */ new Set(["id", "require"]), Qi = /* @__PURE__ */ new Set(["add", "update", "draw", "destroy", "inspect", "drawInspect"]);
function ut(n) {
  switch (n) {
    case "topleft":
      return new v(-1, -1);
    case "top":
      return new v(0, -1);
    case "topright":
      return new v(1, -1);
    case "left":
      return new v(-1, 0);
    case "center":
      return new v(0, 0);
    case "right":
      return new v(1, 0);
    case "botleft":
      return new v(-1, 1);
    case "bot":
      return new v(0, 1);
    case "botright":
      return new v(1, 1);
    default:
      return n;
  }
}
i(ut, "anchorPt");
function Zi(n) {
  switch (n) {
    case "left":
      return 0;
    case "center":
      return 0.5;
    case "right":
      return 1;
    default:
      return 0;
  }
}
i(Zi, "alignPt");
function eo(n) {
  return n.createBuffer(1, 1, 44100);
}
i(eo, "createEmptyAudioBuffer");
var zo = i((n = {}) => {
  let e = n.root ?? document.body;
  e === document.body && (document.body.style.width = "100%", document.body.style.height = "100%", document.body.style.margin = "0px", document.documentElement.style.width = "100%", document.documentElement.style.height = "100%");
  let o = n.canvas ?? (() => {
    let t = document.createElement("canvas");
    return e.appendChild(t), t;
  })(), c = n.scale ?? 1, g = n.width && n.height && !n.stretch && !n.letterbox;
  g ? (o.width = n.width * c, o.height = n.height * c) : (o.width = o.parentElement.offsetWidth, o.height = o.parentElement.offsetHeight);
  let m = ["outline: none", "cursor: default"];
  if (g) {
    let t = o.width, r = o.height;
    m.push(`width: ${t}px`), m.push(`height: ${r}px`);
  } else m.push("width: 100%"), m.push("height: 100%");
  n.crisp && (m.push("image-rendering: pixelated"), m.push("image-rendering: crisp-edges")), o.style.cssText = m.join(";");
  let P = n.pixelDensity || window.devicePixelRatio;
  o.width *= P, o.height *= P, o.tabIndex = 0;
  let I = document.createElement("canvas");
  I.width = sn, I.height = sn;
  let j = I.getContext("2d", { willReadFrequently: true }), y = Ir({ canvas: o, touchToMouse: n.touchToMouse, gamepads: n.gamepads, pixelDensity: n.pixelDensity, maxFPS: n.maxFPS }), X = [], S = y.canvas.getContext("webgl", { antialias: true, depth: true, stencil: true, alpha: true, preserveDrawingBuffer: true }), q = Kn(S, { texFilter: n.texFilter }), E = (() => {
    let t = ht(Xn, Jn), r = Re.fromImage(q, new ImageData(new Uint8ClampedArray([255, 255, 255, 255]), 1, 1)), s = n.width && n.height ? new rt(q, n.width * P * c, n.height * P * c) : new rt(q, S.drawingBufferWidth, S.drawingBufferHeight), u = null, a = 1;
    n.background && (u = J(n.background), a = Array.isArray(n.background) ? n.background[3] : 1, S.clearColor(u.r / 255, u.g / 255, u.b / 255, a ?? 1)), S.enable(S.BLEND), S.blendFuncSeparate(S.SRC_ALPHA, S.ONE_MINUS_SRC_ALPHA, S.ONE, S.ONE_MINUS_SRC_ALPHA);
    let h = new Qt(q, Qn, Ki, Yi), f = Re.fromImage(q, new ImageData(new Uint8ClampedArray([128, 128, 128, 255, 190, 190, 190, 255, 190, 190, 190, 255, 128, 128, 128, 255]), 2, 2), { wrap: "repeat", filter: "nearest" });
    return { lastDrawCalls: 0, defShader: t, defTex: r, frameBuffer: s, postShader: null, postShaderUniform: null, renderer: h, transform: new Ue(), transformStack: [], bgTex: f, bgColor: u, bgAlpha: a, width: n.width ?? S.drawingBufferWidth / P / c, height: n.height ?? S.drawingBufferHeight / P / c, viewport: { x: 0, y: 0, width: S.drawingBufferWidth, height: S.drawingBufferHeight }, fixed: false };
  })();
  const _K = class _K {
    constructor(r, s, u = {}, a = null) {
      __publicField(this, "tex");
      __publicField(this, "frames", [new oe(0, 0, 1, 1)]);
      __publicField(this, "anims", {});
      __publicField(this, "slice9", null);
      this.tex = r, s && (this.frames = s), this.anims = u, this.slice9 = a;
    }
    get width() {
      return this.tex.width * this.frames[0].w;
    }
    get height() {
      return this.tex.height * this.frames[0].h;
    }
    static from(r, s = {}) {
      return typeof r == "string" ? _K.fromURL(r, s) : Promise.resolve(_K.fromImage(r, s));
    }
    static fromImage(r, s = {}) {
      let [u, a] = k.packer.add(r), h = s.frames ? s.frames.map((f) => new oe(a.x + f.x * a.w, a.y + f.y * a.h, f.w * a.w, f.h * a.h)) : Tt(s.sliceX || 1, s.sliceY || 1, a.x, a.y, a.w, a.h);
      return new _K(u, h, s.anims, s.slice9);
    }
    static fromURL(r, s = {}) {
      return St(r).then((u) => _K.fromImage(u, s));
    }
  };
  i(_K, "SpriteData");
  let K = _K;
  const _Q = class _Q {
    constructor(r) {
      __publicField(this, "buf");
      this.buf = r;
    }
    static fromArrayBuffer(r) {
      return new Promise((s, u) => te.ctx.decodeAudioData(r, s, u)).then((s) => new _Q(s));
    }
    static fromURL(r) {
      return jn(r) ? _Q.fromArrayBuffer(Pr(r)) : Vr(r).then((s) => _Q.fromArrayBuffer(s));
    }
  };
  i(_Q, "SoundData");
  let Q = _Q;
  let te = (() => {
    let t = new (window.AudioContext || window.webkitAudioContext)(), r = t.createGain();
    r.connect(t.destination);
    let s = new Q(eo(t));
    return t.decodeAudioData(Hr.buffer.slice(0)).then((u) => {
      s.buf = u;
    }).catch((u) => {
      console.error("Failed to load burp: ", u);
    }), { ctx: t, masterNode: r, burpSnd: s };
  })(), k = { urlPrefix: "", sprites: new je(), fonts: new je(), bitmapFonts: new je(), sounds: new je(), shaders: new je(), custom: new je(), packer: new At(q, Xr, Jr), loaded: false };
  function pe(t) {
    return typeof t != "string" || jn(t) ? t : k.urlPrefix + t;
  }
  i(pe, "fixURL");
  let C = { events: new Ne(), objEvents: new Ne(), root: Un([]), gravity: 0, scenes: {}, logs: [], cam: { pos: null, scale: new v(1), angle: 0, shake: 0, transform: new Ue() } };
  C.root.use(An());
  function Ae(t) {
    return k.custom.add(null, t);
  }
  i(Ae, "load");
  function $() {
    let t = [k.sprites, k.sounds, k.shaders, k.fonts, k.bitmapFonts, k.custom];
    return t.reduce((r, s) => r + s.progress(), 0) / t.length;
  }
  i($, "loadProgress");
  function Te(t) {
    return t !== void 0 && (k.urlPrefix = t), k.urlPrefix;
  }
  i(Te, "loadRoot");
  function ye(t, r) {
    return k.custom.add(t, Et(r));
  }
  i(ye, "loadJSON");
  const _Se = class _Se {
    constructor(r, s = {}) {
      __publicField(this, "fontface");
      __publicField(this, "filter", Wn);
      __publicField(this, "outline", null);
      __publicField(this, "size", rn);
      if (this.fontface = r, this.filter = s.filter ?? Wn, this.size = s.size ?? rn, this.size > sn) throw new Error(`Max font size: ${sn}`);
      s.outline && (this.outline = { width: 1, color: J(0, 0, 0) }, typeof s.outline == "number" ? this.outline.width = s.outline : typeof s.outline == "object" && (s.outline.width && (this.outline.width = s.outline.width), s.outline.color && (this.outline.color = s.outline.color)));
    }
  };
  i(_Se, "FontData");
  let Se = _Se;
  function st(t, r, s = {}) {
    let u = new FontFace(t, typeof r == "string" ? `url(${r})` : r);
    return document.fonts.add(u), k.fonts.add(t, u.load().catch((a) => {
      throw new Error(`Failed to load font from "${r}": ${a}`);
    }).then((a) => new Se(a, s)));
  }
  i(st, "loadFont");
  function on(t, r, s, u, a = {}) {
    return k.bitmapFonts.add(t, St(r).then((h) => bn(Re.fromImage(q, h, a), s, u, a.chars ?? zr)));
  }
  i(on, "loadBitmapFont");
  function Tt(t = 1, r = 1, s = 0, u = 0, a = 1, h = 1) {
    let f = [], b = a / t, p = h / r;
    for (let d = 0; d < r; d++) for (let w = 0; w < t; w++) f.push(new oe(s + w * b, u + d * p, b, p));
    return f;
  }
  i(Tt, "slice");
  function Ot(t, r) {
    return t = pe(t), Ae(typeof r == "string" ? new Promise((s, u) => {
      Et(r).then((a) => {
        Ot(t, a).then(s).catch(u);
      });
    }) : K.from(t).then((s) => {
      let u = {};
      for (let a in r) {
        let h = r[a], f = s.frames[0], b = Xr * f.w, p = Jr * f.h, d = h.frames ? h.frames.map((A) => new oe(f.x + (h.x + A.x) / b * f.w, f.y + (h.y + A.y) / p * f.h, A.w / b * f.w, A.h / p * f.h)) : Tt(h.sliceX || 1, h.sliceY || 1, f.x + h.x / b * f.w, f.y + h.y / p * f.h, h.width / b * f.w, h.height / p * f.h), w = new K(s.tex, d, h.anims);
        k.sprites.addLoaded(a, w), u[a] = w;
      }
      return u;
    }));
  }
  i(Ot, "loadSpriteAtlas");
  function Rt(t, r = {}) {
    let s = document.createElement("canvas"), u = t[0].width, a = t[0].height;
    s.width = u * t.length, s.height = a;
    let h = s.getContext("2d");
    t.forEach((b, p) => {
      b instanceof ImageData ? h.putImageData(b, p * u, 0) : h.drawImage(b, p * u, 0);
    });
    let f = h.getImageData(0, 0, t.length * u, a);
    return K.fromImage(f, { ...r, sliceX: t.length, sliceY: 1 });
  }
  i(Rt, "createSpriteSheet");
  function Ye(t, r, s = { sliceX: 1, sliceY: 1, anims: {} }) {
    return r = pe(r), Array.isArray(r) ? r.some((u) => typeof u == "string") ? k.sprites.add(t, Promise.all(r.map((u) => typeof u == "string" ? St(u) : Promise.resolve(u))).then((u) => Rt(u, s))) : k.sprites.addLoaded(t, Rt(r, s)) : typeof r == "string" ? k.sprites.add(t, K.from(r, s)) : k.sprites.addLoaded(t, K.fromImage(r, s));
  }
  i(Ye, "loadSprite");
  function an(t, r) {
    return r = pe(r), k.sprites.add(t, new Promise(async (s) => {
      let u = typeof r == "string" ? await Et(r) : r, a = await Promise.all(u.frames.map(St)), h = document.createElement("canvas");
      h.width = u.width, h.height = u.height * u.frames.length;
      let f = h.getContext("2d");
      a.forEach((p, d) => {
        f.drawImage(p, 0, d * u.height);
      });
      let b = await Ye(null, h, { sliceY: u.frames.length, anims: u.anims });
      s(b);
    }));
  }
  i(an, "loadPedit");
  function un(t, r, s) {
    r = pe(r), s = pe(s), typeof r == "string" && !s && (s = Mr(r) + ".json");
    let u = typeof s == "string" ? Et(s) : Promise.resolve(s);
    return k.sprites.add(t, u.then((a) => {
      let h = a.meta.size, f = a.frames.map((p) => new oe(p.frame.x / h.w, p.frame.y / h.h, p.frame.w / h.w, p.frame.h / h.h)), b = {};
      for (let p of a.meta.frameTags) p.from === p.to ? b[p.name] = p.from : b[p.name] = { from: p.from, to: p.to, speed: 10, loop: true, pingpong: p.direction === "pingpong" };
      return K.from(r, { frames: f, anims: b });
    }));
  }
  i(un, "loadAseprite");
  function cn(t, r, s) {
    return k.shaders.addLoaded(t, ht(r, s));
  }
  i(cn, "loadShader");
  function hn(t, r, s) {
    r = pe(r), s = pe(s);
    let u = i((h) => h ? Lr(h) : Promise.resolve(null), "resolveUrl"), a = Promise.all([u(r), u(s)]).then(([h, f]) => ht(h, f));
    return k.shaders.add(t, a);
  }
  i(hn, "loadShaderURL");
  function ln(t, r) {
    return r = pe(r), k.sounds.add(t, typeof r == "string" ? Q.fromURL(r) : Q.fromArrayBuffer(r));
  }
  i(ln, "loadSound");
  function dn(t = "bean") {
    return Ye(t, jr);
  }
  i(dn, "loadBean");
  function Pt(t) {
    return k.sprites.get(t);
  }
  i(Pt, "getSprite");
  function Dt(t) {
    return k.sounds.get(t);
  }
  i(Dt, "getSound");
  function Mt(t) {
    return k.fonts.get(t);
  }
  i(Mt, "getFont");
  function Gt(t) {
    return k.bitmapFonts.get(t);
  }
  i(Gt, "getBitmapFont");
  function Bt(t) {
    return k.shaders.get(t);
  }
  i(Bt, "getShader");
  function fn(t) {
    return k.custom.get(t);
  }
  i(fn, "getAsset");
  function ct(t) {
    if (typeof t == "string") {
      let r = Pt(t);
      if (r) return r;
      if ($() < 1) return null;
      throw new Error(`Sprite not found: ${t}`);
    } else {
      if (t instanceof K) return ve.loaded(t);
      if (t instanceof ve) return t;
      throw new Error(`Invalid sprite: ${t}`);
    }
  }
  i(ct, "resolveSprite");
  function mn(t) {
    if (typeof t == "string") {
      let r = Dt(t);
      if (r) return r;
      if ($() < 1) return null;
      throw new Error(`Sound not found: ${t}`);
    } else {
      if (t instanceof Q) return ve.loaded(t);
      if (t instanceof ve) return t;
      throw new Error(`Invalid sound: ${t}`);
    }
  }
  i(mn, "resolveSound");
  function pn(t) {
    if (!t) return E.defShader;
    if (typeof t == "string") {
      let r = Bt(t);
      if (r) return r.data ?? r;
      if ($() < 1) return null;
      throw new Error(`Shader not found: ${t}`);
    } else if (t instanceof ve) return t.data ? t.data : t;
    return t;
  }
  i(pn, "resolveShader");
  function Ft(t) {
    if (!t) return Ft(n.font ?? Ni);
    if (typeof t == "string") {
      let r = Gt(t), s = Mt(t);
      if (r) return r.data ?? r;
      if (s) return s.data ?? s;
      if (document.fonts.check(`${rn}px ${t}`)) return t;
      if ($() < 1) return null;
      throw new Error(`Font not found: ${t}`);
    } else if (t instanceof ve) return t.data ? t.data : t;
    return t;
  }
  i(Ft, "resolveFont");
  function gn(t) {
    return t !== void 0 && (te.masterNode.gain.value = t), te.masterNode.gain.value;
  }
  i(gn, "volume");
  function It(t, r = {}) {
    let s = te.ctx, u = r.paused ?? false, a = s.createBufferSource(), h = new be(), f = s.createGain(), b = r.seek ?? 0, p = 0, d = 0, w = false;
    a.loop = !!r.loop, a.detune.value = r.detune ?? 0, a.playbackRate.value = r.speed ?? 1, a.connect(f), a.onended = () => {
      N() >= a.buffer?.duration && h.trigger();
    }, f.connect(te.masterNode), f.gain.value = r.volume ?? 1;
    let A = i((M) => {
      a.buffer = M.buf, u || (p = s.currentTime, a.start(0, b), w = true);
    }, "start"), D = mn(t);
    D instanceof ve && D.onLoad(A);
    let N = i(() => {
      if (!a.buffer) return 0;
      let M = u ? d - p : s.currentTime - p, O = a.buffer.duration;
      return a.loop ? M % O : Math.min(M, O);
    }, "getTime"), _ = i((M) => {
      let O = s.createBufferSource();
      return O.buffer = M.buffer, O.loop = M.loop, O.playbackRate.value = M.playbackRate.value, O.detune.value = M.detune.value, O.onended = M.onended, O.connect(f), O;
    }, "cloneNode");
    return { stop() {
      this.paused = true, this.seek(0);
    }, set paused(M) {
      if (u !== M) if (u = M, M) w && (a.stop(), w = false), d = s.currentTime;
      else {
        a = _(a);
        let O = d - p;
        a.start(0, O), w = true, p = s.currentTime - O, d = 0;
      }
    }, get paused() {
      return u;
    }, play(M = 0) {
      this.seek(M), this.paused = false;
    }, seek(M) {
      a.buffer?.duration && (M > a.buffer.duration || (u ? (a = _(a), p = d - M) : (a.stop(), a = _(a), p = s.currentTime - M, a.start(0, M), w = true, d = 0)));
    }, set speed(M) {
      a.playbackRate.value = M;
    }, get speed() {
      return a.playbackRate.value;
    }, set detune(M) {
      a.detune.value = M;
    }, get detune() {
      return a.detune.value;
    }, set volume(M) {
      f.gain.value = Math.max(M, 0);
    }, get volume() {
      return f.gain.value;
    }, set loop(M) {
      a.loop = M;
    }, get loop() {
      return a.loop;
    }, duration() {
      return a.buffer?.duration ?? 0;
    }, time() {
      return N() % this.duration();
    }, onEnd(M) {
      return h.add(M);
    }, then(M) {
      return this.onEnd(M);
    } };
  }
  i(It, "play");
  function Lt(t) {
    return It(te.burpSnd, t);
  }
  i(Lt, "burp");
  function wn(t, r) {
    return new rt(q, t, r);
  }
  i(wn, "makeCanvas");
  function ht(t = Xn, r = Jn) {
    let s = Wi.replace("{{user}}", t ?? Xn), u = Xi.replace("{{user}}", r ?? Jn);
    try {
      return new Jt(q, s, u, Qn.map((a) => a.name));
    } catch (a) {
      let f = /(?<type>^\w+) SHADER ERROR: 0:(?<line>\d+): (?<msg>.+)/, b = Br(a).match(f), p = Number(b.groups.line) - 14, d = b.groups.msg.trim(), w = b.groups.type.toLowerCase();
      throw new Error(`${w} shader line ${p}: ${d}`);
    }
  }
  i(ht, "makeShader");
  function bn(t, r, s, u) {
    let a = t.width / r, h = {}, f = u.split("").entries();
    for (let [b, p] of f) h[p] = new oe(b % a * r, Math.floor(b / a) * s, r, s);
    return { tex: t, map: h, size: s };
  }
  i(bn, "makeFont");
  function lt(t, r, s, u = E.defTex, a = E.defShader, h = {}) {
    let f = pn(a);
    if (!f || f instanceof ve) return;
    let b = E.fixed || s ? E.transform : C.cam.transform.mult(E.transform), p = [];
    for (let d of t) {
      let w = vn(b.multVec2(d.pos));
      p.push(w.x, w.y, d.uv.x, d.uv.y, d.color.r / 255, d.color.g / 255, d.color.b / 255, d.opacity);
    }
    E.renderer.push(S.TRIANGLES, p, r, f, u, h);
  }
  i(lt, "drawRaw");
  function Pe() {
    E.renderer.flush();
  }
  i(Pe, "flush");
  function dt() {
    S.clear(S.COLOR_BUFFER_BIT), E.frameBuffer.bind(), S.clear(S.COLOR_BUFFER_BIT), E.bgColor || Ce(() => {
      Be({ width: we(), height: xe(), quad: new oe(0, 0, we() / Kr, xe() / Kr), tex: E.bgTex, fixed: true });
    }), E.renderer.numDraws = 0, E.fixed = false, E.transformStack.length = 0, E.transform = new Ue();
  }
  i(dt, "frameStart");
  function Vt(t, r) {
    E.postShader = t, E.postShaderUniform = r ?? null;
  }
  i(Vt, "usePostEffect");
  function ft() {
    Pe(), E.lastDrawCalls = E.renderer.numDraws, E.frameBuffer.unbind(), S.viewport(0, 0, S.drawingBufferWidth, S.drawingBufferHeight);
    let t = E.width, r = E.height;
    E.width = S.drawingBufferWidth / P, E.height = S.drawingBufferHeight / P, We({ flipY: true, tex: E.frameBuffer.tex, pos: new v(E.viewport.x, E.viewport.y), width: E.viewport.width, height: E.viewport.height, shader: E.postShader, uniform: typeof E.postShaderUniform == "function" ? E.postShaderUniform() : E.postShaderUniform, fixed: true }), Pe(), E.width = t, E.height = r;
  }
  i(ft, "frameEnd");
  function vn(t) {
    return new v(t.x / we() * 2 - 1, -t.y / xe() * 2 + 1);
  }
  i(vn, "screen2ndc");
  function _t2(t) {
    E.transform = t.clone();
  }
  i(_t2, "pushMatrix");
  function ne(...t) {
    if (t[0] === void 0) return;
    let r = T(...t);
    r.x === 0 && r.y === 0 || E.transform.translate(r);
  }
  i(ne, "pushTranslate");
  function He(...t) {
    if (t[0] === void 0) return;
    let r = T(...t);
    r.x === 1 && r.y === 1 || E.transform.scale(r);
  }
  i(He, "pushScale");
  function se(t) {
    t && E.transform.rotate(t);
  }
  i(se, "pushRotate");
  function le() {
    E.transformStack.push(E.transform.clone());
  }
  i(le, "pushTransform");
  function ae() {
    E.transformStack.length > 0 && (E.transform = E.transformStack.pop());
  }
  i(ae, "popTransform");
  function Be(t) {
    if (t.width === void 0 || t.height === void 0) throw new Error('drawUVQuad() requires property "width" and "height".');
    if (t.width <= 0 || t.height <= 0) return;
    let r = t.width, s = t.height, a = ut(t.anchor || tn).scale(new v(r, s).scale(-0.5)), h = t.quad || new oe(0, 0, 1, 1), f = t.color || J(255, 255, 255), b = t.opacity ?? 1, p = t.tex ? Qr / t.tex.width : 0, d = t.tex ? Qr / t.tex.height : 0, w = h.x + p, A = h.y + d, D = h.w - p * 2, N = h.h - d * 2;
    le(), ne(t.pos), se(t.angle), He(t.scale), ne(a), lt([{ pos: new v(-r / 2, s / 2), uv: new v(t.flipX ? w + D : w, t.flipY ? A : A + N), color: f, opacity: b }, { pos: new v(-r / 2, -s / 2), uv: new v(t.flipX ? w + D : w, t.flipY ? A + N : A), color: f, opacity: b }, { pos: new v(r / 2, -s / 2), uv: new v(t.flipX ? w : w + D, t.flipY ? A + N : A), color: f, opacity: b }, { pos: new v(r / 2, s / 2), uv: new v(t.flipX ? w : w + D, t.flipY ? A : A + N), color: f, opacity: b }], [0, 1, 3, 1, 2, 3], t.fixed, t.tex, t.shader, t.uniform), ae();
  }
  i(Be, "drawUVQuad");
  function We(t) {
    if (!t.tex) throw new Error('drawTexture() requires property "tex".');
    let r = t.quad ?? new oe(0, 0, 1, 1), s = t.tex.width * r.w, u = t.tex.height * r.h, a = new v(1);
    if (t.tiled) {
      let h = Math.ceil((t.width || s) / s), f = Math.ceil((t.height || u) / u), p = ut(t.anchor || tn).add(new v(1, 1)).scale(0.5).scale(h * s, f * u);
      for (let d = 0; d < h; d++) for (let w = 0; w < f; w++) Be(Object.assign({}, t, { pos: (t.pos || new v(0)).add(new v(s * d, u * w)).sub(p), scale: a.scale(t.scale || new v(1)), tex: t.tex, quad: r, width: s, height: u, anchor: "topleft" }));
    } else t.width && t.height ? (a.x = t.width / s, a.y = t.height / u) : t.width ? (a.x = t.width / s, a.y = a.x) : t.height && (a.y = t.height / u, a.x = a.y), Be(Object.assign({}, t, { scale: a.scale(t.scale || new v(1)), tex: t.tex, quad: r, width: s, height: u }));
  }
  i(We, "drawTexture");
  function yn(t) {
    if (!t.sprite) throw new Error('drawSprite() requires property "sprite"');
    let r = ct(t.sprite);
    if (!r || !r.data) return;
    let s = r.data.frames[t.frame ?? 0];
    if (!s) throw new Error(`Frame not found: ${t.frame ?? 0}`);
    We(Object.assign({}, t, { tex: r.data.tex, quad: s.scale(t.quad ?? new oe(0, 0, 1, 1)) }));
  }
  i(yn, "drawSprite");
  function qe(t, r, s, u, a, h = 1) {
    u = Ge(u % 360), a = Ge(a % 360), a <= u && (a += Math.PI * 2);
    let f = [], b = Math.ceil((a - u) / Ge(8) * h), p = (a - u) / b;
    for (let d = u; d < a; d += p) f.push(t.add(r * Math.cos(d), s * Math.sin(d)));
    return f.push(t.add(r * Math.cos(a), s * Math.sin(a))), f;
  }
  i(qe, "getArcPts");
  function ge(t) {
    if (t.width === void 0 || t.height === void 0) throw new Error('drawRect() requires property "width" and "height".');
    if (t.width <= 0 || t.height <= 0) return;
    let r = t.width, s = t.height, a = ut(t.anchor || tn).add(1, 1).scale(new v(r, s).scale(-0.5)), h = [new v(0, 0), new v(r, 0), new v(r, s), new v(0, s)];
    if (t.radius) {
      let f = Math.min(Math.min(r, s) / 2, t.radius);
      h = [new v(f, 0), new v(r - f, 0), ...qe(new v(r - f, f), f, f, 270, 360), new v(r, f), new v(r, s - f), ...qe(new v(r - f, s - f), f, f, 0, 90), new v(r - f, s), new v(f, s), ...qe(new v(f, s - f), f, f, 90, 180), new v(0, s - f), new v(0, f), ...qe(new v(f, f), f, f, 180, 270)];
    }
    z(Object.assign({}, t, { offset: a, pts: h, ...t.gradient ? { colors: t.horizontal ? [t.gradient[0], t.gradient[1], t.gradient[1], t.gradient[0]] : [t.gradient[0], t.gradient[0], t.gradient[1], t.gradient[1]] } : {} }));
  }
  i(ge, "drawRect");
  function l(t) {
    let { p1: r, p2: s } = t;
    if (!r || !s) throw new Error('drawLine() requires properties "p1" and "p2".');
    let u = t.width || 1, a = s.sub(r).unit().normal().scale(u * 0.5), h = [r.sub(a), r.add(a), s.add(a), s.sub(a)].map((f) => ({ pos: new v(f.x, f.y), uv: new v(0), color: t.color ?? W.WHITE, opacity: t.opacity ?? 1 }));
    lt(h, [0, 1, 3, 1, 2, 3], t.fixed, E.defTex, t.shader, t.uniform);
  }
  i(l, "drawLine");
  function x(t) {
    let r = t.pts;
    if (!r) throw new Error('drawLines() requires property "pts".');
    if (!(r.length < 2)) if (t.radius && r.length >= 3) {
      let s = r[0].sdist(r[1]);
      for (let a = 1; a < r.length - 1; a++) s = Math.min(r[a].sdist(r[a + 1]), s);
      Math.min(t.radius, Math.sqrt(s) / 2);
      l(Object.assign({}, t, { p1: r[0], p2: r[1] }));
      for (let a = 1; a < r.length - 2; a++) {
        let h = r[a], f = r[a + 1];
        l(Object.assign({}, t, { p1: h, p2: f }));
      }
      l(Object.assign({}, t, { p1: r[r.length - 2], p2: r[r.length - 1] }));
    } else for (let s = 0; s < r.length - 1; s++) l(Object.assign({}, t, { p1: r[s], p2: r[s + 1] })), t.join !== "none" && L(Object.assign({}, t, { pos: r[s], radius: t.width / 2 }));
  }
  i(x, "drawLines");
  function R(t) {
    if (!t.p1 || !t.p2 || !t.p3) throw new Error('drawTriangle() requires properties "p1", "p2" and "p3".');
    return z(Object.assign({}, t, { pts: [t.p1, t.p2, t.p3] }));
  }
  i(R, "drawTriangle");
  function L(t) {
    if (typeof t.radius != "number") throw new Error('drawCircle() requires property "radius".');
    t.radius !== 0 && he(Object.assign({}, t, { radiusX: t.radius, radiusY: t.radius, angle: 0 }));
  }
  i(L, "drawCircle");
  function he(t) {
    if (t.radiusX === void 0 || t.radiusY === void 0) throw new Error('drawEllipse() requires properties "radiusX" and "radiusY".');
    if (t.radiusX === 0 || t.radiusY === 0) return;
    let r = t.start ?? 0, s = t.end ?? 360, u = ut(t.anchor ?? "center").scale(new v(-t.radiusX, -t.radiusY)), a = qe(u, t.radiusX, t.radiusY, r, s, t.resolution);
    a.unshift(u);
    let h = Object.assign({}, t, { pts: a, radius: 0, ...t.gradient ? { colors: [t.gradient[0], ...Array(a.length - 1).fill(t.gradient[1])] } : {} });
    if (s - r >= 360 && t.outline) {
      t.fill !== false && z(Object.assign(h, { outline: null })), z(Object.assign(h, { pts: a.slice(1), fill: false }));
      return;
    }
    z(h);
  }
  i(he, "drawEllipse");
  function z(t) {
    if (!t.pts) throw new Error('drawPolygon() requires property "pts".');
    let r = t.pts.length;
    if (!(r < 3)) {
      if (le(), ne(t.pos), He(t.scale), se(t.angle), ne(t.offset), t.fill !== false) {
        let s = t.color ?? W.WHITE, u = t.pts.map((h, f) => ({ pos: new v(h.x, h.y), uv: new v(0, 0), color: t.colors && t.colors[f] ? t.colors[f].mult(s) : s, opacity: t.opacity ?? 1 })), a = [...Array(r - 2).keys()].map((h) => [0, h + 1, h + 2]).flat();
        lt(u, t.indices ?? a, t.fixed, E.defTex, t.shader, t.uniform);
      }
      t.outline && x({ pts: [...t.pts, t.pts[0]], radius: t.radius, width: t.outline.width, color: t.outline.color, join: t.outline.join, uniform: t.uniform, fixed: t.fixed, opacity: t.opacity }), ae();
    }
  }
  i(z, "drawPolygon");
  function Oe(t, r, s) {
    Pe(), S.clear(S.STENCIL_BUFFER_BIT), S.enable(S.STENCIL_TEST), S.stencilFunc(S.NEVER, 1, 255), S.stencilOp(S.REPLACE, S.REPLACE, S.REPLACE), r(), Pe(), S.stencilFunc(s, 1, 255), S.stencilOp(S.KEEP, S.KEEP, S.KEEP), t(), Pe(), S.disable(S.STENCIL_TEST);
  }
  i(Oe, "drawStenciled");
  function $e(t, r) {
    Oe(t, r, S.EQUAL);
  }
  i($e, "drawMasked");
  function kt(t, r) {
    Oe(t, r, S.NOTEQUAL);
  }
  i(kt, "drawSubtracted");
  function De() {
    return (E.viewport.width + E.viewport.height) / (E.width + E.height);
  }
  i(De, "getViewportScale");
  function Ce(t) {
    Pe();
    let r = E.width, s = E.height;
    E.width = E.viewport.width, E.height = E.viewport.height, t(), Pe(), E.width = r, E.height = s;
  }
  i(Ce, "drawUnscaled");
  function Zn(t, r) {
    r.pos && (t.pos = t.pos.add(r.pos)), r.scale && (t.scale = t.scale.scale(T(r.scale))), r.angle && (t.angle += r.angle), r.color && t.ch.length === 1 && (t.color = t.color.mult(r.color)), r.opacity && (t.opacity *= r.opacity);
  }
  i(Zn, "applyCharTransform");
  let er = /\[(?<style>\w+)\](?<text>.*?)\[\/\k<style>\]/g;
  function es(t) {
    let r = {}, s = t.replace(er, "$2"), u = 0;
    for (let a of t.matchAll(er)) {
      let h = a.index - u;
      for (let f = 0; f < a.groups.text.length; f++) r[f + h] = [a.groups.style];
      u += a[0].length - a.groups.text.length;
    }
    return { charStyleMap: r, text: s };
  }
  i(es, "compileStyledText");
  let xn = {};
  function Xe(t) {
    if (t.text === void 0) throw new Error('formatText() requires property "text".');
    let r = Ft(t.font);
    if (t.text === "" || r instanceof ve || !r) return { width: 0, height: 0, chars: [], opt: t };
    let { charStyleMap: s, text: u } = es(t.text + ""), a = Fr(u);
    if (r instanceof Se || typeof r == "string") {
      let Z = r instanceof Se ? r.fontface.family : r, H = r instanceof Se ? { outline: r.outline, filter: r.filter } : { outline: null, filter: Wn }, V = xn[Z] ?? { font: { tex: new Re(q, Yr, Wr, { filter: H.filter }), map: {}, size: rn }, cursor: new v(0), outline: H.outline };
      xn[Z] || (xn[Z] = V), r = V.font;
      for (let fe of a) if (!V.font.map[fe]) {
        let U = j;
        U.clearRect(0, 0, I.width, I.height), U.font = `${r.size}px ${Z}`, U.textBaseline = "top", U.textAlign = "left", U.fillStyle = "#ffffff";
        let G = U.measureText(fe), B = Math.ceil(G.width), F = r.size;
        V.outline && (U.lineJoin = "round", U.lineWidth = V.outline.width * 2, U.strokeStyle = V.outline.color.toHex(), U.strokeText(fe, V.outline.width, V.outline.width), B += V.outline.width * 2, F += V.outline.width * 3), U.fillText(fe, V.outline?.width ?? 0, V.outline?.width ?? 0);
        let Y = U.getImageData(0, 0, B, F);
        if (V.cursor.x + B > Yr && (V.cursor.x = 0, V.cursor.y += F, V.cursor.y > Wr)) throw new Error("Font atlas exceeds character limit");
        r.tex.update(Y, V.cursor.x, V.cursor.y), r.map[fe] = new oe(V.cursor.x, V.cursor.y, B, F), V.cursor.x += B;
      }
    }
    let h = t.size || r.size, f = T(t.scale ?? 1).scale(h / r.size), b = t.lineSpacing ?? 0, p = t.letterSpacing ?? 0, d = 0, w = 0, A = 0, D = [], N = [], _ = 0, M = null, O = null;
    for (; _ < a.length; ) {
      let Z = a[_];
      if (Z === `
`) A += h + b, D.push({ width: d - p, chars: N }), M = null, O = null, d = 0, N = [];
      else {
        let H = r.map[Z];
        if (H) {
          let V = H.w * f.x;
          t.width && d + V > t.width && (A += h + b, M != null && (_ -= N.length - M, Z = a[_], H = r.map[Z], V = H.w * f.x, N = N.slice(0, M - 1), d = O), M = null, O = null, D.push({ width: d - p, chars: N }), d = 0, N = []), N.push({ tex: r.tex, width: H.w, height: H.h, quad: new oe(H.x / r.tex.width, H.y / r.tex.height, H.w / r.tex.width, H.h / r.tex.height), ch: Z, pos: new v(d, A), opacity: t.opacity ?? 1, color: t.color ?? W.WHITE, scale: T(f), angle: 0 }), Z === " " && (M = N.length, O = d), d += V, w = Math.max(w, d), d += p;
        }
      }
      _++;
    }
    D.push({ width: d - p, chars: N }), A += h, t.width && (w = t.width);
    let ie = [];
    for (let Z of D) {
      let H = (w - Z.width) * Zi(t.align ?? "left");
      for (let V of Z.chars) {
        let fe = r.map[V.ch], U = ie.length;
        if (V.pos = V.pos.add(H, 0).add(fe.w * f.x * 0.5, fe.h * f.y * 0.5), t.transform) {
          let G = typeof t.transform == "function" ? t.transform(U, V.ch) : t.transform;
          G && Zn(V, G);
        }
        if (s[U]) {
          let G = s[U];
          for (let B of G) {
            let F = t.styles[B], Y = typeof F == "function" ? F(U, V.ch) : F;
            Y && Zn(V, Y);
          }
        }
        ie.push(V);
      }
    }
    return { width: w, height: A, chars: ie, opt: t };
  }
  i(Xe, "formatText");
  function tr(t) {
    Je(Xe(t));
  }
  i(tr, "drawText");
  function Je(t) {
    le(), ne(t.opt.pos), se(t.opt.angle), ne(ut(t.opt.anchor ?? "topleft").add(1, 1).scale(t.width, t.height).scale(-0.5)), t.chars.forEach((r) => {
      Be({ tex: r.tex, width: r.width, height: r.height, pos: r.pos, scale: r.scale, angle: r.angle, color: r.color, opacity: r.opacity, quad: r.quad, anchor: "center", uniform: t.opt.uniform, shader: t.opt.shader, fixed: t.opt.fixed });
    }), ae();
  }
  i(Je, "drawFormattedText");
  function we() {
    return E.width;
  }
  i(we, "width");
  function xe() {
    return E.height;
  }
  i(xe, "height");
  function ts(t) {
    return new v((t.x - E.viewport.x) * we() / E.viewport.width, (t.y - E.viewport.y) * xe() / E.viewport.height);
  }
  i(ts, "windowToContent");
  function ns(t) {
    return new v(t.x * E.viewport.width / E.width, t.y * E.viewport.height / E.height);
  }
  i(ns, "contentToView");
  function Nt() {
    return ts(y.mousePos());
  }
  i(Nt, "mousePos");
  let nr = false, re = { inspect: false, timeScale: 1, showLog: true, fps: () => y.fps(), numFrames: () => y.numFrames(), stepFrame: dr, drawCalls: () => E.lastDrawCalls, clearLog: () => C.logs = [], log: (t) => {
    let r = n.logMax ?? qi;
    C.logs.unshift({ msg: t, time: y.time() }), C.logs.length > r && (C.logs = C.logs.slice(0, r));
  }, error: (t) => re.log(new Error(t.toString ? t.toString() : t)), curRecording: null, numObjects: () => On("*", { recursive: true }).length, get paused() {
    return nr;
  }, set paused(t) {
    nr = t, t ? te.ctx.suspend() : te.ctx.resume();
  } };
  function Me() {
    return y.dt() * re.timeScale;
  }
  i(Me, "dt");
  function rs(...t) {
    return t.length > 0 && (C.cam.pos = T(...t)), C.cam.pos ? C.cam.pos.clone() : zt();
  }
  i(rs, "camPos");
  function ss(...t) {
    return t.length > 0 && (C.cam.scale = T(...t)), C.cam.scale.clone();
  }
  i(ss, "camScale");
  function is(t) {
    return t !== void 0 && (C.cam.angle = t), C.cam.angle;
  }
  i(is, "camRot");
  function os(t = 12) {
    C.cam.shake += t;
  }
  i(os, "shake");
  function rr(t) {
    return C.cam.transform.multVec2(t);
  }
  i(rr, "toScreen");
  function sr(t) {
    return C.cam.transform.invert().multVec2(t);
  }
  i(sr, "toWorld");
  function jt(t) {
    let r = new Ue();
    return t.pos && r.translate(t.pos), t.scale && r.scale(t.scale), t.angle && r.rotate(t.angle), t.parent ? r.mult(t.parent.transform) : r;
  }
  i(jt, "calcTransform");
  function Un(t = []) {
    let r = /* @__PURE__ */ new Map(), s = {}, u = new Ne(), a = [], h = null, f = false, b = { id: Gr(), hidden: false, transform: new Ue(), children: [], parent: null, set paused(d) {
      if (d !== f) {
        f = d;
        for (let w of a) w.paused = d;
      }
    }, get paused() {
      return f;
    }, add(d = []) {
      let w = Array.isArray(d) ? Un(d) : d;
      if (w.parent) throw new Error("Cannot add a game obj that already has a parent.");
      return w.parent = this, w.transform = jt(w), this.children.push(w), w.trigger("add", w), C.events.trigger("add", w), w;
    }, readd(d) {
      let w = this.children.indexOf(d);
      return w !== -1 && (this.children.splice(w, 1), this.children.push(d)), d;
    }, remove(d) {
      let w = this.children.indexOf(d);
      if (w !== -1) {
        d.parent = null, this.children.splice(w, 1);
        let A = i((D) => {
          D.trigger("destroy"), C.events.trigger("destroy", D), D.children.forEach((N) => A(N));
        }, "trigger");
        A(d);
      }
    }, removeAll(d) {
      if (d) this.get(d).forEach((w) => this.remove(w));
      else for (let w of [...this.children]) this.remove(w);
    }, update() {
      this.paused || (this.children.sort((d, w) => (d.z ?? 0) - (w.z ?? 0)).forEach((d) => d.update()), this.trigger("update"));
    }, draw() {
      if (this.hidden) return;
      this.canvas && this.canvas.bind();
      let d = E.fixed;
      this.fixed && (E.fixed = true), le(), ne(this.pos), He(this.scale), se(this.angle);
      let w = this.children.sort((A, D) => (A.z ?? 0) - (D.z ?? 0));
      if (this.mask) {
        let A = { intersect: $e, subtract: kt }[this.mask];
        if (!A) throw new Error(`Invalid mask func: "${this.mask}"`);
        A(() => {
          w.forEach((D) => D.draw());
        }, () => {
          this.trigger("draw");
        });
      } else this.trigger("draw"), w.forEach((A) => A.draw());
      ae(), E.fixed = d, this.canvas && this.canvas.unbind();
    }, drawInspect() {
      this.hidden || (le(), ne(this.pos), He(this.scale), se(this.angle), this.children.sort((d, w) => (d.z ?? 0) - (w.z ?? 0)).forEach((d) => d.drawInspect()), this.trigger("drawInspect"), ae());
    }, use(d) {
      if (!d) return;
      if (typeof d == "string") return this.use({ id: d });
      let w = [];
      d.id && (this.unuse(d.id), s[d.id] = [], w = s[d.id], r.set(d.id, d));
      for (let D in d) {
        if (Ji.has(D)) continue;
        let N = Object.getOwnPropertyDescriptor(d, D);
        if (typeof N.value == "function" && (d[D] = d[D].bind(this)), N.set && Object.defineProperty(d, D, { set: N.set.bind(this) }), N.get && Object.defineProperty(d, D, { get: N.get.bind(this) }), Qi.has(D)) {
          let _ = D === "add" ? () => {
            h = i((M) => w.push(M), "onCurCompCleanup"), d[D](), h = null;
          } : d[D];
          w.push(this.on(D, _).cancel);
        } else if (this[D] === void 0) Object.defineProperty(this, D, { get: () => d[D], set: (_) => d[D] = _, configurable: true, enumerable: true }), w.push(() => delete this[D]);
        else throw new Error(`Duplicate component property: "${D}"`);
      }
      let A = i(() => {
        if (d.require) {
          for (let D of d.require) if (!this.c(D)) throw new Error(`Component "${d.id}" requires component "${D}"`);
        }
      }, "checkDeps");
      d.destroy && w.push(d.destroy.bind(this)), this.exists() ? (A(), d.add && (h = i((D) => w.push(D), "onCurCompCleanup"), d.add.call(this), h = null)) : d.require && w.push(this.on("add", A).cancel);
    }, unuse(d) {
      s[d] && (s[d].forEach((w) => w()), delete s[d]), r.has(d) && r.delete(d);
    }, c(d) {
      return r.get(d);
    }, get(d, w = {}) {
      let A = w.recursive ? this.children.flatMap(i(function D(N) {
        return [N, ...N.children.flatMap(D)];
      }, "recurse")) : this.children;
      if (A = A.filter((D) => d ? D.is(d) : true), w.liveUpdate) {
        let D = i((_) => w.recursive ? this.isAncestorOf(_) : _.parent === this, "isChild"), N = [];
        N.push(En((_) => {
          D(_) && _.is(d) && A.push(_);
        })), N.push(ir((_) => {
          if (D(_) && _.is(d)) {
            let M = A.findIndex((O) => O.id === _.id);
            M !== -1 && A.splice(M, 1);
          }
        })), this.onDestroy(() => {
          for (let _ of N) _.cancel();
        });
      }
      return A;
    }, isAncestorOf(d) {
      return d.parent ? d.parent === this || this.isAncestorOf(d.parent) : false;
    }, exists() {
      return C.root.isAncestorOf(this);
    }, is(d) {
      if (d === "*") return true;
      if (Array.isArray(d)) {
        for (let w of d) if (!this.c(w)) return false;
        return true;
      } else return this.c(d) != null;
    }, on(d, w) {
      let A = u.on(d, w.bind(this));
      return h && h(() => A.cancel()), A;
    }, trigger(d, ...w) {
      u.trigger(d, ...w), C.objEvents.trigger(d, this, ...w);
    }, destroy() {
      this.parent && this.parent.remove(this);
    }, inspect() {
      let d = {};
      for (let [w, A] of r) d[w] = A.inspect ? A.inspect() : null;
      return d;
    }, onAdd(d) {
      return this.on("add", d);
    }, onUpdate(d) {
      return this.on("update", d);
    }, onDraw(d) {
      return this.on("draw", d);
    }, onDestroy(d) {
      return this.on("destroy", d);
    }, clearEvents() {
      u.clear();
    } }, p = ["onKeyPress", "onKeyPressRepeat", "onKeyDown", "onKeyRelease", "onMousePress", "onMouseDown", "onMouseRelease", "onMouseMove", "onCharInput", "onMouseMove", "onTouchStart", "onTouchMove", "onTouchEnd", "onScroll", "onGamepadButtonPress", "onGamepadButtonDown", "onGamepadButtonRelease", "onGamepadStick"];
    for (let d of p) b[d] = (...w) => {
      let A = y[d](...w);
      return a.push(A), b.onDestroy(() => A.cancel()), A;
    };
    for (let d of t) b.use(d);
    return b;
  }
  i(Un, "make");
  function ze(t, r, s) {
    return C.objEvents[t] || (C.objEvents[t] = new Ut()), C.objEvents.on(t, (u, ...a) => {
      u.is(r) && s(u, ...a);
    });
  }
  i(ze, "on");
  let as = Ee((t) => {
    let r = gt([{ update: t }]);
    return { get paused() {
      return r.paused;
    }, set paused(s) {
      r.paused = s;
    }, cancel: () => r.destroy() };
  }, (t, r) => ze("update", t, r)), us = Ee((t) => {
    let r = gt([{ draw: t }]);
    return { get paused() {
      return r.hidden;
    }, set paused(s) {
      r.hidden = s;
    }, cancel: () => r.destroy() };
  }, (t, r) => ze("draw", t, r)), En = Ee((t) => C.events.on("add", t), (t, r) => ze("add", t, r)), ir = Ee((t) => C.events.on("destroy", t), (t, r) => ze("destroy", t, r));
  function cs(t, r, s) {
    return ze("collide", t, (u, a, h) => a.is(r) && s(u, a, h));
  }
  i(cs, "onCollide");
  function hs(t, r, s) {
    return ze("collideUpdate", t, (u, a, h) => a.is(r) && s(u, a, h));
  }
  i(hs, "onCollideUpdate");
  function ls(t, r, s) {
    return ze("collideEnd", t, (u, a, h) => a.is(r) && s(u, a, h));
  }
  i(ls, "onCollideEnd");
  function Ht(t, r) {
    On(t, { recursive: true }).forEach(r), En(t, r);
  }
  i(Ht, "forAllCurrentAndFuture");
  let ds = Ee((t) => y.onMousePress(t), (t, r) => {
    let s = [];
    return Ht(t, (u) => {
      if (!u.area) throw new Error("onClick() requires the object to have area() component");
      s.push(u.onClick(() => r(u)));
    }), ke.join(s);
  });
  function fs(t, r) {
    let s = [];
    return Ht(t, (u) => {
      if (!u.area) throw new Error("onHover() requires the object to have area() component");
      s.push(u.onHover(() => r(u)));
    }), ke.join(s);
  }
  i(fs, "onHover");
  function ms(t, r) {
    let s = [];
    return Ht(t, (u) => {
      if (!u.area) throw new Error("onHoverUpdate() requires the object to have area() component");
      s.push(u.onHoverUpdate(() => r(u)));
    }), ke.join(s);
  }
  i(ms, "onHoverUpdate");
  function ps(t, r) {
    let s = [];
    return Ht(t, (u) => {
      if (!u.area) throw new Error("onHoverEnd() requires the object to have area() component");
      s.push(u.onHoverEnd(() => r(u)));
    }), ke.join(s);
  }
  i(ps, "onHoverEnd");
  function gs(t) {
    C.gravity = t;
  }
  i(gs, "setGravity");
  function ws() {
    return C.gravity;
  }
  i(ws, "getGravity");
  function bs(...t) {
    t.length === 1 || t.length === 2 ? (E.bgColor = J(t[0]), t[1] && (E.bgAlpha = t[1])) : (t.length === 3 || t.length === 4) && (E.bgColor = J(t[0], t[1], t[2]), t[3] && (E.bgAlpha = t[3])), S.clearColor(E.bgColor.r / 255, E.bgColor.g / 255, E.bgColor.b / 255, E.bgAlpha);
  }
  i(bs, "setBackground");
  function vs() {
    return E.bgColor.clone();
  }
  i(vs, "getBackground");
  function qt(...t) {
    return { id: "pos", pos: T(...t), moveBy(...r) {
      this.pos = this.pos.add(T(...r));
    }, move(...r) {
      this.moveBy(T(...r).scale(Me()));
    }, moveTo(...r) {
      if (typeof r[0] == "number" && typeof r[1] == "number") return this.moveTo(T(r[0], r[1]), r[2]);
      let s = r[0], u = r[1];
      if (u === void 0) {
        this.pos = T(s);
        return;
      }
      let a = s.sub(this.pos);
      if (a.len() <= u * Me()) {
        this.pos = T(s);
        return;
      }
      this.move(a.unit().scale(u));
    }, worldPos() {
      return this.parent ? this.parent.transform.multVec2(this.pos) : this.pos;
    }, screenPos() {
      let r = this.worldPos();
      return pt(this) ? r : rr(r);
    }, inspect() {
      return `(${Math.round(this.pos.x)}, ${Math.round(this.pos.y)})`;
    }, drawInspect() {
      L({ color: J(255, 0, 0), radius: 4 / De() });
    } };
  }
  i(qt, "pos");
  function $t(...t) {
    return t.length === 0 ? $t(1) : { id: "scale", scale: T(...t), scaleTo(...r) {
      this.scale = T(...r);
    }, scaleBy(...r) {
      this.scale.scale(T(...r));
    }, inspect() {
      return `(${mt(this.scale.x, 2)}, ${mt(this.scale.y, 2)})`;
    } };
  }
  i($t, "scale");
  function ys(t) {
    return { id: "rotate", angle: t ?? 0, rotateBy(r) {
      this.angle += r;
    }, rotateTo(r) {
      this.angle = r;
    }, inspect() {
      return `${Math.round(this.angle)}`;
    } };
  }
  i(ys, "rotate");
  function xs(...t) {
    return { id: "color", color: J(...t), inspect() {
      return this.color.toString();
    } };
  }
  i(xs, "color");
  function mt(t, r) {
    return Number(t.toFixed(r));
  }
  i(mt, "toFixed");
  function Us(t) {
    return { id: "opacity", opacity: t ?? 1, inspect() {
      return `${mt(this.opacity, 1)}`;
    }, fadeOut(r = 1, s = Ct.linear) {
      return Rn(this.opacity, 0, r, (u) => this.opacity = u, s);
    } };
  }
  i(Us, "opacity");
  function Sn(t) {
    if (!t) throw new Error("Please define an anchor");
    return { id: "anchor", anchor: t, inspect() {
      return typeof this.anchor == "string" ? this.anchor : this.anchor.toString();
    } };
  }
  i(Sn, "anchor");
  function Es(t) {
    return { id: "z", z: t, inspect() {
      return `${this.z}`;
    } };
  }
  i(Es, "z");
  function Ss(t, r) {
    return { id: "follow", require: ["pos"], follow: { obj: t, offset: r ?? T(0) }, add() {
      t.exists() && (this.pos = this.follow.obj.pos.add(this.follow.offset));
    }, update() {
      t.exists() && (this.pos = this.follow.obj.pos.add(this.follow.offset));
    } };
  }
  i(Ss, "follow");
  function Cs(t, r) {
    let s = typeof t == "number" ? v.fromAngle(t) : t.unit();
    return { id: "move", require: ["pos"], update() {
      this.move(s.scale(r));
    } };
  }
  i(Cs, "move");
  let As = 200;
  function Ts(t = {}) {
    let r = t.distance ?? As, s = false;
    return { id: "offscreen", require: ["pos"], isOffScreen() {
      let u = this.screenPos(), a = new de(T(0), we(), xe());
      return !vt(a, u) && a.sdistToPoint(u) > r * r;
    }, onExitScreen(u) {
      return this.on("exitView", u);
    }, onEnterScreen(u) {
      return this.on("enterView", u);
    }, update() {
      this.isOffScreen() ? (s || (this.trigger("exitView"), s = true), t.hide && (this.hidden = true), t.pause && (this.paused = true), t.destroy && this.destroy()) : (s && (this.trigger("enterView"), s = false), t.hide && (this.hidden = false), t.pause && (this.paused = false));
    } };
  }
  i(Ts, "offscreen");
  function pt(t) {
    return t.fixed ? true : t.parent ? pt(t.parent) : false;
  }
  i(pt, "isFixed");
  function Os(t = {}) {
    let r = {}, s = /* @__PURE__ */ new Set();
    return { id: "area", collisionIgnore: t.collisionIgnore ?? [], add() {
      this.area.cursor && this.onHover(() => y.setCursor(this.area.cursor)), this.onCollideUpdate((u, a) => {
        r[u.id] || this.trigger("collide", u, a), r[u.id] = a, s.add(u.id);
      });
    }, update() {
      for (let u in r) s.has(Number(u)) || (this.trigger("collideEnd", r[u].target), delete r[u]);
      s.clear();
    }, drawInspect() {
      let u = this.localArea();
      le(), He(this.area.scale), ne(this.area.offset);
      let a = { outline: { width: 4 / De(), color: J(0, 0, 255) }, anchor: this.anchor, fill: false, fixed: pt(this) };
      u instanceof de ? ge({ ...a, pos: u.pos, width: u.width, height: u.height }) : u instanceof Ke ? z({ ...a, pts: u.pts }) : u instanceof yt && L({ ...a, pos: u.center, radius: u.radius }), ae();
    }, area: { shape: t.shape ?? null, scale: t.scale ? T(t.scale) : T(1), offset: t.offset ?? T(0), cursor: t.cursor ?? null }, isClicked() {
      return y.isMousePressed() && this.isHovering();
    }, isHovering() {
      let u = pt(this) ? Nt() : sr(Nt());
      return this.hasPoint(u);
    }, checkCollision(u) {
      return r[u.id] ?? null;
    }, getCollisions() {
      return Object.values(r);
    }, isColliding(u) {
      return !!r[u.id];
    }, isOverlapping(u) {
      let a = r[u.id];
      return a && a.hasOverlap();
    }, onClick(u) {
      let a = y.onMousePress("left", () => {
        this.isHovering() && u();
      });
      return this.onDestroy(() => a.cancel()), a;
    }, onHover(u) {
      let a = false;
      return this.onUpdate(() => {
        a ? a = this.isHovering() : this.isHovering() && (a = true, u());
      });
    }, onHoverUpdate(u) {
      return this.onUpdate(() => {
        this.isHovering() && u();
      });
    }, onHoverEnd(u) {
      let a = false;
      return this.onUpdate(() => {
        a ? this.isHovering() || (a = false, u()) : a = this.isHovering();
      });
    }, onCollide(u, a) {
      if (typeof u == "function" && a === void 0) return this.on("collide", u);
      if (typeof u == "string") return this.onCollide((h, f) => {
        h.is(u) && a(h, f);
      });
    }, onCollideUpdate(u, a) {
      if (typeof u == "function" && a === void 0) return this.on("collideUpdate", u);
      if (typeof u == "string") return this.on("collideUpdate", (h, f) => h.is(u) && a(h, f));
    }, onCollideEnd(u, a) {
      if (typeof u == "function" && a === void 0) return this.on("collideEnd", u);
      if (typeof u == "string") return this.on("collideEnd", (h) => h.is(u) && a(h));
    }, hasPoint(u) {
      return _n(this.worldArea(), u);
    }, resolveCollision(u) {
      let a = this.checkCollision(u);
      a && !a.resolved && (this.pos = this.pos.add(a.displacement), a.resolved = true);
    }, localArea() {
      return this.area.shape ? this.area.shape : this.renderArea();
    }, worldArea() {
      let u = this.localArea();
      if (!(u instanceof Ke || u instanceof de)) throw new Error("Only support polygon and rect shapes for now");
      let a = this.transform.clone().scale(T(this.area.scale ?? 1)).translate(this.area.offset);
      if (u instanceof de) {
        let h = ut(this.anchor || tn).add(1, 1).scale(-0.5).scale(u.width, u.height);
        a.translate(h);
      }
      return u.transform(a);
    }, screenArea() {
      let u = this.worldArea();
      return pt(this) ? u : u.transform(C.cam.transform);
    } };
  }
  i(Os, "area");
  function Qe(t) {
    return { color: t.color, opacity: t.opacity, anchor: t.anchor, outline: t.outline, shader: t.shader, uniform: t.uniform };
  }
  i(Qe, "getRenderProps");
  function Cn(t, r = {}) {
    let s = null, u = null, a = null, h = new be();
    if (!t) throw new Error("Please pass the resource name or data to sprite()");
    let f = i((b, p, d, w) => {
      let A = T(1, 1);
      return d && w ? (A.x = d / (b.width * p.w), A.y = w / (b.height * p.h)) : d ? (A.x = d / (b.width * p.w), A.y = A.x) : w && (A.y = w / (b.height * p.h), A.x = A.y), A;
    }, "calcTexScale");
    return { id: "sprite", width: 0, height: 0, frame: r.frame || 0, quad: r.quad || new oe(0, 0, 1, 1), animSpeed: r.animSpeed ?? 1, flipX: r.flipX ?? false, flipY: r.flipY ?? false, draw() {
      if (!s) return;
      let b = s.frames[this.frame ?? 0];
      if (!b) throw new Error(`Frame not found: ${this.frame ?? 0}`);
      if (s.slice9) {
        let { left: p, right: d, top: w, bottom: A } = s.slice9, D = s.tex.width * b.w, N = s.tex.height * b.h, _ = this.width - p - d, M = this.height - w - A, O = p / D, ie = d / D, Z = 1 - O - ie, H = w / N, V = A / N, fe = 1 - H - V, U = [ce(0, 0, O, H), ce(O, 0, Z, H), ce(O + Z, 0, ie, H), ce(0, H, O, fe), ce(O, H, Z, fe), ce(O + Z, H, ie, fe), ce(0, H + fe, O, V), ce(O, H + fe, Z, V), ce(O + Z, H + fe, ie, V), ce(0, 0, p, w), ce(p, 0, _, w), ce(p + _, 0, d, w), ce(0, w, p, M), ce(p, w, _, M), ce(p + _, w, d, M), ce(0, w + M, p, A), ce(p, w + M, _, A), ce(p + _, w + M, d, A)];
        for (let G = 0; G < 9; G++) {
          let B = U[G], F = U[G + 9];
          We(Object.assign(Qe(this), { pos: F.pos(), tex: s.tex, quad: b.scale(B), flipX: this.flipX, flipY: this.flipY, tiled: r.tiled, width: F.w, height: F.h }));
        }
      } else We(Object.assign(Qe(this), { tex: s.tex, quad: b.scale(this.quad ?? new oe(0, 0, 1, 1)), flipX: this.flipX, flipY: this.flipY, tiled: r.tiled, width: this.width, height: this.height }));
    }, add() {
      let b = i((d) => {
        let w = d.frames[0].clone();
        r.quad && (w = w.scale(r.quad));
        let A = f(d.tex, w, r.width, r.height);
        this.width = d.tex.width * w.w * A.x, this.height = d.tex.height * w.h * A.y, r.anim && this.play(r.anim), s = d, h.trigger(s);
      }, "setSpriteData"), p = ct(t);
      p ? p.onLoad(b) : Tn(() => b(ct(t).data));
    }, update() {
      if (!u) return;
      let b = s.anims[u.name];
      if (typeof b == "number") {
        this.frame = b;
        return;
      }
      if (b.speed === 0) throw new Error("Sprite anim speed cannot be 0");
      u.timer += Me() * this.animSpeed, u.timer >= 1 / u.speed && (u.timer = 0, this.frame += a, (this.frame < Math.min(b.from, b.to) || this.frame > Math.max(b.from, b.to)) && (u.loop ? u.pingpong ? (this.frame -= a, a *= -1, this.frame += a) : this.frame = b.from : (this.frame = b.to, u.onEnd(), this.stop())));
    }, play(b, p = {}) {
      if (!s) {
        h.add(() => this.play(b, p));
        return;
      }
      let d = s.anims[b];
      if (d === void 0) throw new Error(`Anim not found: ${b}`);
      u && this.stop(), u = typeof d == "number" ? { name: b, timer: 0, loop: false, pingpong: false, speed: 0, onEnd: () => {
      } } : { name: b, timer: 0, loop: p.loop ?? d.loop ?? false, pingpong: p.pingpong ?? d.pingpong ?? false, speed: p.speed ?? d.speed ?? 10, onEnd: p.onEnd ?? (() => {
      }) }, a = typeof d == "number" ? null : d.from < d.to ? 1 : -1, this.frame = typeof d == "number" ? d : d.from, this.trigger("animStart", b);
    }, stop() {
      if (!u) return;
      let b = u.name;
      u = null, this.trigger("animEnd", b);
    }, numFrames() {
      return s?.frames.length ?? 0;
    }, curAnim() {
      return u?.name;
    }, onAnimEnd(b) {
      return this.on("animEnd", b);
    }, onAnimStart(b) {
      return this.on("animStart", b);
    }, renderArea() {
      return new de(T(0), this.width, this.height);
    }, inspect() {
      if (typeof t == "string") return `"${t}"`;
    } };
  }
  i(Cn, "sprite");
  function Rs(t, r = {}) {
    function s(a) {
      let h = Xe(Object.assign(Qe(a), { text: a.text + "", size: a.textSize, font: a.font, width: r.width && a.width, align: a.align, letterSpacing: a.letterSpacing, lineSpacing: a.lineSpacing, transform: a.textTransform, styles: a.textStyles }));
      return r.width || (a.width = h.width / (a.scale?.x || 1)), a.height = h.height / (a.scale?.y || 1), h;
    }
    i(s, "update");
    let u = { id: "text", set text(a) {
      t = a, s(this);
    }, get text() {
      return t;
    }, textSize: r.size ?? ji, font: r.font, width: r.width ?? 0, height: 0, align: r.align, lineSpacing: r.lineSpacing, letterSpacing: r.letterSpacing, textTransform: r.transform, textStyles: r.styles, add() {
      Tn(() => s(this));
    }, draw() {
      Je(s(this));
    }, renderArea() {
      return new de(T(0), this.width, this.height);
    } };
    return s(u), u;
  }
  i(Rs, "text");
  function Ps(t, r = {}) {
    if (t.length < 3) throw new Error(`Polygon's need more than two points, ${t.length} points provided`);
    return { id: "polygon", pts: t, colors: r.colors, radius: r.radius, draw() {
      z(Object.assign(Qe(this), { pts: this.pts, colors: this.colors, radius: this.radius, fill: r.fill }));
    }, renderArea() {
      return new Ke(this.pts);
    }, inspect() {
      return this.pts.map((s) => `[${s.x},${s.y}]`).join(",");
    } };
  }
  i(Ps, "polygon");
  function Ds(t, r, s = {}) {
    return { id: "rect", width: t, height: r, radius: s.radius || 0, draw() {
      ge(Object.assign(Qe(this), { width: this.width, height: this.height, radius: this.radius, fill: s.fill }));
    }, renderArea() {
      return new de(T(0), this.width, this.height);
    }, inspect() {
      return `${Math.ceil(this.width)}, ${Math.ceil(this.height)}`;
    } };
  }
  i(Ds, "rect");
  function Ms(t, r) {
    return { id: "rect", width: t, height: r, draw() {
      Be(Object.assign(Qe(this), { width: this.width, height: this.height }));
    }, renderArea() {
      return new de(T(0), this.width, this.height);
    }, inspect() {
      return `${Math.ceil(this.width)}, ${Math.ceil(this.height)}`;
    } };
  }
  i(Ms, "uvquad");
  function Gs(t, r = {}) {
    return { id: "circle", radius: t, draw() {
      L(Object.assign(Qe(this), { radius: this.radius, fill: r.fill }));
    }, renderArea() {
      return new de(new v(this.anchor ? 0 : -this.radius), this.radius * 2, this.radius * 2);
    }, inspect() {
      return `${Math.ceil(this.radius)}`;
    } };
  }
  i(Gs, "circle");
  function Bs(t = 1, r = J(0, 0, 0)) {
    return { id: "outline", outline: { width: t, color: r } };
  }
  i(Bs, "outline");
  function An() {
    return { id: "timer", wait(t, r) {
      let s = [];
      r && s.push(r);
      let u = 0, a = this.onUpdate(() => {
        u += Me(), u >= t && (s.forEach((h) => h()), a.cancel());
      });
      return { get paused() {
        return a.paused;
      }, set paused(h) {
        a.paused = h;
      }, cancel: a.cancel, onEnd(h) {
        s.push(h);
      }, then(h) {
        return this.onEnd(h), this;
      } };
    }, loop(t, r) {
      let s = null, u = i(() => {
        s = this.wait(t, u), r();
      }, "newAction");
      return s = this.wait(0, u), { get paused() {
        return s.paused;
      }, set paused(a) {
        s.paused = a;
      }, cancel: () => s.cancel() };
    }, tween(t, r, s, u, a = Ct.linear) {
      let h = 0, f = [], b = this.onUpdate(() => {
        h += Me();
        let p = Math.min(h / s, 1);
        u(Ve(t, r, a(p))), p === 1 && (b.cancel(), u(r), f.forEach((d) => d()));
      });
      return { get paused() {
        return b.paused;
      }, set paused(p) {
        b.paused = p;
      }, onEnd(p) {
        f.push(p);
      }, then(p) {
        return this.onEnd(p), this;
      }, cancel() {
        b.cancel();
      }, finish() {
        b.cancel(), u(r), f.forEach((p) => p());
      } };
    } };
  }
  i(An, "timer");
  let Fs = 640, Is = 65536;
  function Ls(t = {}) {
    let r = null, s = null, u = false;
    return { id: "body", require: ["pos", "area"], vel: new v(0), jumpForce: t.jumpForce ?? Fs, gravityScale: t.gravityScale ?? 1, isStatic: t.isStatic ?? false, mass: t.mass ?? 1, add() {
      if (this.mass === 0) throw new Error("Can't set body mass to 0");
      this.onCollideUpdate((a, h) => {
        if (a.is("body") && !h.resolved && (this.trigger("beforePhysicsResolve", h), a.trigger("beforePhysicsResolve", h.reverse()), !h.resolved && !(this.isStatic && a.isStatic))) {
          if (!this.isStatic && !a.isStatic) {
            let f = this.mass + a.mass;
            this.pos = this.pos.add(h.displacement.scale(a.mass / f)), a.pos = a.pos.add(h.displacement.scale(-this.mass / f)), this.transform = jt(this), a.transform = jt(a);
          } else {
            let f = !this.isStatic && a.isStatic ? h : h.reverse();
            f.source.pos = f.source.pos.add(f.displacement), f.source.transform = jt(f.source);
          }
          h.resolved = true, this.trigger("physicsResolve", h), a.trigger("physicsResolve", h.reverse());
        }
      }), this.onPhysicsResolve((a) => {
        C.gravity && (a.isBottom() && this.isFalling() ? (this.vel.y = 0, r = a.target, s = a.target.pos, u ? u = false : this.trigger("ground", r)) : a.isTop() && this.isJumping() && (this.vel.y = 0, this.trigger("headbutt", a.target)));
      });
    }, update() {
      if (!C.gravity || this.isStatic) return;
      if (u && (r = null, s = null, this.trigger("fallOff"), u = false), r) if (!this.isColliding(r) || !r.exists() || !r.is("body")) u = true;
      else {
        !r.pos.eq(s) && t.stickToPlatform !== false && this.moveBy(r.pos.sub(s)), s = r.pos;
        return;
      }
      let a = this.vel.y;
      this.vel.y += C.gravity * this.gravityScale * Me(), this.vel.y = Math.min(this.vel.y, t.maxVelocity ?? Is), a < 0 && this.vel.y >= 0 && this.trigger("fall"), this.move(this.vel);
    }, onPhysicsResolve(a) {
      return this.on("physicsResolve", a);
    }, onBeforePhysicsResolve(a) {
      return this.on("beforePhysicsResolve", a);
    }, curPlatform() {
      return r;
    }, isGrounded() {
      return r !== null;
    }, isFalling() {
      return this.vel.y > 0;
    }, isJumping() {
      return this.vel.y < 0;
    }, jump(a) {
      r = null, s = null, this.vel.y = -a || -this.jumpForce;
    }, onGround(a) {
      return this.on("ground", a);
    }, onFall(a) {
      return this.on("fall", a);
    }, onFallOff(a) {
      return this.on("fallOff", a);
    }, onHeadbutt(a) {
      return this.on("headbutt", a);
    } };
  }
  i(Ls, "body");
  function Vs(t = 2) {
    let r = t;
    return { id: "doubleJump", require: ["body"], numJumps: t, add() {
      this.onGround(() => {
        r = this.numJumps;
      });
    }, doubleJump(s) {
      r <= 0 || (r < this.numJumps && this.trigger("doubleJump"), r--, this.jump(s));
    }, onDoubleJump(s) {
      return this.on("doubleJump", s);
    }, inspect() {
      return `${r}`;
    } };
  }
  i(Vs, "doubleJump");
  function _s2(t, r) {
    return { id: "shader", shader: t, ...typeof r == "function" ? { uniform: r(), update() {
      this.uniform = r();
    } } : { uniform: r } };
  }
  i(_s2, "shader");
  function ks() {
    return { id: "fixed", fixed: true };
  }
  i(ks, "fixed");
  function or(t) {
    return { id: "stay", stay: true, scenesToStay: t };
  }
  i(or, "stay");
  function Ns(t, r) {
    if (t == null) throw new Error("health() requires the initial amount of hp");
    return { id: "health", hurt(s = 1) {
      this.setHP(t - s), this.trigger("hurt", s);
    }, heal(s = 1) {
      let u = t;
      this.setHP(t + s), this.trigger("heal", t - u);
    }, hp() {
      return t;
    }, maxHP() {
      return r ?? null;
    }, setMaxHP(s) {
      r = s;
    }, setHP(s) {
      t = r ? Math.min(r, s) : s, t <= 0 && this.trigger("death");
    }, onHurt(s) {
      return this.on("hurt", s);
    }, onHeal(s) {
      return this.on("heal", s);
    }, onDeath(s) {
      return this.on("death", s);
    }, inspect() {
      return `${t}`;
    } };
  }
  i(Ns, "health");
  function js(t, r = {}) {
    if (t == null) throw new Error("lifespan() requires time");
    let s = r.fade ?? 0;
    return { id: "lifespan", async add() {
      await hr(t), s > 0 && this.opacity && await Rn(this.opacity, 0, s, (u) => this.opacity = u, Ct.linear), this.destroy();
    } };
  }
  i(js, "lifespan");
  function Hs(t, r, s) {
    if (!t) throw new Error("state() requires an initial state");
    let u = {};
    function a(p) {
      u[p] || (u[p] = { enter: new be(), end: new be(), update: new be(), draw: new be() });
    }
    i(a, "initStateEvents");
    function h(p, d, w) {
      return a(d), u[d][p].add(w);
    }
    i(h, "on");
    function f(p, d, ...w) {
      a(d), u[d][p].trigger(...w);
    }
    i(f, "trigger");
    let b = false;
    return { id: "state", state: t, enterState(p, ...d) {
      if (b = true, r && !r.includes(p)) throw new Error(`State not found: ${p}`);
      let w = this.state;
      if (s) {
        if (!s?.[w]) return;
        let A = typeof s[w] == "string" ? [s[w]] : s[w];
        if (!A.includes(p)) throw new Error(`Cannot transition state from "${w}" to "${p}". Available transitions: ${A.map((D) => `"${D}"`).join(", ")}`);
      }
      f("end", w, ...d), this.state = p, f("enter", p, ...d), f("enter", `${w} -> ${p}`, ...d);
    }, onStateTransition(p, d, w) {
      return h("enter", `${p} -> ${d}`, w);
    }, onStateEnter(p, d) {
      return h("enter", p, d);
    }, onStateUpdate(p, d) {
      return h("update", p, d);
    }, onStateDraw(p, d) {
      return h("draw", p, d);
    }, onStateEnd(p, d) {
      return h("end", p, d);
    }, update() {
      b || (f("enter", t), b = true), f("update", this.state);
    }, draw() {
      f("draw", this.state);
    }, inspect() {
      return this.state;
    } };
  }
  i(Hs, "state");
  function qs(t = 1) {
    let r = 0, s = false;
    return { require: ["opacity"], add() {
      this.opacity = 0;
    }, update() {
      s || (r += Me(), this.opacity = _e(r, 0, t, 0, 1), r >= t && (this.opacity = 1, s = true));
    } };
  }
  i(qs, "fadeIn");
  function $s(t = "intersect") {
    return { id: "mask", mask: t };
  }
  i($s, "mask");
  function zs(t) {
    return { add() {
      this.canvas = t;
    } };
  }
  i(zs, "drawon");
  function Tn(t) {
    k.loaded ? t() : C.events.on("load", t);
  }
  i(Tn, "onLoad");
  function Ks(t, r) {
    C.scenes[t] = r;
  }
  i(Ks, "scene");
  function Ys(t, ...r) {
    if (!C.scenes[t]) throw new Error(`Scene not found: ${t}`);
    C.events.onOnce("frameEnd", () => {
      C.events.trigger("sceneLeave", t), y.events.clear(), C.events.clear(), C.objEvents.clear(), [...C.root.children].forEach((s) => {
        (!s.stay || s.scenesToStay && !s.scenesToStay.includes(t)) && C.root.remove(s);
      }), C.root.clearEvents(), pr(), C.cam = { pos: null, scale: T(1), angle: 0, shake: 0, transform: new Ue() }, C.scenes[t](...r);
    });
  }
  i(Ys, "go");
  function Ws(t) {
    return C.events.on("sceneLeave", t);
  }
  i(Ws, "onSceneLeave");
  function Xs(t, r) {
    try {
      return JSON.parse(window.localStorage[t]);
    } catch {
      return r ? (ar(t, r), r) : null;
    }
  }
  i(Xs, "getData");
  function ar(t, r) {
    window.localStorage[t] = JSON.stringify(r);
  }
  i(ar, "setData");
  function ur(t, ...r) {
    let s = t(Ze), u;
    typeof s == "function" ? u = s(...r)(Ze) : u = s;
    for (let a in u) Ze[a] = u[a], n.global !== false && (window[a] = u[a]);
    return Ze;
  }
  i(ur, "plug");
  function zt() {
    return T(we() / 2, xe() / 2);
  }
  i(zt, "center");
  let Js;
  ((O) => (O[O.None = 0] = "None", O[O.Left = 1] = "Left", O[O.Top = 2] = "Top", O[O.LeftTop = 3] = "LeftTop", O[O.Right = 4] = "Right", O[O.Horizontal = 5] = "Horizontal", O[O.RightTop = 6] = "RightTop", O[O.HorizontalTop = 7] = "HorizontalTop", O[O.Bottom = 8] = "Bottom", O[O.LeftBottom = 9] = "LeftBottom", O[O.Vertical = 10] = "Vertical", O[O.LeftVertical = 11] = "LeftVertical", O[O.RightBottom = 12] = "RightBottom", O[O.HorizontalBottom = 13] = "HorizontalBottom", O[O.RightVertical = 14] = "RightVertical", O[O.All = 15] = "All"))(Js || (Js = {}));
  function cr(t = {}) {
    let r = T(0), s = t.isObstacle ?? false, u = t.cost ?? 0, a = t.edges ?? [], h = i(() => {
      let b = { left: 1, top: 2, right: 4, bottom: 8 };
      return a.map((p) => b[p] || 0).reduce((p, d) => p | d, 0);
    }, "getEdgeMask"), f = h();
    return { id: "tile", tilePosOffset: t.offset ?? T(0), set tilePos(b) {
      let p = this.getLevel();
      r = b.clone(), this.pos = T(this.tilePos.x * p.tileWidth(), this.tilePos.y * p.tileHeight()).add(this.tilePosOffset);
    }, get tilePos() {
      return r;
    }, set isObstacle(b) {
      s !== b && (s = b, this.getLevel().invalidateNavigationMap());
    }, get isObstacle() {
      return s;
    }, set cost(b) {
      u !== b && (u = b, this.getLevel().invalidateNavigationMap());
    }, get cost() {
      return u;
    }, set edges(b) {
      a = b, f = h(), this.getLevel().invalidateNavigationMap();
    }, get edges() {
      return a;
    }, get edgeMask() {
      return f;
    }, getLevel() {
      return this.parent;
    }, moveLeft() {
      this.tilePos = this.tilePos.add(T(-1, 0));
    }, moveRight() {
      this.tilePos = this.tilePos.add(T(1, 0));
    }, moveUp() {
      this.tilePos = this.tilePos.add(T(0, -1));
    }, moveDown() {
      this.tilePos = this.tilePos.add(T(0, 1));
    } };
  }
  i(cr, "tile");
  function Qs(t, r) {
    if (!r.tileWidth || !r.tileHeight) throw new Error("Must provide tileWidth and tileHeight.");
    let s = gt([qt(r.pos ?? T(0))]), u = t.length, a = 0, h = null, f = null, b = null, p = null, d = i((U) => U.x + U.y * a, "tile2Hash"), w = i((U) => T(Math.floor(U % a), Math.floor(U / a)), "hash2Tile"), A = i(() => {
      h = [];
      for (let U of s.children) D(U);
    }, "createSpatialMap"), D = i((U) => {
      let G = d(U.tilePos);
      h[G] ? h[G].push(U) : h[G] = [U];
    }, "insertIntoSpatialMap"), N = i((U) => {
      let G = d(U.tilePos);
      if (h[G]) {
        let B = h[G].indexOf(U);
        B >= 0 && h[G].splice(B, 1);
      }
    }, "removeFromSpatialMap"), _ = i(() => {
      let U = false;
      for (let G of s.children) {
        let B = s.pos2Tile(G.pos);
        (G.tilePos.x != B.x || G.tilePos.y != B.y) && (U = true, N(G), G.tilePos.x = B.x, G.tilePos.y = B.y, D(G));
      }
      U && s.trigger("spatial_map_changed");
    }, "updateSpatialMap"), M = i(() => {
      let U = s.getSpatialMap(), G = s.numRows() * s.numColumns();
      f ? f.length = G : f = new Array(G), f.fill(1, 0, G);
      for (let B = 0; B < U.length; B++) {
        let F = U[B];
        if (F) {
          let Y = 0;
          for (let ee of F) if (ee.isObstacle) {
            Y = 1 / 0;
            break;
          } else Y += ee.cost;
          f[B] = Y || 1;
        }
      }
    }, "createCostMap"), O = i(() => {
      let U = s.getSpatialMap(), G = s.numRows() * s.numColumns();
      b ? b.length = G : b = new Array(G), b.fill(15, 0, G);
      for (let B = 0; B < U.length; B++) {
        let F = U[B];
        if (F) {
          let Y = F.length, ee = 15;
          for (let ue = 0; ue < Y; ue++) ee |= F[ue].edgeMask;
          b[B] = ee;
        }
      }
    }, "createEdgeMap"), ie = i(() => {
      let U = s.numRows() * s.numColumns(), G = i((F, Y) => {
        let ee = [];
        for (ee.push(F); ee.length > 0; ) {
          let ue = ee.pop();
          V(ue).forEach((me) => {
            p[me] < 0 && (p[me] = Y, ee.push(me));
          });
        }
      }, "traverse");
      p ? p.length = U : p = new Array(U), p.fill(-1, 0, U);
      let B = 0;
      for (let F = 0; F < f.length; F++) {
        if (p[F] >= 0) {
          B++;
          continue;
        }
        G(F, B), B++;
      }
    }, "createConnectivityMap"), Z = i((U, G) => f[G], "getCost"), H = i((U, G) => {
      let B = w(U), F = w(G);
      return B.dist(F);
    }, "getHeuristic"), V = i((U, G) => {
      let B = [], F = Math.floor(U % a), Y = F > 0 && b[U] & 1 && f[U - 1] !== 1 / 0, ee = U >= a && b[U] & 2 && f[U - a] !== 1 / 0, ue = F < a - 1 && b[U] & 4 && f[U + 1] !== 1 / 0, me = U < a * u - a - 1 && b[U] & 8 && f[U + a] !== 1 / 0;
      return G ? (Y && (ee && B.push(U - a - 1), B.push(U - 1), me && B.push(U + a - 1)), ee && B.push(U - a), ue && (ee && B.push(U - a + 1), B.push(U + 1), me && B.push(U + a + 1)), me && B.push(U + a)) : (Y && B.push(U - 1), ee && B.push(U - a), ue && B.push(U + 1), me && B.push(U + a)), B;
    }, "getNeighbours"), fe = { id: "level", tileWidth() {
      return r.tileWidth;
    }, tileHeight() {
      return r.tileHeight;
    }, spawn(U, ...G) {
      let B = T(...G), F = (() => {
        if (typeof U == "string") {
          if (r.tiles[U]) {
            if (typeof r.tiles[U] != "function") throw new Error("Level symbol def must be a function returning a component list");
            return r.tiles[U](B);
          } else if (r.wildcardTile) return r.wildcardTile(U, B);
        } else {
          if (Array.isArray(U)) return U;
          throw new Error("Expected a symbol or a component list");
        }
      })();
      if (!F) return null;
      let Y = false, ee = false;
      for (let me of F) me.id === "tile" && (ee = true), me.id === "pos" && (Y = true);
      Y || F.push(qt()), ee || F.push(cr());
      let ue = s.add(F);
      return Y && (ue.tilePosOffset = ue.pos.clone()), ue.tilePos = B, h && (D(ue), this.trigger("spatial_map_changed"), this.trigger("navigation_map_invalid")), ue;
    }, numColumns() {
      return a;
    }, numRows() {
      return u;
    }, levelWidth() {
      return a * this.tileWidth();
    }, levelHeight() {
      return u * this.tileHeight();
    }, tile2Pos(...U) {
      return T(...U).scale(this.tileWidth(), this.tileHeight());
    }, pos2Tile(...U) {
      let G = T(...U);
      return T(Math.floor(G.x / this.tileWidth()), Math.floor(G.y / this.tileHeight()));
    }, getSpatialMap() {
      return h || A(), h;
    }, onSpatialMapChanged(U) {
      return this.on("spatial_map_changed", U);
    }, onNavigationMapInvalid(U) {
      return this.on("navigation_map_invalid", U);
    }, getAt(U) {
      h || A();
      let G = d(U);
      return h[G] || [];
    }, update() {
      h && _();
    }, invalidateNavigationMap() {
      f = null, b = null, p = null;
    }, onNavigationMapChanged(U) {
      return this.on("navigation_map_changed", U);
    }, getTilePath(U, G, B = {}) {
      if (f || M(), b || O(), p || ie(), U.x < 0 || U.x >= a || U.y < 0 || U.y >= u || G.x < 0 || G.x >= a || G.y < 0 || G.y >= u) return null;
      let F = d(U), Y = d(G);
      if (f[Y] === 1 / 0) return null;
      if (F === Y) return [];
      if (p[F] != -1 && p[F] !== p[Y]) return null;
      let ee = new Yt((Fe, Mn) => Fe.cost < Mn.cost);
      ee.insert({ cost: 0, node: F });
      let ue = /* @__PURE__ */ new Map();
      ue.set(F, F);
      let me = /* @__PURE__ */ new Map();
      for (me.set(F, 0); ee.length !== 0; ) {
        let Fe = ee.remove()?.node;
        if (Fe === Y) break;
        let Mn = V(Fe, B.allowDiagonals);
        for (let et of Mn) {
          let Gn = (me.get(Fe) || 0) + Z(Fe, et) + H(et, Y);
          (!me.has(et) || Gn < me.get(et)) && (me.set(et, Gn), ee.insert({ cost: Gn, node: et }), ue.set(et, Fe));
        }
      }
      let Dn = [], wt = Y, vi = w(wt);
      for (Dn.push(vi); wt !== F; ) {
        wt = ue.get(wt);
        let Fe = w(wt);
        Dn.push(Fe);
      }
      return Dn.reverse();
    }, getPath(U, G, B = {}) {
      let F = this.tileWidth(), Y = this.tileHeight(), ee = this.getTilePath(this.pos2Tile(U), this.pos2Tile(G), B);
      return ee ? [U, ...ee.slice(1, -1).map((ue) => ue.scale(F, Y).add(F / 2, Y / 2)), G] : null;
    } };
    return s.use(fe), s.onNavigationMapInvalid(() => {
      s.invalidateNavigationMap(), s.trigger("navigation_map_changed");
    }), t.forEach((U, G) => {
      let B = U.split("");
      a = Math.max(B.length, a), B.forEach((F, Y) => {
        s.spawn(F, T(Y, G));
      });
    }), s;
  }
  i(Qs, "addLevel");
  function Zs(t = {}) {
    let r = null, s = null, u = null, a = null;
    return { id: "agent", require: ["pos", "tile"], agentSpeed: t.speed ?? 100, allowDiagonals: t.allowDiagonals ?? true, getDistanceToTarget() {
      return r ? this.pos.dist(r) : 0;
    }, getNextLocation() {
      return s && u ? s[u] : null;
    }, getPath() {
      return s ? s.slice() : null;
    }, getTarget() {
      return r;
    }, isNavigationFinished() {
      return s ? u === null : true;
    }, isTargetReachable() {
      return s !== null;
    }, isTargetReached() {
      return r ? this.pos.eq(r) : true;
    }, setTarget(h) {
      r = h, s = this.getLevel().getPath(this.pos, r, { allowDiagonals: this.allowDiagonals }), u = s ? 0 : null, s ? (a || (a = this.getLevel().onNavigationMapChanged(() => {
        s && u !== null && (s = this.getLevel().getPath(this.pos, r, { allowDiagonals: this.allowDiagonals }), u = s ? 0 : null, s ? this.trigger("navigation-next", this, s[u]) : this.trigger("navigation-ended", this));
      }), this.onDestroy(() => a.cancel())), this.trigger("navigation-started", this), this.trigger("navigation-next", this, s[u])) : this.trigger("navigation-ended", this);
    }, update() {
      if (s && u !== null) {
        if (this.pos.sdist(s[u]) < 2) if (u === s.length - 1) {
          this.pos = r.clone(), u = null, this.trigger("navigation-ended", this), this.trigger("target-reached", this);
          return;
        } else u++, this.trigger("navigation-next", this, s[u]);
        this.moveTo(s[u], this.agentSpeed);
      }
    }, onNavigationStarted(h) {
      return this.on("navigation-started", h);
    }, onNavigationNext(h) {
      return this.on("navigation-next", h);
    }, onNavigationEnded(h) {
      return this.on("navigation-ended", h);
    }, onTargetReached(h) {
      return this.on("target-reached", h);
    }, inspect() {
      return JSON.stringify({ target: JSON.stringify(r), path: JSON.stringify(s) });
    } };
  }
  i(Zs, "agent");
  function ei(t) {
    let r = y.canvas.captureStream(t), s = te.ctx.createMediaStreamDestination();
    te.masterNode.connect(s);
    let u = new MediaRecorder(r), a = [];
    return u.ondataavailable = (h) => {
      h.data.size > 0 && a.push(h.data);
    }, u.onerror = () => {
      te.masterNode.disconnect(s), r.getTracks().forEach((h) => h.stop());
    }, u.start(), { resume() {
      u.resume();
    }, pause() {
      u.pause();
    }, stop() {
      return u.stop(), te.masterNode.disconnect(s), r.getTracks().forEach((h) => h.stop()), new Promise((h) => {
        u.onstop = () => {
          h(new Blob(a, { type: "video/mp4" }));
        };
      });
    }, download(h = "kaboom.mp4") {
      this.stop().then((f) => Nn(h, f));
    } };
  }
  i(ei, "record");
  function ti() {
    return document.activeElement === y.canvas;
  }
  i(ti, "isFocused");
  function ni(t) {
    t.destroy();
  }
  i(ni, "destroy");
  let gt = C.root.add.bind(C.root), ri = C.root.readd.bind(C.root), si = C.root.removeAll.bind(C.root), On = C.root.get.bind(C.root), hr = C.root.wait.bind(C.root), ii = C.root.loop.bind(C.root), Rn = C.root.tween.bind(C.root);
  function lr(t = 2, r = 1) {
    let s = 0;
    return { require: ["scale"], update() {
      let u = Math.sin(s * t) * r;
      u < 0 && this.destroy(), this.scale = T(u), s += Me();
    } };
  }
  i(lr, "boom");
  let oi = Ye(null, qr), ai = Ye(null, $r);
  function ui(t, r = {}) {
    let s = gt([qt(t), or()]), u = (r.speed || 1) * 5, a = r.scale || 1;
    s.add([Cn(ai), $t(0), Sn("center"), lr(u, a), ...r.comps ?? []]);
    let h = s.add([Cn(oi), $t(0), Sn("center"), An(), ...r.comps ?? []]);
    return h.wait(0.4 / u, () => h.use(lr(u, a))), h.onDestroy(() => s.destroy()), s;
  }
  i(ui, "addKaboom");
  function dr() {
    C.root.update();
  }
  i(dr, "updateFrame");
  const _Pn = class _Pn {
    constructor(r, s, u, a = false) {
      __publicField(this, "source");
      __publicField(this, "target");
      __publicField(this, "displacement");
      __publicField(this, "resolved", false);
      this.source = r, this.target = s, this.displacement = u, this.resolved = a;
    }
    reverse() {
      return new _Pn(this.target, this.source, this.displacement.scale(-1), this.resolved);
    }
    hasOverlap() {
      return !this.displacement.isZero();
    }
    isLeft() {
      return this.displacement.x > 0;
    }
    isRight() {
      return this.displacement.x < 0;
    }
    isTop() {
      return this.displacement.y > 0;
    }
    isBottom() {
      return this.displacement.y < 0;
    }
    preventResolution() {
      this.resolved = true;
    }
  };
  i(_Pn, "Collision");
  let Pn = _Pn;
  function ci() {
    let t = {}, r = n.hashGridSize || Hi, s = new Ue(), u = [];
    function a(h) {
      if (u.push(s.clone()), h.pos && s.translate(h.pos), h.scale && s.scale(h.scale), h.angle && s.rotate(h.angle), h.transform = s.clone(), h.c("area") && !h.paused) {
        let f = h, p = f.worldArea().bbox(), d = Math.floor(p.pos.x / r), w = Math.floor(p.pos.y / r), A = Math.ceil((p.pos.x + p.width) / r), D = Math.ceil((p.pos.y + p.height) / r), N = /* @__PURE__ */ new Set();
        for (let _ = d; _ <= A; _++) for (let M = w; M <= D; M++) if (!t[_]) t[_] = {}, t[_][M] = [f];
        else if (!t[_][M]) t[_][M] = [f];
        else {
          let O = t[_][M];
          e: for (let ie of O) {
            if (ie.paused || !ie.exists() || N.has(ie.id)) continue;
            for (let H of f.collisionIgnore) if (ie.is(H)) continue e;
            for (let H of ie.collisionIgnore) if (f.is(H)) continue e;
            let Z = Or(f.worldArea(), ie.worldArea());
            if (Z) {
              let H = new Pn(f, ie, Z);
              f.trigger("collideUpdate", ie, H);
              let V = H.reverse();
              V.resolved = H.resolved, ie.trigger("collideUpdate", f, V);
            }
            N.add(ie.id);
          }
          O.push(f);
        }
      }
      h.children.forEach(a), s = u.pop();
    }
    i(a, "checkObj"), a(C.root);
  }
  i(ci, "checkFrame");
  function hi() {
    let t = C.cam, r = v.fromAngle(xt(0, 360)).scale(t.shake);
    t.shake = Ve(t.shake, 0, 5 * Me()), t.transform = new Ue().translate(zt()).scale(t.scale).rotate(t.angle).translate((t.pos ?? zt()).scale(-1).add(r)), C.root.draw(), Pe();
  }
  i(hi, "drawFrame");
  function li() {
    let t = $();
    C.events.numListeners("loading") > 0 ? C.events.trigger("loading", t) : Ce(() => {
      let r = we() / 2, s = 24, u = T(we() / 2, xe() / 2).sub(T(r / 2, s / 2));
      ge({ pos: T(0), width: we(), height: xe(), color: J(0, 0, 0) }), ge({ pos: u, width: r, height: s, fill: false, outline: { width: 4 } }), ge({ pos: u, width: r * t, height: s });
    });
  }
  i(li, "drawLoadScreen");
  function fr(t, r) {
    Ce(() => {
      let s = T(8);
      le(), ne(t);
      let u = Xe({ text: r, font: nn, size: 16, pos: s, color: J(255, 255, 255), fixed: true }), a = u.width + s.x * 2, h = u.height + s.x * 2;
      t.x + a >= we() && ne(T(-a, 0)), t.y + h >= xe() && ne(T(0, -h)), ge({ width: a, height: h, color: J(0, 0, 0), radius: 4, opacity: 0.8, fixed: true }), Je(u), ae();
    });
  }
  i(fr, "drawInspectText");
  function di() {
    if (re.inspect) {
      let t = null;
      for (let r of C.root.get("*", { recursive: true })) if (r.c("area") && r.isHovering()) {
        t = r;
        break;
      }
      if (C.root.drawInspect(), t) {
        let r = [], s = t.inspect();
        for (let u in s) s[u] ? r.push(`${u}: ${s[u]}`) : r.push(`${u}`);
        fr(ns(Nt()), r.join(`
`));
      }
      fr(T(8), `FPS: ${re.fps()}`);
    }
    re.paused && Ce(() => {
      le(), ne(we(), 0), ne(-8, 8);
      let t = 32;
      ge({ width: t, height: t, anchor: "topright", color: J(0, 0, 0), opacity: 0.8, radius: 4, fixed: true });
      for (let r = 1; r <= 2; r++) ge({ width: 4, height: t * 0.6, anchor: "center", pos: T(-t / 3 * r, t * 0.5), color: J(255, 255, 255), radius: 2, fixed: true });
      ae();
    }), re.timeScale !== 1 && Ce(() => {
      le(), ne(we(), xe()), ne(-8, -8);
      let t = 8, r = Xe({ text: re.timeScale.toFixed(1), font: nn, size: 16, color: J(255, 255, 255), pos: T(-t), anchor: "botright", fixed: true });
      ge({ width: r.width + t * 2 + t * 4, height: r.height + t * 2, anchor: "botright", color: J(0, 0, 0), opacity: 0.8, radius: 4, fixed: true });
      for (let s = 0; s < 2; s++) {
        let u = re.timeScale < 1;
        R({ p1: T(-r.width - t * (u ? 2 : 3.5), -t), p2: T(-r.width - t * (u ? 2 : 3.5), -t - r.height), p3: T(-r.width - t * (u ? 3.5 : 2), -t - r.height / 2), pos: T(-s * t * 1 + (u ? -t * 0.5 : 0), 0), color: J(255, 255, 255), fixed: true });
      }
      Je(r), ae();
    }), re.curRecording && Ce(() => {
      le(), ne(0, xe()), ne(24, -24), L({ radius: 12, color: J(255, 0, 0), opacity: In(0, 1, y.time() * 4), fixed: true }), ae();
    }), re.showLog && C.logs.length > 0 && Ce(() => {
      le(), ne(0, xe()), ne(8, -8);
      let t = 8, r = [];
      for (let u of C.logs) {
        let a = "", h = u.msg instanceof Error ? "error" : "info";
        a += `[time]${u.time.toFixed(2)}[/time]`, a += " ", a += `[${h}]${u.msg?.toString ? u.msg.toString() : u.msg}[/${h}]`, r.push(a);
      }
      C.logs = C.logs.filter((u) => y.time() - u.time < (n.logTime || $i));
      let s = Xe({ text: r.join(`
`), font: nn, pos: T(t, -t), anchor: "botleft", size: 16, width: we() * 0.6, lineSpacing: t / 2, fixed: true, styles: { time: { color: J(127, 127, 127) }, info: { color: J(255, 255, 255) }, error: { color: J(255, 0, 127) } } });
      ge({ width: s.width + t * 2, height: s.height + t * 2, anchor: "botleft", color: J(0, 0, 0), radius: 4, opacity: 0.8, fixed: true }), Je(s), ae();
    });
  }
  i(di, "drawDebug");
  function fi(t) {
    C.events.on("loading", t);
  }
  i(fi, "onLoading");
  function mi(t) {
    y.onResize(t);
  }
  i(mi, "onResize");
  function pi(t) {
    C.events.on("error", t);
  }
  i(pi, "onError");
  function gi(t) {
    console.error(t), te.ctx.suspend(), y.run(() => {
      dt(), Ce(() => {
        let u = we(), a = xe(), h = { size: 36, width: u - 32 * 2, letterSpacing: 4, lineSpacing: 4, font: nn, fixed: true };
        ge({ width: u, height: a, color: J(0, 0, 255), fixed: true });
        let f = Xe({ ...h, text: "Error", pos: T(32), color: J(255, 128, 0), fixed: true });
        Je(f), tr({ ...h, text: t.message, pos: T(32, 32 + f.height + 16), fixed: true }), ae(), C.events.trigger("error", t);
      }), ft();
    });
  }
  i(gi, "handleErr");
  function wi(t) {
    X.push(t);
  }
  i(wi, "onCleanup");
  function bi() {
    C.events.onOnce("frameEnd", () => {
      y.quit(), S.clear(S.COLOR_BUFFER_BIT | S.DEPTH_BUFFER_BIT | S.STENCIL_BUFFER_BIT);
      let t = S.getParameter(S.MAX_TEXTURE_IMAGE_UNITS);
      for (let r = 0; r < t; r++) S.activeTexture(S.TEXTURE0 + r), S.bindTexture(S.TEXTURE_2D, null), S.bindTexture(S.TEXTURE_CUBE_MAP, null);
      S.bindBuffer(S.ARRAY_BUFFER, null), S.bindBuffer(S.ELEMENT_ARRAY_BUFFER, null), S.bindRenderbuffer(S.RENDERBUFFER, null), S.bindFramebuffer(S.FRAMEBUFFER, null), q.destroy(), X.forEach((r) => r());
    });
  }
  i(bi, "quit");
  let Kt = true;
  y.run(() => {
    try {
      k.loaded || $() === 1 && !Kt && (k.loaded = true, C.events.trigger("load")), !k.loaded && n.loadingScreen !== false || Kt ? (dt(), li(), ft()) : (re.paused || dr(), ci(), dt(), hi(), n.debug !== false && di(), ft()), Kt && (Kt = false), C.events.trigger("frameEnd");
    } catch (t) {
      gi(t);
    }
  });
  function mr() {
    let t = P, r = S.drawingBufferWidth / t, s = S.drawingBufferHeight / t;
    if (n.letterbox) {
      if (!n.width || !n.height) throw new Error("Letterboxing requires width and height defined.");
      let u = r / s, a = n.width / n.height;
      if (u > a) {
        let h = s * a, f = (r - h) / 2;
        E.viewport = { x: f, y: 0, width: h, height: s };
      } else {
        let h = r / a, f = (s - h) / 2;
        E.viewport = { x: 0, y: f, width: r, height: h };
      }
      return;
    }
    if (n.stretch && (!n.width || !n.height)) throw new Error("Stretching requires width and height defined.");
    E.viewport = { x: 0, y: 0, width: r, height: s };
  }
  i(mr, "updateViewport");
  function pr() {
    y.onHide(() => {
      n.backgroundAudio || te.ctx.suspend();
    }), y.onShow(() => {
      !n.backgroundAudio && !re.paused && te.ctx.resume();
    }), y.onResize(() => {
      if (y.isFullscreen()) return;
      let t = n.width && n.height;
      t && !n.stretch && !n.letterbox || (o.width = o.offsetWidth * P, o.height = o.offsetHeight * P, mr(), t || (E.frameBuffer.free(), E.frameBuffer = new rt(q, S.drawingBufferWidth, S.drawingBufferHeight), E.width = S.drawingBufferWidth / P, E.height = S.drawingBufferHeight / P));
    }), n.debug !== false && (y.onKeyPress("f1", () => re.inspect = !re.inspect), y.onKeyPress("f2", () => re.clearLog()), y.onKeyPress("f8", () => re.paused = !re.paused), y.onKeyPress("f7", () => {
      re.timeScale = mt(Le(re.timeScale - 0.2, 0, 2), 1);
    }), y.onKeyPress("f9", () => {
      re.timeScale = mt(Le(re.timeScale + 0.2, 0, 2), 1);
    }), y.onKeyPress("f10", () => re.stepFrame())), n.burp && y.onKeyPress("b", () => Lt());
  }
  i(pr, "initEvents"), mr(), pr();
  let Ze = { VERSION: ki, loadRoot: Te, loadProgress: $, loadSprite: Ye, loadSpriteAtlas: Ot, loadSound: ln, loadBitmapFont: on, loadFont: st, loadShader: cn, loadShaderURL: hn, loadAseprite: un, loadPedit: an, loadBean: dn, loadJSON: ye, load: Ae, getSprite: Pt, getSound: Dt, getFont: Mt, getBitmapFont: Gt, getShader: Bt, getAsset: fn, Asset: ve, SpriteData: K, SoundData: Q, width: we, height: xe, center: zt, dt: Me, time: y.time, screenshot: y.screenshot, record: ei, isFocused: ti, setCursor: y.setCursor, getCursor: y.getCursor, setCursorLocked: y.setCursorLocked, isCursorLocked: y.isCursorLocked, setFullscreen: y.setFullscreen, isFullscreen: y.isFullscreen, isTouchscreen: y.isTouchscreen, onLoad: Tn, onLoading: fi, onResize: mi, onGamepadConnect: y.onGamepadConnect, onGamepadDisconnect: y.onGamepadDisconnect, onError: pi, onCleanup: wi, camPos: rs, camScale: ss, camRot: is, shake: os, toScreen: rr, toWorld: sr, setGravity: gs, getGravity: ws, setBackground: bs, getBackground: vs, getGamepads: y.getGamepads, add: gt, make: Un, destroy: ni, destroyAll: si, get: On, readd: ri, pos: qt, scale: $t, rotate: ys, color: xs, opacity: Us, anchor: Sn, area: Os, sprite: Cn, text: Rs, polygon: Ps, rect: Ds, circle: Gs, uvquad: Ms, outline: Bs, body: Ls, doubleJump: Vs, shader: _s2, timer: An, fixed: ks, stay: or, health: Ns, lifespan: js, z: Es, move: Cs, offscreen: Ts, follow: Ss, state: Hs, fadeIn: qs, mask: $s, drawon: zs, tile: cr, agent: Zs, on: ze, onUpdate: as, onDraw: us, onAdd: En, onDestroy: ir, onClick: ds, onCollide: cs, onCollideUpdate: hs, onCollideEnd: ls, onHover: fs, onHoverUpdate: ms, onHoverEnd: ps, onKeyDown: y.onKeyDown, onKeyPress: y.onKeyPress, onKeyPressRepeat: y.onKeyPressRepeat, onKeyRelease: y.onKeyRelease, onMouseDown: y.onMouseDown, onMousePress: y.onMousePress, onMouseRelease: y.onMouseRelease, onMouseMove: y.onMouseMove, onCharInput: y.onCharInput, onTouchStart: y.onTouchStart, onTouchMove: y.onTouchMove, onTouchEnd: y.onTouchEnd, onScroll: y.onScroll, onHide: y.onHide, onShow: y.onShow, onGamepadButtonDown: y.onGamepadButtonDown, onGamepadButtonPress: y.onGamepadButtonPress, onGamepadButtonRelease: y.onGamepadButtonRelease, onGamepadStick: y.onGamepadStick, mousePos: Nt, mouseDeltaPos: y.mouseDeltaPos, isKeyDown: y.isKeyDown, isKeyPressed: y.isKeyPressed, isKeyPressedRepeat: y.isKeyPressedRepeat, isKeyReleased: y.isKeyReleased, isMouseDown: y.isMouseDown, isMousePressed: y.isMousePressed, isMouseReleased: y.isMouseReleased, isMouseMoved: y.isMouseMoved, isGamepadButtonPressed: y.isGamepadButtonPressed, isGamepadButtonDown: y.isGamepadButtonDown, isGamepadButtonReleased: y.isGamepadButtonReleased, getGamepadStick: y.getGamepadStick, charInputted: y.charInputted, loop: ii, wait: hr, play: It, volume: gn, burp: Lt, audioCtx: te.ctx, Line: Ie, Rect: de, Circle: yt, Polygon: Ke, Vec2: v, Color: W, Mat4: Ue, Quad: oe, RNG: bt, rand: xt, randi: Ln, randSeed: yr, vec2: T, rgb: J, hsl2rgb: vr, quad: ce, choose: Ur, chance: xr, lerp: Ve, tween: Rn, easings: Ct, map: _e, mapc: br, wave: In, deg2rad: Ge, rad2deg: ot, clamp: Le, testLineLine: it, testRectRect: Er, testRectLine: Sr, testRectPoint: vt, testCirclePolygon: Tr, testLinePoint: Cr, testLineCircle: Vn, drawSprite: yn, drawText: tr, formatText: Xe, drawRect: ge, drawLine: l, drawLines: x, drawTriangle: R, drawCircle: L, drawEllipse: he, drawUVQuad: Be, drawPolygon: z, drawFormattedText: Je, drawMasked: $e, drawSubtracted: kt, pushTransform: le, popTransform: ae, pushTranslate: ne, pushScale: He, pushRotate: se, pushMatrix: _t2, usePostEffect: Vt, makeCanvas: wn, debug: re, scene: Ks, go: Ys, onSceneLeave: Ws, addLevel: Qs, getData: Xs, setData: ar, download: Xt, downloadJSON: Dr, downloadText: kn, downloadBlob: Nn, plug: ur, ASCII_CHARS: zr, canvas: y.canvas, addKaboom: ui, LEFT: v.LEFT, RIGHT: v.RIGHT, UP: v.UP, DOWN: v.DOWN, RED: W.RED, GREEN: W.GREEN, BLUE: W.BLUE, YELLOW: W.YELLOW, MAGENTA: W.MAGENTA, CYAN: W.CYAN, WHITE: W.WHITE, BLACK: W.BLACK, quit: bi, Event: be, EventHandler: Ne, EventController: ke };
  if (n.plugins && n.plugins.forEach(ur), n.global !== false) for (let t in Ze) window[t] = Ze[t];
  return n.focus !== false && y.canvas.focus(), Ze;
}, "default");
const GAME_CONFIG = {
  internalWidth: 540,
  internalHeight: 960,
  physicsTimestepMs: 16.6667,
  maxDtSeconds: 0.05,
  inputLockMs: 120,
  uiScale: 1.25,
  timeBar: {
    maxSeconds: 6.5,
    refillOnStepSeconds: 0.3
  },
  wall: {
    width: 200,
    segmentHeight: 40
  },
  obstacles: {
    maxSameSideInRow: 2,
    dualHoldChance: 0.18
  },
  difficulty: {
    rampSlope: 45e-4,
    rampMax: 0.7,
    maxDrainMultiplier: 1.35
  }
};
const HOLD_Y_OFFSET_PX = -50;
const BUTTON_SCALE = 1.35;
const UI_MARGIN = 12;
const HOLD_SIZE_SCALE = 2;
function initKaboom() {
  const k = zo({
    width: GAME_CONFIG.internalWidth,
    height: GAME_CONFIG.internalHeight,
    background: [196, 244, 248],
    global: false,
    touchToMouse: true,
    debug: false,
    stretch: true,
    letterbox: true,
    crisp: true,
    pixelDensity: Math.max(1, Math.floor(window.devicePixelRatio || 1)),
    root: document.querySelector("#app")
  });
  return { k };
}
const THEME_KEY = "climbtap_theme";
function loadTheme() {
  try {
    const v2 = localStorage.getItem(THEME_KEY);
    if (v2 === "day" || v2 === "night") return v2;
  } catch {
  }
  return "day";
}
function saveTheme(t) {
  try {
    localStorage.setItem(THEME_KEY, t);
  } catch {
  }
  window.__theme = t;
}
function loadBest() {
  try {
    const v2 = localStorage.getItem("climbtap_best");
    const n = v2 ? Number(v2) : 0;
    return Number.isFinite(n) ? n : 0;
  } catch {
    return 0;
  }
}
function saveBest(best) {
  try {
    localStorage.setItem("climbtap_best", String(best));
  } catch {
  }
}
function showMobileControls() {
  const el = document.getElementById("mobile-controls");
  if (!el) return;
  el.style.display = "grid";
  el.style.zIndex = "9999";
}
function hideMobileControls() {
  const el = document.getElementById("mobile-controls");
  if (!el) return;
  el.style.display = "none";
}
function setupInput(k, cbs) {
  const onLeft = () => cbs.onMove("left");
  const onRight = () => cbs.onMove("right");
  const onStart = () => cbs.onStart();
  const ctrls = [];
  ctrls.push(k.onKeyPress("a", () => {
    onLeft();
  }));
  ctrls.push(k.onKeyPress("left", () => {
    onLeft();
  }));
  ctrls.push(k.onKeyPress("d", () => {
    onRight();
  }));
  ctrls.push(k.onKeyPress("right", () => {
    onRight();
  }));
  ctrls.push(k.onKeyPress("space", onStart));
  ctrls.push(k.onKeyPress("enter", onStart));
  const btnLeft = document.getElementById("btn-left");
  const btnRight = document.getElementById("btn-right");
  const add = (el, fn) => {
    if (!el) return () => {
    };
    const handler = (e) => {
      e.preventDefault();
      fn();
    };
    el.addEventListener("pointerdown", handler);
    return () => el.removeEventListener("pointerdown", handler);
  };
  const domUnsubLeft = add(btnLeft, onLeft);
  const domUnsubRight = add(btnRight, onRight);
  return () => {
    ctrls.forEach((c) => c.cancel());
    domUnsubLeft();
    domUnsubRight();
  };
}
function createHud(k) {
  const padding = 10;
  const scoreSize = Math.round(72 * GAME_CONFIG.uiScale * 1.1 * 0.85);
  const scoreX = Math.floor(k.width() / 2);
  const scoreY = 12;
  const scoreOutlineOffsets = [
    [-2, 0],
    [2, 0],
    [0, -2],
    [0, 2],
    [-1, -1],
    [1, -1],
    [-1, 1],
    [1, 1]
  ];
  const betasprayBlue = k.rgb(28, 120, 200);
  for (const [ox, oy] of scoreOutlineOffsets) {
    k.add([k.text("0", { size: scoreSize, font: "sink", letterSpacing: 1 }), k.pos(scoreX + ox, scoreY + oy), k.anchor("top"), k.z(4001), k.color(255, 255, 255), { _scoreOutline: true }]);
  }
  const scoreText = k.add([k.text("0", { size: scoreSize, font: "sink", letterSpacing: 1 }), k.pos(scoreX, scoreY), k.anchor("top"), k.z(4002), k.color(betasprayBlue)]);
  const fullWidth = k.width() - padding * 2;
  const barWidth = Math.floor(fullWidth * 0.85 * 0.7);
  const barHeight = Math.floor(10 * 1.5 * 1.25);
  const bgX = Math.floor((k.width() - barWidth) / 2);
  const BAR_Y_OFFSET = 20 + 25;
  const yBase = padding + 52 + BAR_Y_OFFSET;
  k.add([k.rect(barWidth, barHeight), k.pos(bgX, yBase), k.color(255, 255, 255), k.opacity(0.12), k.z(4e3)]);
  const glow = k.add([k.pos(bgX + barWidth / 2, yBase + barHeight / 2), k.anchor("center"), k.z(4000.5)]);
  const glowRect = glow.add([k.rect(barWidth, barHeight, { radius: 3 }), k.anchor("center"), k.color(80, 200, 120), k.opacity(0.14)]);
  const timeBar = k.add([k.rect(barWidth, barHeight), k.pos(bgX, yBase), k.color(80, 200, 120), k.z(4001), { fullWidth: barWidth }]);
  let timeFrac = 1;
  function setTime(t) {
    const frac = Math.max(0, Math.min(1, t / GAME_CONFIG.timeBar.maxSeconds));
    timeFrac = frac;
    timeBar.width = timeBar.fullWidth * frac;
    const green = [80, 200, 120];
    const yellow = [240, 210, 72];
    const red = [230, 70, 70];
    const lerp = (a, b, t2) => Math.round(a + (b - a) * t2);
    const mix = (c1, c2, t2) => k.rgb(
      lerp(c1[0], c2[0], t2),
      lerp(c1[1], c2[1], t2),
      lerp(c1[2], c2[2], t2)
    );
    let col;
    if (frac >= 0.66) {
      const t2 = (frac - 0.66) / (1 - 0.66);
      col = mix(yellow, green, t2);
    } else if (frac >= 0.33) {
      const t2 = (frac - 0.33) / (0.66 - 0.33);
      col = mix(red, yellow, t2);
    } else {
      col = k.rgb(red[0], red[1], red[2]);
    }
    timeBar.color = col;
    glowRect.color = col;
  }
  function setScore(score) {
    const outlines = k.get("text").filter((t) => t._scoreOutline);
    for (const o of outlines) {
      o.text = String(score);
    }
    if (scoreText) scoreText.text = `${score}`;
  }
  k.onUpdate(() => {
    const minW = Math.max(4, timeBar.width);
    const freq = 1.5 + (1 - timeFrac) * 3;
    const amp = 0.1 + (1 - timeFrac) * 0.1;
    const s = 1 + Math.sin(k.time() * Math.PI * 2 * freq) * amp;
    glow.pos = k.vec2(timeBar.pos.x + minW / 2, yBase + barHeight / 2);
    glowRect.width = Math.max(minW, timeBar.width ?? 0) * 1.04;
    glowRect.height = barHeight * 1.3;
    glowRect.scale = s;
    glowRect.opacity = 0.1 + (1 - timeFrac) * 0.16;
  });
  return { setScore, setTime };
}
function spawnClimber(k, wallCenterX, baseY, modelScale = 1, opts = {}) {
  const s = modelScale;
  const laneOffset = GAME_CONFIG.wall.width * 0.25;
  const leftX = wallCenterX - laneOffset;
  const rightX = wallCenterX + laneOffset;
  const root = k.add([k.pos(leftX, baseY), k.anchor("center"), k.z(10)]);
  const shirtColor = k.rgb(28, 120, 200), shirtDark = k.rgb(20, 92, 160), skin = k.rgb(250, 215, 170), hairColor = k.rgb(60, 40, 30), pants = k.rgb(170, 120, 40), shoe = k.rgb(22, 26, 30), harnessRed = k.rgb(180, 50, 40), beltColor = k.rgb(200, 80, 40), ropeColor = k.rgb(230, 110, 40);
  const bodyW = 24 * s, bodyH = 30 * s;
  const body = k.add([k.rect(bodyW, bodyH, { radius: 2 * s }), k.pos(0, 0), k.color(shirtColor), k.anchor("center"), k.z(11), k.rotate(0)]);
  const neck = k.add([k.rect(8 * s, 8 * s, { radius: 1 * s }), k.pos(0, -(bodyH / 2 + 3.5 * s)), k.anchor("center"), k.color(skin), k.z(12), k.rotate(0)]);
  const headRadius = 8 * s;
  const head = k.add([k.rect(14 * s, 14 * s, { radius: 1 * s }), k.pos(0, -(bodyH / 2 + 14 * s)), k.anchor("center"), k.color(skin), k.z(13), k.rotate(0)]);
  const hairBack = k.add([k.rect(24 * s, 20 * s, { radius: 6 * s }), k.pos(0, -(bodyH / 2 + 16 * s) + 1 * s), k.anchor("center"), k.color(hairColor), k.z(11.5), k.rotate(0)]);
  const hair = k.add([k.rect(20 * s, 14 * s, { radius: 4 * s }), k.pos(-2 * s, -(bodyH / 2 + 17 * s)), k.anchor("center"), k.color(hairColor), k.z(12.2), k.rotate(0)]);
  const belt = k.add([k.rect(bodyW, 5 * s, { radius: 1 * s }), k.pos(0, bodyH / 2 - 7 * s), k.anchor("center"), k.color(beltColor), k.z(12), k.rotate(0)]);
  const harnessL = k.add([k.rect(10 * s, 8 * s, { radius: 2 * s }), k.pos(-6 * s, bodyH / 2 - 2 * s), k.anchor("center"), k.color(harnessRed), k.opacity(0), k.z(12), k.rotate(0)]);
  const harnessR = k.add([k.rect(10 * s, 8 * s, { radius: 2 * s }), k.pos(6 * s, bodyH / 2 - 2 * s), k.anchor("center"), k.color(harnessRed), k.opacity(0), k.z(12), k.rotate(0)]);
  const loopCol = k.rgb(150, 50, 40);
  const legLoopWidth = 12 * s;
  const legLoopHeight = 3 * s;
  const legLoopLeft = k.add([k.rect(legLoopWidth, legLoopHeight, { radius: 1.5 * s }), k.pos(-7 * s, bodyH / 2 + 4 * s), k.anchor("center"), k.color(loopCol), k.z(11)]);
  const legLoopRight = k.add([k.rect(legLoopWidth, legLoopHeight, { radius: 1.5 * s }), k.pos(7 * s, bodyH / 2 + 4 * s), k.anchor("center"), k.color(loopCol), k.z(11)]);
  const legLeft = k.add([k.rect(10 * s, 28 * s, { radius: 1 * s }), k.pos(-7 * s, bodyH / 2), k.anchor("top"), k.color(pants), k.z(10), k.rotate(0)]);
  const legRight = k.add([k.rect(10 * s, 28 * s, { radius: 1 * s }), k.pos(7 * s, bodyH / 2), k.anchor("top"), k.color(pants), k.z(10), k.rotate(0)]);
  const footLeft = k.add([k.rect(10 * s, 6 * s, { radius: 1 * s }), k.pos(-7 * s, bodyH / 2 + 28 * s), k.anchor("top"), k.color(shoe), k.z(10), k.rotate(0)]);
  const footRight = k.add([k.rect(10 * s, 6 * s, { radius: 1 * s }), k.pos(7 * s, bodyH / 2 + 28 * s), k.anchor("top"), k.color(shoe), k.z(10), k.rotate(0)]);
  const armLeft = k.add([k.rect(6 * s, 28 * s, { radius: 1 * s }), k.pos(-12 * s, -(bodyH / 2)), k.anchor("bot"), k.color(skin), k.z(12), k.rotate(0)]);
  const armRight = k.add([k.rect(6 * s, 28 * s, { radius: 1 * s }), k.pos(12 * s, -(bodyH / 2)), k.anchor("bot"), k.color(skin), k.z(12), k.rotate(0)]);
  const sleeveW = 10 * s;
  const sleeveH = 12 * s;
  armLeft.add([k.rect(sleeveW, sleeveH, { radius: 2 * s }), k.pos(0, 0), k.anchor("bot"), k.color(shirtColor), k.z(12.2)]);
  armRight.add([k.rect(sleeveW, sleeveH, { radius: 2 * s }), k.pos(0, 0), k.anchor("bot"), k.color(shirtColor), k.z(12.2)]);
  const rope = k.add([k.rect(2 * s, Math.max(80 * s, k.height() * 2)), k.pos(0, -36 * s), k.anchor("top"), k.color(ropeColor), k.z(9), k.rotate(0)]);
  if (opts.showRope === false) {
    rope.hidden = true;
  }
  const showPouch = opts.showPouch === true;
  const pouchRoot = showPouch ? k.add([k.pos(0, 0), k.anchor("center"), k.z(12.05)]) : null;
  if (pouchRoot) {
    pouchRoot.add([k.rect(10 * s, 12 * s, { radius: 4 * s }), k.pos(0, 0), k.anchor("center"), k.color(60, 60, 70), k.opacity(0.95)]);
    pouchRoot.add([k.rect(10 * s, 3 * s, { radius: 2 * s }), k.pos(0, -6.5 * s), k.anchor("center"), k.color(200, 200, 210), k.opacity(0.25)]);
    pouchRoot.add([k.rect(2 * s, 8 * s, { radius: 1 * s }), k.pos(-3 * s, -11 * s), k.anchor("bot"), k.color(90, 90, 100), k.opacity(0.9), k.rotate(-10)]);
  }
  const shirtLight = k.rgb(40, 150, 220);
  const skinShadow = k.rgb(235, 200, 158);
  const pantsDark = k.rgb(140, 100, 32);
  body.add([k.rect(10 * s, 6 * s, { radius: 2 * s }), k.pos(-6 * s, -10 * s), k.anchor("center"), k.color(shirtLight), k.opacity(0.25), k.z(11.1), k.rotate(-8)]);
  body.add([k.rect(10 * s, 6 * s, { radius: 2 * s }), k.pos(6 * s, -10 * s), k.anchor("center"), k.color(shirtLight), k.opacity(0.25), k.z(11.1), k.rotate(8)]);
  body.add([k.rect(8 * s, 4 * s, { radius: 1 * s }), k.pos(0, 0), k.anchor("center"), k.color(shirtDark), k.opacity(0.18), k.z(11.1)]);
  body.add([k.rect(8 * s, 4 * s, { radius: 1 * s }), k.pos(0, 6 * s), k.anchor("center"), k.color(shirtDark), k.opacity(0.18), k.z(11.1)]);
  body.add([k.rect(8 * s, 4 * s, { radius: 1 * s }), k.pos(0, 12 * s), k.anchor("center"), k.color(shirtDark), k.opacity(0.18), k.z(11.1)]);
  body.add([k.rect(6 * s, 10 * s, { radius: 2 * s }), k.pos(-10 * s, 4 * s), k.anchor("center"), k.color(shirtDark), k.opacity(0.12), k.z(11.05), k.rotate(18)]);
  body.add([k.rect(6 * s, 10 * s, { radius: 2 * s }), k.pos(10 * s, 4 * s), k.anchor("center"), k.color(shirtDark), k.opacity(0.12), k.z(11.05), k.rotate(-18)]);
  neck.add([k.rect(8 * s, 3 * s, { radius: 1 * s }), k.pos(0, 1 * s), k.anchor("top"), k.color(skinShadow), k.opacity(0.25), k.z(12.1)]);
  armLeft.add([k.rect(7 * s, 10 * s, { radius: 3 * s }), k.pos(0, -16 * s), k.anchor("center"), k.color(skinShadow), k.opacity(0.22), k.z(12.1)]);
  armLeft.add([k.rect(6 * s, 9 * s, { radius: 2 * s }), k.pos(0, -6 * s), k.anchor("center"), k.color(skinShadow), k.opacity(0.18), k.z(12.1)]);
  armRight.add([k.rect(7 * s, 10 * s, { radius: 3 * s }), k.pos(0, -16 * s), k.anchor("center"), k.color(skinShadow), k.opacity(0.22), k.z(12.1)]);
  armRight.add([k.rect(6 * s, 9 * s, { radius: 2 * s }), k.pos(0, -6 * s), k.anchor("center"), k.color(skinShadow), k.opacity(0.18), k.z(12.1)]);
  legLeft.add([k.rect(10 * s, 16 * s, { radius: 2 * s }), k.pos(0, 8 * s), k.anchor("top"), k.color(pantsDark), k.opacity(0.18), k.z(10.1)]);
  legRight.add([k.rect(10 * s, 16 * s, { radius: 2 * s }), k.pos(0, 8 * s), k.anchor("top"), k.color(pantsDark), k.opacity(0.18), k.z(10.1)]);
  legLeft.add([k.rect(8 * s, 10 * s, { radius: 2 * s }), k.pos(0, 18 * s), k.anchor("top"), k.color(pantsDark), k.opacity(0.12), k.z(10.1)]);
  legRight.add([k.rect(8 * s, 10 * s, { radius: 2 * s }), k.pos(0, 18 * s), k.anchor("top"), k.color(pantsDark), k.opacity(0.12), k.z(10.1)]);
  legLeft.add([k.circle(2.5 * s), k.pos(0, 16 * s), k.anchor("center"), k.color(220, 220, 220), k.opacity(0.15), k.z(10.2)]);
  legRight.add([k.circle(2.5 * s), k.pos(0, 16 * s), k.anchor("center"), k.color(220, 220, 220), k.opacity(0.15), k.z(10.2)]);
  footLeft.add([k.rect(9 * s, 2 * s, { radius: 1 * s }), k.pos(0, 2 * s), k.anchor("top"), k.color(255, 255, 255), k.opacity(0.1), k.z(10.1)]);
  footRight.add([k.rect(9 * s, 2 * s, { radius: 1 * s }), k.pos(0, 2 * s), k.anchor("top"), k.color(255, 255, 255), k.opacity(0.1), k.z(10.1)]);
  const c = {
    root,
    body,
    head,
    hair,
    hairBack,
    neck,
    belt,
    harness: harnessL,
    legLoopLeft,
    legLoopRight,
    legLeft,
    legRight,
    footLeft,
    footRight,
    armLeft,
    armRight,
    rope,
    side: "left",
    jitterTime: 0,
    leftX,
    rightX,
    baseY,
    armReachLeft: 0,
    armReachRight: 0,
    headRadius,
    scale: s,
    facingWall: false
  };
  k.onUpdate(() => {
    const t = k.time();
    const sway = Math.sin(t * 2) * 1.3;
    body.angle = body.angle ?? 0;
    rope.angle = rope.angle ?? 0;
    body.angle = sway;
    rope.angle = sway * 0.6;
    const breathe = Math.sin(Math.PI * t);
    const breathOffset = breathe * 2;
    const headTilt = Math.sin(t * 2.6) * 3;
    const headSwayX = Math.sin(t * 1.8) * 1.2;
    c.jitterTime += k.dt();
    const j = Math.sin(c.jitterTime * 18) * 0.8;
    const rp = c.root.pos;
    body.pos = k.vec2(rp.x, rp.y + breathOffset);
    neck.pos = k.vec2(rp.x, rp.y + breathOffset - (bodyH / 2 + 3.5 * s));
    head.pos = k.vec2(rp.x + headSwayX, rp.y + breathOffset - (bodyH / 2 + 14 * s));
    head.angle = headTilt;
    hair.pos = k.vec2(rp.x - 2 * s + headSwayX * 0.6, rp.y + breathOffset - (bodyH / 2 + 17 * s));
    hair.angle = headTilt * 0.9;
    hairBack.pos = k.vec2(rp.x - 1 * s + headSwayX * 0.4, rp.y + breathOffset - (bodyH / 2 + 16 * s) + 1 * s);
    hairBack.angle = headTilt * 0.6;
    if (c.facingWall) {
      hairBack.z = 13.6;
      hair.z = 11.6;
    } else {
      hairBack.z = 11.5;
      hair.z = 12.2;
    }
    belt.pos = k.vec2(rp.x, rp.y + breathOffset + bodyH / 2 - 7 * s);
    harnessL.pos = k.vec2(rp.x - 6 * s, rp.y + breathOffset + bodyH / 2 - 2 * s);
    harnessR.pos = k.vec2(rp.x + 6 * s, rp.y + breathOffset + bodyH / 2 - 2 * s);
    legLeft.pos = k.vec2(rp.x - 7 * s, rp.y + bodyH / 2);
    legRight.pos = k.vec2(rp.x + 7 * s, rp.y + bodyH / 2);
    const legTopY = rp.y + bodyH / 2;
    const kneeY = legTopY + 16 * s;
    const hipY = legTopY - 2 * s;
    const kneeToHipT = 4 / 7;
    const loopY = kneeY + kneeToHipT * (hipY - kneeY);
    legLoopLeft.pos = k.vec2(rp.x - 7 * s, loopY);
    legLoopRight.pos = k.vec2(rp.x + 7 * s, loopY);
    footLeft.pos = k.vec2(rp.x - 7 * s, rp.y + bodyH / 2 + 28 * s);
    footRight.pos = k.vec2(rp.x + 7 * s, rp.y + bodyH / 2 + 28 * s);
    rope.pos = k.vec2(rp.x, rp.y + breathOffset * 0.5 - 36 * s);
    rope.height = Math.max(rope.height ?? 0, k.height() * 2);
    if (pouchRoot) {
      const hipX = rp.x + 10 * s;
      const hipY2 = rp.y + breathOffset + bodyH / 2 - 4 * s;
      pouchRoot.pos = k.vec2(hipX, hipY2);
      pouchRoot.angle = -(sway * 0.5);
    }
    const leftJit = c.side === "left" ? j : 0;
    const rightJit = c.side === "right" ? j : 0;
    const armsBaseY = rp.y + breathOffset - bodyH / 2 - 2;
    const shoulderSpread = c.facingWall ? 14 * s : 12 * s;
    c.armLeft.pos = k.vec2(rp.x - shoulderSpread + leftJit, armsBaseY - c.armReachLeft);
    c.armRight.pos = k.vec2(rp.x + shoulderSpread + rightJit, armsBaseY - c.armReachRight);
  });
  return c;
}
function reachToSide(k, climber, side) {
  const targetX = side === "left" ? climber.leftX : climber.rightX;
  climber.side = side;
  const duration = GAME_CONFIG.inputLockMs / 1e3;
  k.tween(climber.root.pos.x, targetX, duration, (v2) => climber.root.pos.x = v2, k.easings.easeOutCubic);
  const reachDur = duration * 0.5;
  const pullDur = duration * 0.5;
  const pullHeight = 8;
  if (side === "left") {
    const fromA = climber.armLeft.angle ?? 0;
    const reachTw = k.tween(fromA, -60, reachDur * 0.8, (v2) => climber.armLeft.angle = v2, k.easings.easeOutCubic);
    reachTw.then?.(() => {
      k.tween(climber.armLeft.angle, 0, pullDur * 0.8, (v2) => climber.armLeft.angle = v2, k.easings.easeOutCubic);
    });
    const reachTarget = climber.headRadius * 2;
    k.tween(climber.armReachLeft, reachTarget, reachDur, (v2) => climber.armReachLeft = v2, k.easings.linear).then?.(() => {
      k.tween(climber.armReachLeft, 0, pullDur, (v2) => climber.armReachLeft = v2, k.easings.easeInCubic);
      const y0 = climber.root.pos.y;
      k.tween(y0, y0 - pullHeight, pullDur * 0.6, (v2) => climber.root.pos.y = v2, k.easings.easeOutCubic).then?.(() => {
        k.tween(climber.root.pos.y, y0, pullDur * 0.4, (v2) => climber.root.pos.y = v2, k.easings.easeInCubic);
      });
    });
  } else {
    const fromA = climber.armRight.angle ?? 0;
    const reachTw = k.tween(fromA, 60, reachDur * 0.8, (v2) => climber.armRight.angle = v2, k.easings.easeOutCubic);
    reachTw.then?.(() => {
      k.tween(climber.armRight.angle, 0, pullDur * 0.8, (v2) => climber.armRight.angle = v2, k.easings.easeOutCubic);
    });
    const reachTarget = climber.headRadius * 2;
    k.tween(climber.armReachRight, reachTarget, reachDur, (v2) => climber.armReachRight = v2, k.easings.linear).then?.(() => {
      k.tween(climber.armReachRight, 0, pullDur, (v2) => climber.armReachRight = v2, k.easings.easeInCubic);
      const y0 = climber.root.pos.y;
      k.tween(y0, y0 - pullHeight, pullDur * 0.6, (v2) => climber.root.pos.y = v2, k.easings.easeOutCubic).then?.(() => {
        k.tween(climber.root.pos.y, y0, pullDur * 0.4, (v2) => climber.root.pos.y = v2, k.easings.easeInCubic);
      });
    });
  }
}
function createObstacleState(seed = Math.random() * 1e9) {
  let x = seed | 0 || 123456789;
  const rng2 = () => {
    x ^= x << 13;
    x ^= x >>> 17;
    x ^= x << 5;
    return (x >>> 0) % 1e5 / 1e5;
  };
  return { rng: rng2 };
}
function nextObstacle(score, lastSide, sameSideRun, rng2) {
  let side = rng2() < 0.5 ? "left" : "right";
  if (lastSide && sameSideRun >= GAME_CONFIG.obstacles.maxSameSideInRow) {
    side = lastSide === "left" ? "right" : "left";
  }
  const eitherAllowed = rng2() < GAME_CONFIG.obstacles.dualHoldChance;
  const newRun = lastSide === side ? sameSideRun + 1 : 1;
  return { side, newRun, newLast: side, eitherAllowed };
}
function seedInitialSegments(count, rng2) {
  const segs = [];
  let last = null;
  let run = 0;
  for (let i2 = 0; i2 < count; i2++) {
    const n = nextObstacle(0, last, run, rng2);
    const seg = { side: n.side };
    seg.eitherAllowed = n.eitherAllowed;
    populateHoldsForSegment(seg, rng2);
    segs.push(seg);
    last = n.newLast;
    run = n.newRun;
  }
  if (segs.length > 0) {
    segs[0] = { ...segs[0], side: null, holds: {} };
  }
  return segs;
}
function generateHoldSpec(rng2) {
  const rect = rng2() < 0.5;
  const color = rng2() < 0.33 ? [176, 170, 162] : rng2() < 0.66 ? [160, 154, 148] : [188, 180, 172];
  return rect ? { kind: "rect", w: 14 + Math.floor(rng2() * 6), h: 6 + Math.floor(rng2() * 3), rotDeg: (rng2() - 0.5) * 15, offsetX: (rng2() - 0.5) * 10, offsetYRatio: (rng2() - 0.5) * 0.2, color } : { kind: "circle", r: 5 + Math.floor(rng2() * 3), rotDeg: 0, offsetX: (rng2() - 0.5) * 10, offsetYRatio: (rng2() - 0.5) * 0.2, color };
}
function populateHoldsForSegment(seg, rng2) {
  const allowed = seg.side ? [seg.side] : ["left", "right"];
  seg.holds = seg.holds ?? {};
  for (const s of allowed) {
    const spec = generateHoldSpec(rng2);
    spec.offsetYRatio = -0.25 + (rng2() - 0.5) * 0.1;
    spec.offsetX = (rng2() - 0.5) * 8;
    seg.holds[s] = spec;
  }
}
function rand(min, max) {
  return Math.random() * (max - min) + min;
}
function sampleXsSpaced(randFn, min, max, count, jitterFrac = 0.35) {
  const xs = [];
  const span = Math.max(1, max - min);
  const step = span / Math.max(1, count);
  for (let i2 = 0; i2 < count; i2++) {
    const center = min + (i2 + 0.5) * step;
    const jitter = (randFn() * 2 - 1) * step * jitterFrac;
    const x = Math.min(max, Math.max(min, center + jitter));
    xs.push(x);
  }
  return xs;
}
function spawnBackground(k, viewSize, opts) {
  const clouds = [];
  const trees = [], shrubs = [];
  let lastTheme = window.__theme ?? loadTheme();
  const daySky = k.rgb(196, 235, 250), nightSky = k.rgb(18, 26, 42);
  const sky = k.add([k.rect(viewSize.x, viewSize.y), k.pos(0, 0), k.anchor("topleft"), k.z(-50), k.color(lastTheme === "night" ? nightSky : daySky)]);
  const sun = k.add([k.circle(Math.max(14, viewSize.x * 0.04)), k.pos(Math.max(48, viewSize.x * 0.08), Math.max(48, viewSize.y * 0.1)), k.anchor("center"), k.color(255, 210, 60), k.z(-30)]);
  const moon = k.add([k.circle(Math.max(12, viewSize.x * 0.035)), k.pos(Math.max(viewSize.x - 64, viewSize.x * 0.92), Math.max(48, viewSize.y * 0.14)), k.anchor("center"), k.color(220, 230, 255), k.z(-30)]);
  ((ox, oy, r) => moon.add([k.circle(r), k.pos(ox, oy), k.color(200, 210, 240), k.opacity(0.6)]))(-6, -4, 3);
  ((ox, oy, r) => moon.add([k.circle(r), k.pos(ox, oy), k.color(200, 210, 240), k.opacity(0.6)]))(4, 2, 2.4);
  ((ox, oy, r) => moon.add([k.circle(r), k.pos(ox, oy), k.color(200, 210, 240), k.opacity(0.6)]))(2, -6, 2.2);
  sun.hidden = lastTheme === "night";
  moon.hidden = lastTheme !== "night";
  const horizonHeight = (typeof opts?.horizonLevel === "number" ? opts.horizonLevel : null) ?? viewSize.y * 0.88 - 8;
  const treeBaseY = horizonHeight + 8;
  function spawnCloud(startOffLeft = false) {
    const width = rand(viewSize.x * 0.18, viewSize.x * 0.34);
    const x = startOffLeft ? -10 - width / 2 : rand(0, viewSize.x);
    const c = k.add([k.rect(width, width * 0.3, { radius: width * 0.15 }), k.pos(x, rand(18, viewSize.y * 0.6)), k.color(255, 255, 255), k.opacity(0.32), { z: -20, speed: rand(12, 28) }]);
    clouds.push(c);
  }
  const initialClouds = Math.max(6, Math.round(12 * Math.max(1, viewSize.x / 540)));
  for (let i2 = 0; i2 < initialClouds; i2++) spawnCloud(false);
  const maxClouds = Math.max(initialClouds, Math.round(initialClouds * 1.5));
  let cloudSpawnTimer = 0;
  const ground = k.add([k.rect(viewSize.x, Math.max(10, viewSize.y - treeBaseY + 8), { radius: 6 }), k.pos(0, viewSize.y), k.anchor("botleft"), k.color(74, 52, 43), { z: -2 }]);
  for (let i2 = 0; i2 < 6; i2++) {
    const w = rand(viewSize.x * 0.12, viewSize.x * 0.3);
    const h = rand(8, 16);
    k.add([k.rect(w, h, { radius: 8 }), k.pos(rand(10, viewSize.x - 10), viewSize.y - rand(6, 20)), k.anchor("bot"), k.color(56, 40, 34), k.opacity(0.7), { z: -1.9 }]);
  }
  const baseTreeCount = Math.round(8 * 0.7);
  const densityMul = Math.max(0, Math.min(1, opts?.treeDensityMul ?? 1));
  const treeCount = Math.max(0, Math.round(baseTreeCount * densityMul));
  const clip = opts?.treeClip;
  const minX = clip ? clip.centerX - clip.width / 2 : 0;
  const maxX = clip ? clip.centerX + clip.width / 2 : viewSize.x;
  const addTree = (x, scale, variant, heightMul = 1) => {
    const trunkMul = Math.max(0.1, opts?.trunkHeightMul ?? 1);
    const trunk = k.add([k.rect(5 * scale, 18 * scale * heightMul * trunkMul, { radius: 2 }), k.pos(x, treeBaseY), k.anchor("bot"), k.color(84, 60, 44), { z: -1.5 }]);
    trees.push(trunk);
    const type = variant ?? (Math.random() < 0.6 ? "round" : "cone");
    const baseTrunkH = 18 * scale * heightMul * trunkMul;
    if (type === "round") {
      const blobCount = 3 + Math.floor(Math.random() * 3);
      const baseR = 10 * scale * (0.9 + 0.5 * (heightMul - 1));
      for (let i2 = 0; i2 < blobCount; i2++) {
        const r = baseR * (0.8 + Math.random() * 0.5);
        const ox = (Math.random() * 12 - 6) * scale;
        const oy = baseTrunkH + (Math.random() * 6 - 8) * scale;
        const blob = k.add([k.circle(r), k.pos(x + ox, treeBaseY - oy), k.anchor("center"), k.color(60 + i2 * 6, 130 + i2 * 4, 90), { z: -1.45 }]);
        trees.push(blob);
      }
      const hl = k.add([k.circle(Math.max(1, baseR * 0.5)), k.pos(x + 6 * scale, treeBaseY - (baseTrunkH + 6 * scale)), k.anchor("center"), k.color(255, 255, 255), k.opacity(0.06), { z: -1.44 }]);
      trees.push(hl);
    } else {
      const stripes = 5;
      for (let s = 0; s < stripes; s++) {
        const frac = (s + 1) / stripes;
        const wobble = Math.sin(frac * Math.PI) * 2 * scale;
        const w = 20 * scale * (0.4 + frac * 0.75);
        const h = 5 * scale * heightMul;
        const y = treeBaseY - baseTrunkH - s * h + 2 * scale;
        const leaf = k.add([k.rect(w, h, { radius: 3 }), k.pos(x + wobble * (Math.random() - 0.5), y), k.anchor("center"), k.color(44 + s * 6, 118 + s * 4, 82), { z: -1.45 }]);
        trees.push(leaf);
      }
    }
  };
  const tScale = Math.max(0.5, opts?.treeScale ?? 1);
  for (const x of sampleXsSpaced(Math.random, minX + 10, maxX - 10, treeCount, 0.35)) {
    const scale = rand(0.9, 1.3) * tScale;
    const heightMul = 1 + (Math.random() * 0.5 - 0.25);
    addTree(x, scale, Math.random() < 0.65 ? "round" : "cone", heightMul);
  }
  const leftRange = { min: 10, max: Math.max(20, minX - 10) };
  const rightRange = { min: Math.min(viewSize.x - 20, maxX + 10), max: viewSize.x - 10 };
  const addCluster = (range, count) => {
    if (range.max - range.min < 10) return;
    const c = Math.max(0, Math.round(count * densityMul * 0.7));
    for (const x of sampleXsSpaced(Math.random, range.min, range.max, c, 0.25)) {
      const scale = rand(0.9, 1.5) * tScale;
      const heightMul = 1 + (Math.random() * 0.5 - 0.25);
      addTree(x, scale, Math.random() < 0.6 ? "round" : "cone", heightMul);
      if (Math.random() < 0.7) {
        const w = rand(12, 26) * (scale * 0.6);
        const h = rand(6, 10) * (scale * 0.5);
        const shrub = k.add([k.rect(w, h, { radius: 4 }), k.pos(x + rand(-8, 8), treeBaseY - 2), k.anchor("bot"), k.color(66, 120, 72), k.opacity(0.9), { z: -1.48 }]);
        shrubs.push(shrub);
        if (Math.random() < 0.5) {
          const sprig = k.add([k.rect(w * 0.6, h * 0.7, { radius: 3 }), k.pos(x + rand(-10, 10), treeBaseY - h * 0.6), k.anchor("bot"), k.color(58, 100, 64), { z: -1.47 }]);
          shrubs.push(sprig);
        }
      }
    }
  };
  addCluster(leftRange, 8);
  addCluster(rightRange, 8);
  k.onUpdate(() => {
    const theme = window.__theme ?? loadTheme();
    if (theme !== lastTheme) {
      lastTheme = theme;
      const isNight = theme === "night";
      sky.color = isNight ? nightSky : daySky;
      ground.color = isNight ? k.rgb(54, 42, 38) : k.rgb(74, 52, 43);
      sun.hidden = isNight;
      moon.hidden = !isNight;
      for (const c of clouds) c.opacity = isNight ? 0.22 : 0.32;
      const treeOpacity = isNight ? 0.82 : 1;
      for (const t of trees) t.opacity = treeOpacity;
      for (const s of shrubs) s.opacity = isNight ? 0.85 : 0.95;
    }
    cloudSpawnTimer -= k.dt();
    if (cloudSpawnTimer <= 0 && clouds.length < maxClouds) {
      spawnCloud(true);
      cloudSpawnTimer = rand(0.8, 1.6);
    }
    for (const c of clouds) {
      const s = c.speed ?? 10;
      c.move(s, 0);
      const pos = c.pos;
      const width = c.width;
      if (pos.x - width / 2 > viewSize.x + 10) {
        c.pos.x = -10 - width / 2;
        c.pos.y = rand(20, viewSize.y * 0.6);
      }
    }
  });
  return { sky, sun, moon, clouds, trees, shrubs, ground };
}
function spawnRockWall(k, centerX, viewH, width, bandH, seedBaseOverride) {
  const baseR = 150, baseG = 130, baseB = 110;
  const seedBase = typeof seedBaseOverride === "number" ? seedBaseOverride : Math.floor(Math.random() * 1e9);
  function rngFrom(n) {
    let a = (seedBase ^ n * 2654435761) >>> 0;
    let b = (a ^ 2246822507) >>> 0;
    let c = (b ^ 3266489909) >>> 0;
    let d = (c ^ 668265263) >>> 0;
    return function random() {
      a >>>= 0;
      b >>>= 0;
      c >>>= 0;
      d >>>= 0;
      let t = a + b | 0;
      a = b ^ b >>> 9;
      b = c + (c << 3) | 0;
      c = c << 21 | c >>> 11;
      d = d + 1 | 0;
      t = t + d | 0;
      c = c + t | 0;
      return (t >>> 0) / 4294967296;
    };
  }
  const bandCount = Math.ceil(viewH / bandH) + 4;
  const leftOffsets = [];
  const rightOffsets = [];
  let curL = 0, curR = 0;
  const maxJitter = width * 0.12;
  for (let i2 = 0; i2 < bandCount; i2++) {
    curL += (Math.random() - 0.5) * (width * 0.06);
    curR += (Math.random() - 0.5) * (width * 0.06);
    curL = Math.max(-maxJitter, Math.min(maxJitter, curL));
    curR = Math.max(-maxJitter, Math.min(maxJitter, curR));
    leftOffsets.push(curL);
    rightOffsets.push(curR);
  }
  const edgesAt = (y) => {
    const idx = Math.max(0, Math.min(bandCount - 1, Math.floor(y / bandH)));
    const lOff = leftOffsets[idx] ?? 0;
    const rOff = rightOffsets[idx] ?? 0;
    const left = centerX - width / 2 + lOff;
    const right = centerX + width / 2 + rOff;
    return { left, right };
  };
  const laneXAt = (y, side) => {
    const { left, right } = edgesAt(y);
    const w = right - left;
    const margin = w * 0.25;
    return side === "left" ? left + margin : right - margin;
  };
  const bands = [];
  const root = k.add([k.pos(0, 0)]);
  const buildBandSprite = (w, h, worldIdx) => {
    const r = rngFrom(worldIdx);
    const cnv = document.createElement("canvas");
    cnv.width = Math.max(1, Math.ceil(w));
    cnv.height = Math.max(1, Math.ceil(h));
    const ctx = cnv.getContext("2d", { alpha: true });
    ctx.fillStyle = `rgb(${baseR}, ${baseG}, ${baseB})`;
    ctx.fillRect(0, 0, cnv.width, cnv.height);
    const stripCount = 2 + Math.floor(r() * 2);
    for (let i2 = 0; i2 < stripCount; i2++) {
      const y = r() * h - h / 2;
      const len = w * (0.28 + r() * 0.38);
      const thick = 2 + Math.floor(r() * 2);
      const x = (r() - 0.5) * (w * 0.1) + w / 2 - len / 2;
      ctx.globalAlpha = 0.12 + r() * 0.08;
      const rr = Math.round(baseR + 10 + r() * 10);
      const gg = Math.round(baseG + 10 + r() * 10);
      const bb = Math.round(baseB + 8 + r() * 10);
      ctx.fillStyle = `rgb(${rr}, ${gg}, ${bb})`;
      ctx.fillRect(x, y + h / 2 - thick / 2, len, thick);
    }
    const patches = 4 + Math.floor(r() * 3);
    for (let i2 = 0; i2 < patches; i2++) {
      const pw = w * (0.1 + r() * 0.18);
      const ph = h * (0.18 + r() * 0.28);
      const lighten = r() < 0.4;
      const dr = (lighten ? 14 : -18) + (lighten ? r() * 8 : -r() * 8);
      const dg = (lighten ? 12 : -16) + (lighten ? r() * 6 : -r() * 6);
      const db = (lighten ? 12 : -16) + (lighten ? r() * 6 : -r() * 6);
      ctx.globalAlpha = 0.08 + r() * 0.07;
      const rr = Math.max(0, Math.min(255, baseR + dr));
      const gg = Math.max(0, Math.min(255, baseG + dg));
      const bb = Math.max(0, Math.min(255, baseB + db));
      ctx.fillStyle = `rgb(${rr}, ${gg}, ${bb})`;
      const x = (r() - 0.5) * (w * 0.7) + w / 2 - pw / 2;
      const y = (r() - 0.5) * (h * 0.7) + h / 2 - ph / 2;
      const radius = Math.min(pw, ph) * 0.25;
      ctx.beginPath();
      ctx.moveTo(x + radius, y);
      ctx.lineTo(x + pw - radius, y);
      ctx.quadraticCurveTo(x + pw, y, x + pw, y + radius);
      ctx.lineTo(x + pw, y + ph - radius);
      ctx.quadraticCurveTo(x + pw, y + ph, x + pw - radius, y + ph);
      ctx.lineTo(x + radius, y + ph);
      ctx.quadraticCurveTo(x, y + ph, x, y + ph - radius);
      ctx.lineTo(x, y + radius);
      ctx.quadraticCurveTo(x, y, x + radius, y);
      ctx.closePath();
      ctx.fill();
    }
    const specks = 70 + Math.floor(r() * 50);
    for (let i2 = 0; i2 < specks; i2++) {
      const rad = 1.4 + r() * 2.6;
      const x = (r() - 0.5) * (w * 0.9);
      const y = (r() - 0.5) * (h * 0.9);
      const darken = r() < 0.65;
      const dr = darken ? -22 - r() * 12 : 16 + r() * 10;
      const dg = darken ? -18 - r() * 10 : 14 + r() * 8;
      const db = darken ? -18 - r() * 10 : 12 + r() * 8;
      ctx.globalAlpha = darken ? 0.3 + r() * 0.1 : 0.18 + r() * 0.08;
      const rr = Math.max(0, Math.min(255, baseR + dr));
      const gg = Math.max(0, Math.min(255, baseG + dg));
      const bb = Math.max(0, Math.min(255, baseB + db));
      ctx.fillStyle = `rgb(${rr}, ${gg}, ${bb})`;
      ctx.beginPath();
      ctx.arc(x + w / 2, y + h / 2, rad, 0, Math.PI * 2);
      ctx.fill();
    }
    if (r() < 0.55) {
      const segs = 3 + Math.floor(r() * 3);
      let px = (r() - 0.5) * (w * 0.5);
      let py = (r() - 0.5) * (h * 0.3);
      let ang = r() * 80 - 40;
      const marginX = Math.min(14, w * 0.12);
      const marginY = Math.min(8, h * 0.2);
      for (let s = 0; s < segs; s++) {
        const len = 10 + r() * 18;
        const thick = 0.8 + r() * 1;
        const rad = ang * Math.PI / 180;
        const dx = Math.cos(rad) * len * 0.5;
        const dy = Math.sin(rad) * len * 0.5;
        const minX = -w / 2 + marginX + Math.abs(dx);
        const maxX = w / 2 - marginX - Math.abs(dx);
        const minY = -h / 2 + marginY + Math.abs(dy);
        const maxY = h / 2 - marginY - Math.abs(dy);
        px = Math.max(minX, Math.min(maxX, px));
        py = Math.max(minY, Math.min(maxY, py));
        ctx.save();
        ctx.globalAlpha = 0.2;
        ctx.translate(px + w / 2, py + h / 2);
        ctx.rotate(rad);
        ctx.fillStyle = `rgb(30,30,30)`;
        ctx.fillRect(-len / 2, -thick / 2, len, thick);
        ctx.restore();
        px += Math.cos(rad) * len * 0.6;
        py += Math.sin(rad) * len * 0.6;
        ang += r() * 40 - 20;
      }
    }
    const img = ctx.getImageData(0, 0, cnv.width, cnv.height);
    const name = `rock_band_${Math.abs(worldIdx)}_${cnv.width}x${cnv.height}`;
    k.loadSprite(name, img);
    return name;
  };
  let worldTopIndex = 0;
  for (let i2 = 0; i2 < bandCount; i2++) {
    const yMid = -bandH / 2 + i2 * bandH;
    const { left, right } = edgesAt(yMid);
    const w = right - left;
    const spriteName = buildBandSprite(w, bandH + 4, worldTopIndex + i2);
    const o = root.add([k.sprite(spriteName), k.pos((left + right) / 2, yMid), k.anchor("center"), k.z(0)]);
    bands.push(o);
  }
  function spawnTopBand() {
    const topL = leftOffsets[0] ?? 0;
    const topR = rightOffsets[0] ?? 0;
    let nextL = topL + (Math.random() - 0.5) * (width * 0.06);
    let nextR = topR + (Math.random() - 0.5) * (width * 0.06);
    nextL = Math.max(-maxJitter, Math.min(maxJitter, nextL));
    nextR = Math.max(-maxJitter, Math.min(maxJitter, nextR));
    leftOffsets.unshift(nextL);
    rightOffsets.unshift(nextR);
    leftOffsets.pop();
    rightOffsets.pop();
    const yMid = (bands[0]?.pos.y ?? -bandH / 2) - bandH;
    const { left, right } = edgesAt(0);
    const w = right - left;
    worldTopIndex -= 1;
    const spriteName = buildBandSprite(w, bandH + 4, worldTopIndex);
    const o = root.add([k.sprite(spriteName), k.pos((left + right) / 2, yMid), k.anchor("center"), k.z(0)]);
    bands.unshift(o);
    const last = bands.pop();
    last?.destroy();
  }
  function scrollOnce(duration) {
    return new Promise((resolve) => {
      const startY = root.pos.y;
      k.tween(startY, startY + bandH, duration, (v2) => root.pos.y = v2, k.easings.linear).then?.(() => {
        root.pos.y = 0;
        for (const b of bands) {
          b.pos.y += bandH;
        }
        spawnTopBand();
        resolve();
      });
    });
  }
  return { root, laneXAt, edgesAt, scrollOnce };
}
function spawnSprayCan(k, parent, x, y, side, scale = 1, z = 1.2, opts) {
  const s = scale;
  const root = parent.add([k.pos(x, y), k.anchor("center"), k.z(z), k.rotate(0)]);
  const bodyColor = opts?.bodyColor ?? k.rgb(190, 190, 200);
  const metalDark = k.rgb(150, 150, 160);
  const capCol = k.rgb(235, 235, 240);
  const nozzleCol = k.rgb(240, 240, 245);
  const holeCol = k.rgb(40, 40, 40);
  const bodyW = 14 * s;
  const bodyH = 22 * s;
  const radius = 3 * s;
  const topBandH = 3 * s;
  const capH = 6 * s;
  const body = root.add([k.rect(bodyW, bodyH, { radius }), k.pos(0, 0), k.anchor("center"), k.color(bodyColor)]);
  body.add([k.rect(bodyW * 0.9, bodyH * 0.4, { radius: radius * 0.6 }), k.pos(0, bodyH * 0.1), k.anchor("center"), k.color(metalDark), k.opacity(0.25)]);
  root.add([k.rect(bodyW * 0.95, topBandH, { radius: topBandH * 0.3 }), k.pos(0, -bodyH / 2 + topBandH / 2), k.anchor("center"), k.color(metalDark)]);
  root.add([k.rect(bodyW * 0.8, capH, { radius: capH * 0.5 }), k.pos(0, -bodyH / 2 - capH / 2 + 1 * s), k.anchor("center"), k.color(capCol)]);
  const dir = 1;
  const nozzleY = -bodyH / 2 - capH + 4 * s;
  const stemW = 6 * s;
  const stemH = 4 * s;
  const tipW = 4 * s;
  const tipH = 3 * s;
  root.add([k.rect(stemW, stemH, { radius: 1 * s }), k.pos(dir * (bodyW * 0.2), nozzleY), k.anchor("center"), k.color(nozzleCol)]);
  const tip = root.add([k.rect(tipW, tipH, { radius: 1 * s }), k.pos(dir * (bodyW * 0.2 + stemW * 0.5 + tipW * 0.3), nozzleY - 1 * s), k.anchor("center"), k.color(nozzleCol)]);
  tip.add([k.circle(0.8 * s), k.pos(dir * (tipW * 0.3), 0), k.anchor("center"), k.color(holeCol)]);
  const nozzleAnchor = root.add([k.pos(dir * (bodyW * 0.2 + stemW * 0.5 + tipW * 0.6), nozzleY - 1 * s), k.anchor("center")]);
  root._nozzleAnchor = nozzleAnchor;
  return root;
}
const LAYER_PARALLAX = { tall: 0.2, medium: 0.4, short: 0.7 };
const LAYER_COUNTS = { tall: 2, medium: 4, short: 5 };
const HEIGHT_RANGES = {
  tall: { min: 0.55, max: 0.75, mean: 0.65 },
  medium: { min: 0.45, max: 0.6, mean: 0.5 },
  short: { min: 0.25, max: 0.5, mean: 0.3 }
};
const BASE_GREY = { h: 220, s: 8, l: 58 };
function rng(seed) {
  const str = String(seed ?? 0);
  let h1 = 1779033703, h2 = 3144134277, h3 = 1013904242, h4 = 2773480762;
  for (let i2 = 0; i2 < str.length; i2++) {
    const k = str.charCodeAt(i2);
    h1 = h2 ^ Math.imul(h1 ^ k, 597399067);
    h2 = h3 ^ Math.imul(h2 ^ k, 2869860233);
    h3 = h4 ^ Math.imul(h3 ^ k, 951274213);
    h4 = h1 ^ Math.imul(h4 ^ k, 2716044179);
  }
  h1 = Math.imul(h3 ^ h1 >>> 18, 597399067);
  h2 = Math.imul(h4 ^ h2 >>> 22, 2869860233);
  h3 = Math.imul(h1 ^ h3 >>> 17, 951274213);
  h4 = Math.imul(h2 ^ h4 >>> 19, 2716044179);
  let a = (h1 ^ h2 ^ h3 ^ h4) >>> 0;
  let b = (h2 ^ h1) >>> 0;
  let c = (h3 ^ h1) >>> 0;
  let d = (h4 ^ h1) >>> 0;
  return function random() {
    a >>>= 0;
    b >>>= 0;
    c >>>= 0;
    d >>>= 0;
    let t = a + b | 0;
    a = b ^ b >>> 9;
    b = c + (c << 3) | 0;
    c = c << 21 | c >>> 11;
    d = d + 1 | 0;
    t = t + d | 0;
    c = c + t | 0;
    return (t >>> 0) / 4294967296;
  };
}
function pickInRange(random, min, max, meanHint) {
  if (meanHint === void 0) return min + (max - min) * random();
  const mode = Math.max(min, Math.min(max, meanHint));
  const u = random();
  const c = (mode - min) / (max - min || 1);
  if (u < c) {
    return min + Math.sqrt(u * (max - min) * (mode - min));
  }
  return max - Math.sqrt((1 - u) * (max - min) * (max - mode));
}
function clamp(n, min, max) {
  return Math.max(min, Math.min(max, n));
}
function hsl(h, s, l, a = 1) {
  return `hsla(${Math.round(h)}, ${Math.round(s)}%, ${Math.round(l)}%, ${a})`;
}
function jitterLightness(layer, baseL, random) {
  const j = 5 + random() * 5;
  let l = baseL + (random() * 2 - 1) * j;
  if (layer === "tall") l -= 6;
  else if (layer === "medium") l -= 2;
  else l += 2;
  return clamp(l, 10, 90);
}
function layerZ(layer) {
  switch (layer) {
    case "tall":
      return -15;
    case "medium":
      return -12;
    case "short":
      return -9;
  }
}
function makeMountainPolygon(params) {
  const { xCenter, baseY, width, height, peaks, peakDelta = 0.15, random } = params;
  const half = width / 2;
  const leftX = xCenter - half;
  const rightX = xCenter + half;
  const topY = baseY - height;
  const ridge = [];
  if (peaks === 1) {
    const lShoulderX = leftX + width * (0.28 + random() * 0.08);
    const rShoulderX = rightX - width * (0.28 + random() * 0.08);
    const apexX = xCenter + (random() * 2 - 1) * width * 0.06;
    const lY = baseY - height * (0.7 + random() * 0.12);
    const rY = baseY - height * (0.68 + random() * 0.12);
    const apex = { x: apexX, y: topY };
    const lMid = { x: lShoulderX, y: lY };
    const rMid = { x: rShoulderX, y: rY };
    ridge.push(lMid, apex, rMid);
  } else {
    const leftPeakX = xCenter - width * (0.18 + random() * 0.08);
    const rightPeakX = xCenter + width * (0.18 + random() * 0.08);
    const d = clamp(peakDelta, 0.05, 0.35);
    const leftPeakH = height * (1 - d * (random() < 0.5 ? 1 : 0.5));
    const rightPeakH = height * (1 - d * (random() < 0.5 ? 0.5 : 1));
    const left = { x: leftPeakX, y: baseY - leftPeakH };
    const right = { x: rightPeakX, y: baseY - rightPeakH };
    const saddleX = xCenter + (random() * 2 - 1) * width * 0.06;
    const saddleY = baseY - height * (0.78 + random() * 0.08);
    const lShoulderX = leftX + width * (0.22 + random() * 0.07);
    const rShoulderX = rightX - width * (0.22 + random() * 0.07);
    const lShoulder = { x: lShoulderX, y: baseY - height * (0.68 + random() * 0.1) };
    const rShoulder = { x: rShoulderX, y: baseY - height * (0.66 + random() * 0.1) };
    ridge.push(lShoulder, left, { x: saddleX, y: saddleY }, right, rShoulder);
  }
  ridge.sort((a, b) => a.x - b.x);
  const outline = [{ x: leftX, y: baseY }, ...ridge, { x: rightX, y: baseY }];
  const apexY = ridge.reduce((m, p) => Math.min(m, p.y), baseY);
  return { outline, ridge, width, height, apexY };
}
function drawMountain(ctx, poly, fillStyle) {
  const pts = poly.outline;
  if (!pts || pts.length < 2) return;
  ctx.beginPath();
  ctx.moveTo(pts[0].x, pts[0].y);
  for (let i2 = 1; i2 < pts.length; i2++) {
    const p = pts[i2];
    ctx.lineTo(p.x, p.y);
  }
  ctx.closePath();
  ctx.fillStyle = fillStyle;
  ctx.fill();
}
function intersectAtY(a, b, y) {
  const dy = b.y - a.y;
  if (dy === 0) return null;
  const t = (y - a.y) / dy;
  if (t < 0 || t > 1) return null;
  return { x: a.x + (b.x - a.x) * t, y };
}
function makeSnowCap(poly, random) {
  const { ridge, apexY, height } = poly;
  const capBaseY = apexY + height * (0.3 + random() * 0.06);
  if (ridge.length === 0) return [];
  const capTop = [];
  for (let i2 = 0; i2 < ridge.length - 1; i2++) {
    const p = ridge[i2];
    const q = ridge[i2 + 1];
    if (p.y <= capBaseY) capTop.push({ x: p.x, y: p.y });
    const cross = intersectAtY(p, q, capBaseY);
    if (cross) capTop.push(cross);
  }
  const last = ridge[ridge.length - 1];
  if (last && last.y <= capBaseY) capTop.push(last);
  if (capTop.length < 2) return [];
  const uniqTop = [];
  for (const p of capTop.sort((a, b) => a.x - b.x)) {
    const prev = uniqTop[uniqTop.length - 1];
    if (!prev || Math.hypot(p.x - prev.x, p.y - prev.y) > 0.5) uniqTop.push(p);
  }
  if (uniqTop.length < 2) return [];
  const capBottom = [];
  const jagAmp = Math.max(3, height * 0.04);
  const spanX = uniqTop[uniqTop.length - 1].x - uniqTop[0].x;
  const segs = Math.max(6, Math.min(18, Math.round(spanX / 24)));
  for (let i2 = 0; i2 <= segs; i2++) {
    const t = i2 / segs;
    const x = uniqTop[0].x + spanX * t;
    const jag = (i2 % 2 === 0 ? 1 : -1) * (0.5 + random() * 0.5) * jagAmp;
    const y = capBaseY + jag * 0.35 + height * 0.02 + random() * height * 0.015;
    capBottom.push({ x, y });
  }
  const capPoly = [...uniqTop, ...capBottom.reverse()];
  return capPoly;
}
function drawSnowCap(ctx, capPoly) {
  if (!capPoly || capPoly.length < 3) return;
  const first = capPoly[0];
  let minY = first.y;
  let maxY = first.y;
  for (const p of capPoly) {
    minY = Math.min(minY, p.y);
    maxY = Math.max(maxY, p.y);
  }
  const grad = ctx.createLinearGradient(0, minY, 0, maxY);
  grad.addColorStop(0, "rgba(255,255,255,1.0)");
  grad.addColorStop(1, "rgba(255,255,255,0.75)");
  ctx.beginPath();
  ctx.moveTo(first.x, first.y);
  for (let i2 = 1; i2 < capPoly.length; i2++) {
    const p = capPoly[i2];
    ctx.lineTo(p.x, p.y);
  }
  ctx.closePath();
  ctx.fillStyle = grad;
  ctx.fill();
}
function buildLayerCanvas(layer, canvasW, canvasH, horizon, seedRandom, counts, viewportStart, viewportWidth) {
  const offW = Math.ceil(canvasW);
  const offH = Math.ceil(canvasH);
  const cnv = document.createElement("canvas");
  const peakPoints = [];
  cnv.width = offW;
  cnv.height = offH;
  const ctx = cnv.getContext("2d", { alpha: true });
  ctx.clearRect(0, 0, offW, offH);
  const r = seedRandom;
  const range = HEIGHT_RANGES[layer];
  const count = counts[layer];
  const xs = sampleXsSpaced(r, offW * 0.1, offW * 0.9, count, 0.45);
  const viewStart = viewportStart ?? 0;
  const safeWidth = Math.max(1, viewportWidth);
  const viewEnd = viewStart + safeWidth;
  const midX = viewStart + safeWidth / 2;
  const margin = Math.max(12, safeWidth * 0.02);
  const leftMin = viewStart + margin;
  const leftMax = midX - margin;
  const rightMin = midX + margin;
  const rightMax = viewEnd - margin;
  const inLeft = (x) => x >= leftMin && x <= leftMax;
  const inRight = (x) => x >= rightMin && x <= rightMax;
  let leftCount = xs.filter((x) => inLeft(x)).length;
  let rightCount = xs.filter((x) => inRight(x)).length;
  if (layer === "tall" && count >= 2) {
    if (leftCount === 0) xs[0] = pickInRange(r, leftMin, leftMax, (leftMin + leftMax) / 2);
    if (rightCount === 0) xs[Math.min(1, xs.length - 1)] = pickInRange(r, rightMin, rightMax, (rightMin + rightMax) / 2);
  } else {
    if (leftCount === 0 && xs.length > 0) xs[0] = pickInRange(r, leftMin, leftMax, (leftMin + leftMax) / 2);
    if (rightCount === 0 && xs.length > 1) xs[1] = pickInRange(r, rightMin, rightMax, (rightMin + rightMax) / 2);
  }
  const doubleIdx = /* @__PURE__ */ new Set();
  if (layer === "short") {
    const c1 = Math.floor(r() * count);
    let c2 = Math.floor(r() * count);
    if (c2 === c1) c2 = (c1 + 1) % count;
    doubleIdx.add(c1);
    doubleIdx.add(c2);
  } else if (layer === "medium") {
    doubleIdx.add(Math.floor(r() * count));
  }
  for (let i2 = 0; i2 < count; i2++) {
    const xCenter = xs[i2];
    const h = pickInRange(r, canvasH * range.min, canvasH * range.max, canvasH * range.mean);
    const minW = canvasW * 0.18;
    const maxW = canvasW * 0.55;
    const baseW = clamp(h * pickInRange(r, 1.1, 1.9, 1.4), minW, maxW);
    const w = baseW * (0.9 + r() * 0.2);
    const numPeaks = doubleIdx.has(i2) ? 2 : 1;
    const peakDeltaVal = numPeaks === 2 ? 0.12 + r() * 0.2 : 0.15;
    const params = { xCenter, baseY: horizon, width: w, height: h, peaks: numPeaks, random: r, peakDelta: peakDeltaVal };
    const mp = makeMountainPolygon(params);
    const l = jitterLightness(layer, BASE_GREY.l, r);
    const fill = hsl(BASE_GREY.h, BASE_GREY.s, l);
    drawMountain(ctx, mp, fill);
    const midOutlineX = mp.outline[Math.floor(mp.outline.length / 2)]?.x ?? xCenter;
    const firstRidge = mp.ridge.length > 0 ? mp.ridge[0] : null;
    let apexX = firstRidge ? firstRidge.x : midOutlineX;
    let apexY = mp.apexY;
    for (const rp of mp.ridge) {
      if (typeof rp.y === "number" && rp.y < apexY) {
        apexY = rp.y;
        apexX = rp.x;
      }
    }
    peakPoints.push({ x: apexX, y: apexY });
    const capPoly = makeSnowCap(mp, r);
    if (capPoly.length >= 3) drawSnowCap(ctx, capPoly);
  }
  return { canvas: cnv, peakPoints };
}
function addMountains(k, config) {
  let lastTheme = window.__theme ?? loadTheme();
  let viewW = k.width();
  let viewH = k.height();
  const horizon = config.horizon;
  const counts = {
    tall: config.count?.tall ?? LAYER_COUNTS.tall,
    medium: config.count?.medium ?? LAYER_COUNTS.medium,
    short: config.count?.short ?? LAYER_COUNTS.short
  };
  const seedBase = config.seed ?? Math.floor(Math.random() * 1e9);
  let random = rng(seedBase);
  const layers = [
    { kind: "tall", z: layerZ("tall"), parallax: LAYER_PARALLAX.tall, root: null, spriteName: `mountains_tall`, canvas: null, offsetX: 0, offsetY: 0 },
    { kind: "medium", z: layerZ("medium"), parallax: LAYER_PARALLAX.medium, root: null, spriteName: `mountains_medium`, canvas: null, offsetX: 0, offsetY: 0 },
    { kind: "short", z: layerZ("short"), parallax: LAYER_PARALLAX.short, root: null, spriteName: `mountains_short`, canvas: null, offsetX: 0, offsetY: 0 }
  ];
  let autoDrift = true;
  let goat = null;
  let goatBase = null;
  let goatState = "walk";
  let goatFacing = 1;
  let goatS = 0;
  let stateTimer = 0;
  let stateDur = 0;
  let stepPhase = 0;
  function updateRootPosition(l) {
    if (!l.root || !l.canvas) return;
    const cnvW = l.canvas.width;
    const baseX = -(cnvW - viewW) / 2;
    const maxShift = Math.max(1, cnvW - viewW);
    const wrapped = (l.offsetX % maxShift + maxShift) % maxShift;
    l.root.pos.x = baseX + wrapped;
    l.root.pos.y = l.offsetY;
  }
  const destroyAll = () => {
    for (const l of layers) {
      try {
        l.root?.destroy();
      } catch {
      }
      l.root = null;
      l.canvas = null;
      l.offsetX = 0;
      l.offsetY = 0;
    }
  };
  const buildAll = (seedOverride) => {
    destroyAll();
    random = rng(seedOverride ?? seedBase);
    viewW = k.width();
    viewH = k.height();
    const layerPeaks = { tall: [], medium: [], short: [] };
    for (const l of layers) {
      const cnvW = viewW * 2.2;
      const maxPhase = Math.max(0, cnvW - viewW);
      const startPhase = (random() * 0.3 - 0.15) * maxPhase;
      const viewportStart = Math.max(0, Math.min(maxPhase, (cnvW - viewW) / 2 - startPhase));
      const build = buildLayerCanvas(
        l.kind,
        cnvW,
        viewH,
        horizon,
        random,
        counts,
        viewportStart,
        viewW
      );
      l.canvas = build.canvas;
      layerPeaks[l.kind] = build.peakPoints;
      const c2d = build.canvas.getContext("2d");
      const img = c2d.getImageData(0, 0, build.canvas.width, build.canvas.height);
      const name = `${l.spriteName}`;
      k.loadSprite(name, img);
      const root = k.add([k.sprite(name), k.pos(-(build.canvas.width - viewW) / 2 + startPhase, 0), k.anchor("topleft"), k.z(l.z)]);
      l.root = root;
      l.offsetX = startPhase;
      l.offsetY = 0;
      updateRootPosition(l);
      const isNight = lastTheme === "night";
      l.root.opacity = isNight ? 0.82 : 1;
    }
    try {
      const shortLayer = layers.find((L) => L.kind === "short");
      const peaksArr = layerPeaks.short ?? [];
      if (shortLayer && shortLayer.root && peaksArr.length > 0) {
        let best = peaksArr[0];
        let bestDist = Infinity;
        const baseX = shortLayer.root.pos.x;
        const centerX = viewW / 2;
        const wallHalf = GAME_CONFIG.wall?.width ? GAME_CONFIG.wall.width / 2 : Math.max(60, viewW * 0.12);
        const blockMin = centerX - wallHalf - 12;
        const blockMax = centerX + wallHalf + 12;
        for (const p of peaksArr) {
          const worldX = baseX + p.x;
          if (worldX >= blockMin && worldX <= blockMax) continue;
          const d = Math.abs(worldX - centerX);
          if (d < bestDist) {
            best = p;
            bestDist = d;
          }
        }
        const peakX = best.x;
        const peakY = best.y;
        const g = shortLayer.root.add([k.pos(peakX, peakY), k.anchor("center"), k.z(shortLayer.z + 0.1)]);
        goat = g;
        const bodyCol = k.rgb(235, 238, 245);
        const hornCol = k.rgb(200, 180, 120);
        const body = g.add([k.rect(16, 9, { radius: 3 }), k.anchor("center"), k.color(bodyCol)]);
        const head = g.add([k.rect(7, 6, { radius: 2 }), k.pos(10, -3), k.anchor("center"), k.color(bodyCol)]);
        g.add([k.rect(2, 5, { radius: 1 }), k.pos(12, -8), k.anchor("center"), k.rotate(-20), k.color(hornCol)]);
        g.add([k.rect(2, 5, { radius: 1 }), k.pos(8, -8), k.anchor("center"), k.rotate(-40), k.color(hornCol)]);
        const legL = g.add([k.rect(2, 6, { radius: 1 }), k.pos(-4, 6), k.anchor("center"), k.color(60, 60, 70)]);
        const legM = g.add([k.rect(2, 6, { radius: 1 }), k.pos(0, 6), k.anchor("center"), k.color(60, 60, 70)]);
        const legR = g.add([k.rect(2, 6, { radius: 1 }), k.pos(4, 6), k.anchor("center"), k.color(60, 60, 70)]);
        g.add([k.rect(3, 2, { radius: 1 }), k.pos(-10, -3), k.anchor("center"), k.color(bodyCol)]);
        goatBase = { x: peakX, y: peakY };
        goatState = "walk";
        stateTimer = 0;
        stateDur = 2.2 + Math.random() * 0.8;
        stepPhase = 0;
        goatFacing = 1;
        goatS = 0;
        g._parts = { body, head, legL, legM, legR };
      }
    } catch {
    }
  };
  buildAll();
  const DRIFT_PX_PER_SEC_BASE = 0.01;
  k.onUpdate(() => {
    if (goat && goatBase) {
      const dt = Math.min(0.05, k.dt() ?? 0.016);
      stateTimer += dt;
      const parts = goat._parts || {};
      if (goatState === "walk") {
        const walkSpeed = 0.18;
        goatS += goatFacing * walkSpeed * dt;
        const maxExcursion = 0.65;
        if (goatS > maxExcursion) {
          goatS = maxExcursion;
        }
        if (goatS < -maxExcursion) {
          goatS = -maxExcursion;
        }
        stepPhase += 3.8 * dt;
        const step = Math.sin(stepPhase) * 4;
        if (parts.legL) parts.legL.angle = step;
        if (parts.legR) parts.legR.angle = -step;
        if (parts.legM) parts.legM.angle = Math.sin(stepPhase + Math.PI / 2) * 2;
        if (parts.head) parts.head.angle = Math.sin(stepPhase * 0.7) * 2.5;
        if (stateTimer >= stateDur || Math.abs(goatS) >= maxExcursion - 1e-3) {
          goatState = "turn";
          stateTimer = 0;
          stateDur = 0.4 + Math.random() * 0.2;
        }
      } else if (goatState === "turn") {
        const t = Math.min(1, stateTimer / Math.max(0.01, stateDur));
        const tilt = (1 - Math.cos(t * Math.PI)) * 8 * (goatFacing === 1 ? 1 : -1);
        if (parts.body) parts.body.angle = tilt;
        if (parts.head) parts.head.angle = tilt * 0.4;
        if (t >= 1) {
          goatFacing = goatFacing === 1 ? -1 : 1;
          if (parts.body) parts.body.angle = 0;
          goatState = "rest";
          stateTimer = 0;
          stateDur = 1.6 + Math.random() * 0.6;
        }
      } else {
        if (parts.legL) parts.legL.angle = 0;
        if (parts.legM) parts.legM.angle = 0;
        if (parts.legR) parts.legR.angle = 0;
        if (parts.head) parts.head.angle = Math.sin(k.time() * 1.2) * 3;
        if (stateTimer >= stateDur) {
          goatState = "walk";
          stateTimer = 0;
          stateDur = 2.2 + Math.random() * 0.8;
        }
      }
      const xOff = goatS * 22;
      const yOff = Math.abs(goatS) * 16;
      goat.pos = k.vec2(goatBase.x + xOff, goatBase.y + yOff);
    }
    const theme = window.__theme ?? loadTheme();
    if (theme !== lastTheme) {
      lastTheme = theme;
      const isNight = lastTheme === "night";
      for (const l of layers) {
        if (!l.root) continue;
        l.root.opacity = isNight ? 0.82 : 1;
      }
    }
    for (const l of layers) {
      if (!l.root || !l.root.exists?.()) continue;
      if (autoDrift) {
        const drift = viewW * DRIFT_PX_PER_SEC_BASE * l.parallax * k.dt();
        l.offsetX += drift;
      }
      updateRootPosition(l);
    }
  });
  k.onResize(() => {
    buildAll();
  });
  return {
    regenerate: (newSeed) => buildAll(newSeed),
    setAutoDrift: (enabled) => {
      autoDrift = enabled;
    },
    scrollVertical: (deltaPx, durationSec) => {
      const dur = Math.max(0, durationSec ?? 0);
      for (const l of layers) {
        const target = l.offsetY + deltaPx * l.parallax;
        if (dur <= 0) {
          l.offsetY = target;
          updateRootPosition(l);
        } else {
          const start = l.offsetY;
          k.tween(start, target, dur, (v2) => {
            l.offsetY = v2;
            updateRootPosition(l);
          }, k.easings.easeOutCubic);
        }
      }
    }
  };
}
function createCircleButton(k, label, x, y, radius, z, onClick, opts = {}) {
  const root = k.add([k.pos(x, y), k.anchor("center"), k.z(z)]);
  const baseCol = k.rgb(56, 60, 66);
  const hoverCol = k.rgb(76, 82, 90);
  if (opts.glow) {
    const glow = root.add([k.circle(radius * 1.25), k.color(28, 120, 200), k.opacity(0.22), k.anchor("center")]);
    k.onUpdate(() => {
      const t = k.time();
      glow.opacity = 0.16 + 0.08 * Math.sin(t * 2.2);
      glow.scale = 1 + 0.05 * Math.sin(t * 2.2);
    });
  }
  const ring = root.add([k.circle(radius), k.color(baseCol), k.opacity(opts.opacity ?? 0.85), k.area()]);
  const size = Math.round(radius * 1.05);
  const iconCol = k.rgb(240, 244, 248);
  const shadowCol = k.rgb(20, 24, 28);
  const highlightCol = k.rgb(220, 230, 240);
  const kind = opts.kind ?? (label === "" ? "play" : label === "home" || label === "" ? "home" : "text");
  if (kind === "play") {
    if (opts.embossed) {
      root.add([k.text("", { size, width: radius * 2, align: "center" }), k.pos(1.8, 1.8), k.anchor("center"), k.color(shadowCol)]);
      root.add([k.text("", { size, width: radius * 2, align: "center" }), k.pos(-1.2, -1.2), k.anchor("center"), k.color(highlightCol)]);
    }
    root.add([k.text("", { size, width: radius * 2, align: "center" }), k.anchor("center"), k.color(iconCol)]);
  } else if (kind === "home") {
    const iconR = radius * 0.9;
    const house = root.add([k.pos(0, 0), k.anchor("center")]);
    if (opts.embossed) {
      const shadow = house.add([k.pos(1.6, 1.6), k.anchor("center")]);
      shadow.add([k.rect(iconR * 0.9, iconR * 0.18, { radius: Math.max(1, iconR * 0.08) }), k.pos(-iconR * 0.32, -iconR * 0.25), k.anchor("center"), k.color(shadowCol), k.rotate(-38)]);
      shadow.add([k.rect(iconR * 0.9, iconR * 0.18, { radius: Math.max(1, iconR * 0.08) }), k.pos(iconR * 0.32, -iconR * 0.25), k.anchor("center"), k.color(shadowCol), k.rotate(38)]);
      shadow.add([k.rect(iconR * 1, iconR * 0.72, { radius: Math.max(1, iconR * 0.12) }), k.pos(0, iconR * 0.05), k.anchor("center"), k.color(shadowCol)]);
      shadow.add([k.rect(iconR * 0.26, iconR * 0.42, { radius: Math.max(1, iconR * 0.1) }), k.pos(0, iconR * 0.28), k.anchor("center"), k.color(shadowCol)]);
      const hilite = house.add([k.pos(-1.1, -1.1), k.anchor("center")]);
      hilite.add([k.rect(iconR * 0.9, iconR * 0.18, { radius: Math.max(1, iconR * 0.08) }), k.pos(-iconR * 0.32, -iconR * 0.25), k.anchor("center"), k.color(highlightCol), k.rotate(-38)]);
      hilite.add([k.rect(iconR * 0.9, iconR * 0.18, { radius: Math.max(1, iconR * 0.08) }), k.pos(iconR * 0.32, -iconR * 0.25), k.anchor("center"), k.color(highlightCol), k.rotate(38)]);
      hilite.add([k.rect(iconR * 1, iconR * 0.72, { radius: Math.max(1, iconR * 0.12) }), k.pos(0, iconR * 0.05), k.anchor("center"), k.color(highlightCol)]);
      hilite.add([k.rect(iconR * 0.26, iconR * 0.42, { radius: Math.max(1, iconR * 0.1) }), k.pos(0, iconR * 0.28), k.anchor("center"), k.color(highlightCol)]);
    }
    house.add([k.rect(iconR * 0.9, iconR * 0.18, { radius: Math.max(1, iconR * 0.08) }), k.pos(-iconR * 0.32, -iconR * 0.25), k.anchor("center"), k.color(iconCol), k.rotate(-38)]);
    house.add([k.rect(iconR * 0.9, iconR * 0.18, { radius: Math.max(1, iconR * 0.08) }), k.pos(iconR * 0.32, -iconR * 0.25), k.anchor("center"), k.color(iconCol), k.rotate(38)]);
    house.add([k.rect(iconR * 1, iconR * 0.72, { radius: Math.max(1, iconR * 0.12) }), k.pos(0, iconR * 0.05), k.anchor("center"), k.color(iconCol)]);
    house.add([k.rect(iconR * 0.26, iconR * 0.42, { radius: Math.max(1, iconR * 0.1) }), k.pos(0, iconR * 0.28), k.anchor("center"), k.color(baseCol)]);
  } else {
    if (opts.embossed) {
      root.add([k.text(label, { size, width: radius * 2, align: "center" }), k.pos(1.6, 1.6), k.anchor("center"), k.color(shadowCol)]);
      root.add([k.text(label, { size, width: radius * 2, align: "center" }), k.pos(-1.1, -1.1), k.anchor("center"), k.color(highlightCol)]);
    }
    root.add([k.text(label, { size, width: radius * 2, align: "center" }), k.anchor("center"), k.color(iconCol)]);
  }
  ring.onClick?.(onClick);
  ring.onHover?.(() => {
    ring.color = hoverCol;
  });
  ring.onHoverEnd?.(() => {
    ring.color = baseCol;
  });
  return { root, bg: ring };
}
function createSettingsButton(k, x, y, iconRadius, z, opts = {}) {
  const ringR = iconRadius + 6;
  const baseCol = k.rgb(56, 60, 66);
  const hoverCol = k.rgb(76, 82, 90);
  const iconCol = k.rgb(240, 244, 248);
  const root = k.add([k.pos(x, y), k.anchor("center"), k.z(z)]);
  const bg = root.add([k.circle(ringR), k.color(baseCol), k.opacity(opts.opacity ?? 0.85), k.area()]);
  const gear = root.add([k.pos(0, 0), k.anchor("center")]);
  const iconR = iconRadius * 0.675;
  const numTeeth = 8;
  const outerR = iconR * 0.95;
  const innerR = iconR * 0.7;
  gear.add([k.circle(outerR), k.anchor("center"), k.color(iconCol)]);
  const toothGapW = Math.max(2, iconR * 0.16);
  const toothGapH = (outerR - innerR) * 1.2;
  for (let i2 = 0; i2 < numTeeth; i2++) {
    const angle = i2 / numTeeth * Math.PI * 2 + Math.PI / numTeeth;
    const gapRadius = outerR - toothGapH / 2;
    const x2 = Math.cos(angle) * gapRadius;
    const y2 = Math.sin(angle) * gapRadius;
    gear.add([
      k.rect(toothGapW, toothGapH, { radius: Math.max(1, iconR * 0.02) }),
      k.pos(x2, y2),
      k.anchor("center"),
      k.color(baseCol),
      k.rotate(angle * 180 / Math.PI + 90)
    ]);
  }
  gear.add([k.circle(innerR), k.anchor("center"), k.color(iconCol)]);
  gear.add([k.circle(iconR * 0.32), k.anchor("center"), k.color(baseCol)]);
  let panel = null;
  const showPanel = () => {
    if (panel?.exists?.()) return;
    opts.onOpen?.();
    const viewW = k.width();
    const viewH = k.height();
    const pW = Math.min(380, viewW * 0.9);
    const pH = 220;
    panel = k.add([k.pos(viewW / 2, viewH / 2), k.anchor("center"), k.z(z + 100)]);
    panel.add([k.rect(pW, pH, { radius: 14 }), k.pos(0, 0), k.anchor("center"), k.color(20, 20, 24), k.opacity(0.92)]);
    panel.add([k.text("Settings", { size: 28 }), k.pos(0, -pH / 2 + 26), k.anchor("center"), k.color(255, 255, 255)]);
    const rowY1 = -30;
    const helpBtn = panel.add([k.rect(110, 34, { radius: 8 }), k.pos(0, rowY1), k.anchor("center"), k.color(28, 120, 200), k.area()]);
    helpBtn.add([k.text("Help", { size: 18 }), k.anchor("center"), k.color(255, 255, 255)]);
    helpBtn.onClick?.(() => {
      const msg = opts.helpText ?? "How to Play\n\n- Tap Left/Right (A/D) to climb holds on the matching side.\n- Time bar drains; climb to refill.\n- Avoid wrong holds unless both are shown.\n- Pause top-right; menu via home button.";
      alert(msg);
    });
    const slideW = Math.round(pW / 6);
    const slider = panel.add([k.rect(slideW, 14, { radius: 7 }), k.pos(0, rowY1 + 56), k.anchor("center"), k.color(80, 80, 90)]);
    const knob = slider.add([k.circle(12), k.pos(-(slideW / 2), 0), k.anchor("center"), k.color(240, 244, 248), k.area()]);
    const sunRadius = 14;
    slider.add([k.circle(sunRadius), k.pos(-(slideW / 2 + 43), 0), k.anchor("center"), k.color(255, 210, 60)]);
    const moonRadius = 14;
    const moonRoot = slider.add([k.pos(slideW / 2 + 43, 0), k.anchor("center")]);
    moonRoot.add([k.circle(moonRadius), k.anchor("center"), k.color(220, 230, 255)]);
    moonRoot.add([k.circle(moonRadius), k.pos(6, 0), k.anchor("center"), k.color(20, 20, 24)]);
    const dayTrackCol = k.rgb(120, 180, 255);
    const nightTrackCol = k.rgb(28, 60, 120);
    const setTrack = (t) => {
      slider.color = t === "day" ? dayTrackCol : nightTrackCol;
    };
    const applyTheme = (t) => {
      saveTheme(t);
      setTrack(t);
    };
    const setKnob = (t) => {
      knob.pos.x = t === "day" ? -(slideW / 2) : slideW / 2;
    };
    const cur = window.__theme ?? loadTheme();
    setKnob(cur);
    setTrack(cur);
    knob.onClick?.(() => {
      const curr = window.__theme ?? loadTheme();
      const next = curr === "day" ? "night" : "day";
      setKnob(next);
      applyTheme(next);
    });
    const closeBtn = panel.add([k.rect(100, 34, { radius: 8 }), k.pos(0, pH / 2 - 28), k.anchor("center"), k.color(120, 120, 120), k.area()]);
    closeBtn.add([k.text("Close", { size: 18 }), k.anchor("center"), k.color(20, 20, 20)]);
    closeBtn.onClick?.(() => {
      try {
        panel?.destroy();
      } catch {
      }
      panel = null;
      opts.onClose?.();
    });
  };
  bg.onClick?.(showPanel);
  bg.onHover?.(() => {
    bg.color = hoverCol;
  });
  bg.onHoverEnd?.(() => {
    bg.color = baseCol;
  });
  return { root, open: showPanel };
}
function spawnSmallDeer(k, opts) {
  const s = Math.max(0.2, opts.scale ?? 0.8);
  const z = opts.z ?? -1.46;
  const facing = opts.facing ?? (Math.random() < 0.5 ? 1 : -1);
  const root = k.add([k.pos(opts.x, opts.groundY), k.anchor("bot"), { z }]);
  root.scale = k.vec2(facing, 1);
  let roamMinX = opts.roamMinX ?? opts.x - 40;
  let roamMaxX = opts.roamMaxX ?? opts.x + 40;
  const clamp2 = (n, a, b) => Math.max(a, Math.min(b, n));
  roamMinX = Math.min(roamMinX, roamMaxX);
  roamMaxX = Math.max(roamMinX + 1, roamMaxX);
  let speed = Math.max(1, (opts.speed ?? 16) * s);
  let dir = root.scale.x >= 0 ? 1 : -1;
  let state = Math.random() < 0.6 ? "idle" : "walk";
  let stateTimer = state === "walk" ? 0.8 + Math.random() * 1.2 : 1.5 + Math.random() * 2;
  let stepPhase = Math.random() * Math.PI * 2;
  const brown = k.rgb(152, 108, 72);
  const white = k.rgb(255, 255, 255);
  const bodyW = 24 * s;
  const bodyH = 12 * s;
  const body = root.add([k.rect(bodyW, bodyH, { radius: bodyH * 0.45 }), k.pos(0, -6 * s), k.anchor("center"), k.color(brown)]);
  body.add([k.rect(bodyW * 0.75, bodyH * 0.4, { radius: bodyH * 0.25 }), k.pos(0, bodyH * 0.12), k.anchor("center"), k.color(white)]);
  const neck = root.add([k.rect(6 * s, 8 * s, { radius: 2 * s }), k.pos(bodyW * 0.36, -bodyH - 2 * s), k.anchor("bot"), k.color(brown), k.rotate(-18)]);
  const head = root.add([k.rect(12 * s, 9 * s, { radius: 3 * s }), k.pos(bodyW * 0.52, -bodyH - 9 * s), k.anchor("center"), k.color(brown)]);
  head.add([k.circle(1.4 * s), k.pos(3.8 * s, -1.2 * s), k.anchor("center"), k.color(white)]);
  head.add([k.rect(2.6 * s, 1.6 * s, { radius: 1 * s }), k.pos(5.2 * s, 1.6 * s), k.anchor("center"), k.color(white)]);
  const earL = head.add([k.rect(3.6 * s, 5.4 * s, { radius: 1.4 * s }), k.pos(-3.8 * s, -4.8 * s), k.anchor("center"), k.color(brown), k.rotate(-18)]);
  const earR = head.add([k.rect(3.6 * s, 5.4 * s, { radius: 1.4 * s }), k.pos(-0.8 * s, -5.2 * s), k.anchor("center"), k.color(brown), k.rotate(-6)]);
  const legW = 3.2 * s;
  const legH = 11 * s;
  const hoofH = Math.max(2, 2.2 * s);
  const lf = root.add([k.rect(legW, legH, { radius: legW * 0.5 }), k.pos(bodyW * 0.08, 0), k.anchor("bot"), k.color(brown)]);
  const lr = root.add([k.rect(legW, legH, { radius: legW * 0.5 }), k.pos(-bodyW * 0.28, 0), k.anchor("bot"), k.color(brown)]);
  const lf2 = root.add([k.rect(legW, legH * 0.95, { radius: legW * 0.5 }), k.pos(bodyW * 0.2, 0), k.anchor("bot"), k.color(brown)]);
  const lr2 = root.add([k.rect(legW, legH * 0.95, { radius: legW * 0.5 }), k.pos(-bodyW * 0.4, 0), k.anchor("bot"), k.color(brown)]);
  lf.add([k.rect(legW * 0.9, hoofH, { radius: hoofH * 0.4 }), k.pos(0, 0), k.anchor("bot"), k.color(white)]);
  lr.add([k.rect(legW * 0.9, hoofH, { radius: hoofH * 0.4 }), k.pos(0, 0), k.anchor("bot"), k.color(white)]);
  lf2.add([k.rect(legW * 0.9, hoofH, { radius: hoofH * 0.4 }), k.pos(0, 0), k.anchor("bot"), k.color(white)]);
  lr2.add([k.rect(legW * 0.9, hoofH, { radius: hoofH * 0.4 }), k.pos(0, 0), k.anchor("bot"), k.color(white)]);
  root.add([k.rect(4 * s, 4 * s, { radius: 2 * s }), k.pos(-bodyW * 0.48, -bodyH - 2 * s), k.anchor("center"), k.color(white)]);
  k.onUpdate(() => {
    if (!root.exists()) return;
    const dt = Math.min(0.05, k.dt());
    const t = k.time();
    stateTimer -= dt;
    if (stateTimer <= 0) {
      if (state === "idle") {
        state = Math.random() < 0.4 ? "walk" : "idle";
        stateTimer = state === "walk" ? 0.8 + Math.random() * 1.2 : 1.2 + Math.random() * 1.6;
        const x = root.pos.x;
        const distL = x - roamMinX;
        const distR = roamMaxX - x;
        if (state === "walk") {
          if (distL < 12) dir = 1;
          else if (distR < 12) dir = -1;
          else dir = Math.random() < 0.5 ? 1 : -1;
        }
      } else {
        state = Math.random() < 0.7 ? "idle" : "walk";
        stateTimer = state === "walk" ? 0.6 + Math.random() * 1 : 1.6 + Math.random() * 2.2;
      }
    }
    if (state === "walk") {
      const x0 = root.pos.x;
      const x1 = clamp2(x0 + dir * speed * dt, roamMinX, roamMaxX);
      root.pos.x = x1;
      if (x1 <= roamMinX + 0.5) dir = 1;
      if (x1 >= roamMaxX - 0.5) dir = -1;
      root.scale = k.vec2(dir, 1);
      stepPhase += dt * 8;
    } else {
      stepPhase += dt * 2;
    }
    const baseBob = state === "walk" ? 0.9 * s : 0.6 * s;
    const bob = Math.sin(stepPhase) * baseBob;
    head.pos.y = -bodyH - 9 * s + bob;
    neck.angle = -18 + Math.sin(t * 1.6) * 2;
    earL.angle = -18 + Math.sin(t * 2.1) * 6;
    earR.angle = -6 + Math.sin(t * 2.3 + 0.7) * 6;
    const amp = state === "walk" ? 2 * s : 0.6 * s;
    const swingF = Math.sin(stepPhase) * amp;
    const swingB = Math.sin(stepPhase + Math.PI) * (amp * 0.8);
    lf.pos.y = swingF * 0.5;
    lf2.pos.y = -swingF * 0.5;
    lr.pos.y = swingB * 0.4;
    lr2.pos.y = -swingB * 0.4;
  });
  return {
    root,
    setRoamBounds: (minX, maxX) => {
      roamMinX = Math.min(minX, maxX);
      roamMaxX = Math.max(minX, maxX);
    }
  };
}
function spawnMalteseDog(k, opts) {
  const s = Math.max(0.3, opts.scale);
  const z = opts.z ?? 5.2;
  const bodyW = 26 * s;
  const bodyH = 14 * s;
  const headW = 12 * s;
  const headH = 12 * s;
  const legW = 3.2 * s;
  const legH = 6 * s;
  const root = k.add([k.pos(opts.x, opts.groundY), k.anchor("bot"), { z }]);
  root.add([k.rect(bodyW * 0.9, Math.max(2, bodyH * 0.18), { radius: bodyH * 0.09 }), k.pos(0, -1), k.anchor("bot"), k.color(0, 0, 0), k.opacity(0.15)]);
  const white = k.rgb(245, 245, 245), white2 = k.rgb(255, 255, 255);
  const body = root.add([k.rect(bodyW, bodyH, { radius: bodyH * 0.4 }), k.pos(0, -legH), k.anchor("bot"), k.color(white2)]);
  body.add([k.rect(bodyW * 0.7, bodyH * 0.35, { radius: bodyH * 0.2 }), k.pos(-bodyW * 0.1, -bodyH * 0.5), k.anchor("center"), k.color(255, 255, 255), k.opacity(0.18)]);
  const tail = body.add([k.rect(bodyW * 0.3, bodyH * 0.35, { radius: bodyH * 0.2 }), k.pos(bodyW * 0.52, -bodyH * 0.65), k.anchor("center"), k.color(white), k.rotate(25)]);
  const head = root.add([k.rect(headW, headH, { radius: headH * 0.35 }), k.pos(bodyW * 0.35, -legH - bodyH + 2 * s), k.anchor("center"), k.color(white2)]);
  const earL = head.add([k.rect(headW * 0.35, headH * 0.6, { radius: headH * 0.25 }), k.pos(-headW * 0.55, 0), k.anchor("center"), k.color(white), k.opacity(0.95)]);
  const earR = head.add([k.rect(headW * 0.35, headH * 0.6, { radius: headH * 0.25 }), k.pos(headW * 0.55, 0), k.anchor("center"), k.color(white), k.opacity(0.95)]);
  head.add([k.circle(1.2 * s), k.pos(-headW * 0.18, -headH * 0.05), k.anchor("center"), k.color(30, 30, 30)]);
  head.add([k.circle(1.2 * s), k.pos(headW * 0.18, -headH * 0.05), k.anchor("center"), k.color(30, 30, 30)]);
  head.add([k.rect(2.6 * s, 1.8 * s, { radius: 1 * s }), k.pos(0, headH * 0.08), k.anchor("center"), k.color(40, 40, 40)]);
  const collarColor = k.rgb(160, 200, 120);
  const collarRoot = head.add([k.pos(0, headH * 0.48), k.anchor("center"), k.z(9999)]);
  const outerR = Math.max(4.5 * s, headH * 0.32);
  const innerR = outerR * 0.78;
  const samples = 9;
  for (let i2 = 0; i2 < samples; i2++) {
    const t = i2 / (samples - 1) * Math.PI;
    const x = Math.cos(t) * outerR * 0.9;
    const y = Math.sin(t) * outerR * 0.35;
    collarRoot.add([k.circle(Math.max(2.2 * s, outerR * 0.22)), k.pos(x, y), k.anchor("center"), k.color(collarColor)]);
  }
  const cutColor = white2;
  for (let i2 = 0; i2 < samples; i2++) {
    const t = i2 / (samples - 1) * Math.PI;
    const x = Math.cos(t) * innerR * 0.9;
    const y = Math.sin(t) * innerR * 0.32;
    collarRoot.add([k.circle(Math.max(2 * s, innerR * 0.22)), k.pos(x, y - 0.5 * s), k.anchor("center"), k.color(cutColor)]);
  }
  collarRoot.add([k.rect(outerR * 1.2, Math.max(1.2 * s, 2), { radius: 1 }), k.pos(0, -outerR * 0.08), k.anchor("center"), k.color(255, 255, 255), k.opacity(0.08)]);
  const tongue = head.add([k.rect(2.2 * s, 3.2 * s, { radius: 1 * s }), k.pos(0, headH * 0.24), k.anchor("top"), k.color(240, 120, 140)]);
  tongue.hidden = true;
  const legFL = root.add([k.rect(legW, legH, { radius: legW * 0.5 }), k.pos(bodyW * 0.04, 0), k.anchor("bot"), k.color(white)]);
  const legFR = root.add([k.rect(legW, legH, { radius: legW * 0.5 }), k.pos(bodyW * 0.22, 0), k.anchor("bot"), k.color(white)]);
  const legBL = root.add([k.rect(legW, legH, { radius: legW * 0.5 }), k.pos(-bodyW * 0.42, 0), k.anchor("bot"), k.color(white)]);
  const legBR = root.add([k.rect(legW, legH, { radius: legW * 0.5 }), k.pos(-bodyW * 0.22, 0), k.anchor("bot"), k.color(white)]);
  const baseUpperH = Math.max(1.5 * s, 2);
  const uFL = root.add([k.rect(legW * 1.05, baseUpperH, { radius: legW * 0.5 }), k.pos(legFL.pos.x, body.pos.y), k.anchor("top"), k.color(white), k.opacity(0.98)]);
  const uFR = root.add([k.rect(legW * 1.05, baseUpperH, { radius: legW * 0.5 }), k.pos(legFR.pos.x, body.pos.y), k.anchor("top"), k.color(white), k.opacity(0.98)]);
  const uBL = root.add([k.rect(legW * 1.05, baseUpperH, { radius: legW * 0.5 }), k.pos(legBL.pos.x, body.pos.y), k.anchor("top"), k.color(white), k.opacity(0.98)]);
  const uBR = root.add([k.rect(legW * 1.05, baseUpperH, { radius: legW * 0.5 }), k.pos(legBR.pos.x, body.pos.y), k.anchor("top"), k.color(white), k.opacity(0.98)]);
  const jointR = Math.max(1.6 * s, 2.2 * s);
  const jointYOffset = Math.max(1.2 * s, legH * 0.22);
  const jointColor = k.rgb(235, 235, 235);
  const jFL = root.add([k.circle(jointR), k.pos(legFL.pos.x, -jointYOffset), k.anchor("center"), k.color(jointColor), k.opacity(0.95)]), jFR = root.add([k.circle(jointR), k.pos(legFR.pos.x, -jointYOffset), k.anchor("center"), k.color(jointColor), k.opacity(0.95)]), jBL = root.add([k.circle(jointR), k.pos(legBL.pos.x, -jointYOffset), k.anchor("center"), k.color(jointColor), k.opacity(0.95)]), jBR = root.add([k.circle(jointR), k.pos(legBR.pos.x, -jointYOffset), k.anchor("center"), k.color(jointColor), k.opacity(0.95)]);
  function syncJoints() {
    jFL.pos = k.vec2(legFL.pos.x, legFL.pos.y - jointYOffset);
    jFR.pos = k.vec2(legFR.pos.x, legFR.pos.y - jointYOffset);
    jBL.pos = k.vec2(legBL.pos.x, legBL.pos.y - jointYOffset);
    jBR.pos = k.vec2(legBR.pos.x, legBR.pos.y - jointYOffset);
  }
  function syncUpperLegs() {
    const by = body.pos.y;
    const overlap = 1.2 * s;
    const topY_FL = legFL.pos.y - legH;
    const topY_FR = legFR.pos.y - legH;
    const topY_BL = legBL.pos.y - legH;
    const topY_BR = legBR.pos.y - legH;
    const hFL = Math.max(1, topY_FL - by + overlap);
    const hFR = Math.max(1, topY_FR - by + overlap);
    const hBL = Math.max(1, topY_BL - by + overlap);
    const hBR = Math.max(1, topY_BR - by + overlap);
    uFL.pos = k.vec2(legFL.pos.x, by);
    uFR.pos = k.vec2(legFR.pos.x, by);
    uBL.pos = k.vec2(legBL.pos.x, by);
    uBR.pos = k.vec2(legBR.pos.x, by);
    uFL.scale = k.vec2(1, hFL / baseUpperH);
    uFR.scale = k.vec2(1, hFR / baseUpperH);
    uBL.scale = k.vec2(1, hBL / baseUpperH);
    uBR.scale = k.vec2(1, hBR / baseUpperH);
  }
  const pawLift = root.add([k.rect(legW, legH * 0.9, { radius: legW * 0.5 }), k.pos(bodyW * 0.05, -legH * 0.2), k.anchor("bot"), k.color(white)]);
  pawLift.hidden = true;
  let facingRight = true;
  let roamMinX = Math.min(opts.roamMinX, opts.roamMaxX);
  let roamMaxX = Math.max(opts.roamMinX, opts.roamMaxX);
  let vx = 10 * s;
  let bobPhase = 0;
  let state = "walk";
  let stateTimer = 1 + Math.random() * 2;
  let lickTimer = 0;
  let tongueBurstActive = false;
  let tongueBurstT = 0;
  const tongueBurstDur = 0.35;
  function clamp2(x, a, b) {
    return Math.max(a, Math.min(b, x));
  }
  function enterWalk() {
    state = "walk";
    stateTimer = 0.8 + Math.random() * 1.2;
    tongue.hidden = true;
    pawLift.hidden = true;
  }
  function enterSit() {
    state = "sit";
    stateTimer = 3 + Math.random() * 3;
    lickTimer = 0.2 + Math.random() * 0.5;
    bobPhase = 0;
  }
  function chooseNext() {
    const r = Math.random();
    if (r < 0.72) enterSit();
    else enterWalk();
  }
  function updateWalk(dt) {
    const x = root.pos.x;
    const nearL = x <= roamMinX + 2;
    const nearR = x >= roamMaxX - 2;
    if (nearL) facingRight = true;
    if (nearR) facingRight = false;
    if (Math.random() < 1e-3) facingRight = !facingRight;
    const dir = facingRight ? 1 : -1;
    root.scale = k.vec2(dir, 1);
    root.pos.x = clamp2(x + dir * vx * dt, roamMinX, roamMaxX);
    bobPhase += dt * 8;
    const bob = Math.sin(bobPhase) * 0.8 * s;
    body.pos.y = -legH - bob;
    head.pos.y = -legH - bodyH + 2 * s - bob * 0.6;
    tail.angle = 25 + Math.sin(k.time() * 6) * 10;
    earL.angle = Math.sin(k.time() * 7) * 6;
    earR.angle = -Math.sin(k.time() * 7 + 0.7) * 6;
    const swing = Math.sin(bobPhase) * 2.5 * s;
    legFL.pos.y = swing * 0.6;
    legFR.pos.y = -swing * 0.6;
    legBL.pos.y = -swing * 0.4;
    legBR.pos.y = swing * 0.4;
    syncJoints();
    syncUpperLegs();
  }
  function updateSit(dt) {
    body.pos.y = -legH + 2 * s;
    head.pos.y = -legH - bodyH + 4 * s;
    legFL.pos.y = 2 * s;
    legFR.pos.y = 2 * s;
    legBL.pos.y = 2.5 * s;
    legBR.pos.y = 2.5 * s;
    tail.angle = 35 + Math.sin(k.time() * 4) * 6;
    earL.angle = Math.sin(k.time() * 5) * 4;
    earR.angle = -Math.sin(k.time() * 5 + 0.6) * 4;
    syncJoints();
    syncUpperLegs();
    lickTimer -= dt;
    if (lickTimer <= 0 && !tongueBurstActive) {
      tongue.hidden = false;
      pawLift.hidden = false;
      pawLift.pos = k.vec2(bodyW * 0, -legH * 0.2);
      tongueBurstActive = true;
      tongueBurstT = 0;
      k.wait(tongueBurstDur, () => {
        if (tongue.exists()) tongue.hidden = true;
      });
      k.wait(0.5, () => {
        if (pawLift.exists()) pawLift.hidden = true;
      });
      lickTimer = 0.8 + Math.random() * 1;
    }
  }
  k.onUpdate(() => {
    if (!root.exists()) return;
    const dt = Math.min(0.05, k.dt());
    stateTimer -= dt;
    if (stateTimer <= 0) chooseNext();
    if (state === "walk") updateWalk(dt);
    else updateSit(dt);
    if (tongueBurstActive) {
      tongueBurstT += dt;
      const baseLen = 3.2 * s;
      const longLen = 5.2 * s;
      const u = Math.sin(Math.min(1, tongueBurstT / tongueBurstDur) * Math.PI);
      tongue.pos.y = headH * 0.24 + u * (longLen - baseLen) * 0.6;
      if (tongueBurstT >= tongueBurstDur) {
        tongueBurstActive = false;
      }
    }
  });
  return {
    root,
    setRoamBounds: (minX, maxX) => {
      roamMinX = Math.min(minX, maxX);
      roamMaxX = Math.max(minX, maxX);
      root.pos.x = clamp2(root.pos.x, roamMinX, roamMaxX);
    }
  };
}
function defineGameScene(k) {
  k.scene("game", (mountSeed) => {
    const viewW = k.width();
    const viewH = k.height();
    const wallCenterX = viewW / 2;
    const horizonY = viewH * 0.88 - 8;
    const seed = typeof mountSeed === "number" ? mountSeed : Math.floor(Math.random() * 1e9);
    const mountains = addMountains(k, { horizon: horizonY, seed });
    mountains.setAutoDrift(false);
    spawnBackground(k, k.vec2(viewW, viewH), { treeClip: { centerX: wallCenterX, width: GAME_CONFIG.wall.width }, treeScale: 2, treeDensityMul: 0.5, horizonLevel: horizonY });
    const wallTop = 50;
    const wallBottom = viewH - 40;
    const climberScale = 1.5;
    const segmentH = Math.max(50, Math.floor(viewH / 7));
    const numSegmentsOnScreen = Math.ceil((wallBottom - wallTop) / segmentH) + 2;
    const INDICATOR_Y_RATIO = -0.25;
    const rock = spawnRockWall(k, wallCenterX, viewH, GAME_CONFIG.wall.width, segmentH, seed ^ 2654435761);
    showMobileControls();
    (function addDeer() {
      const treeBaseY = horizonY + 8;
      const zAmongTrees = -1.46;
      const margin = 24;
      const leftX = Math.max(margin, wallCenterX - GAME_CONFIG.wall.width / 2 - 60);
      const rightX = Math.min(viewW - margin, wallCenterX + GAME_CONFIG.wall.width / 2 + 60);
      try {
        spawnSmallDeer(k, { x: leftX, groundY: treeBaseY, z: zAmongTrees, scale: 0.95 * 1.1, facing: 1 });
        spawnSmallDeer(k, { x: rightX, groundY: treeBaseY, z: zAmongTrees, scale: 0.95 * 1.1, facing: -1 });
      } catch {
      }
    })();
    const obstaclesLayer = k.add([k.pos(0, 0), k.z(1)]);
    const rngState = createObstacleState(), initialSegments = seedInitialSegments(numSegmentsOnScreen + 5, rngState.rng);
    let state = { phase: "READY", score: 0, best: loadBest(), timeRemaining: GAME_CONFIG.timeBar.maxSeconds, playerSide: "left", segments: initialSegments, sameSideRun: 0, lastObstacleSide: null, inputLockedUntilMs: 0 };
    const hud = createHud(k);
    hud.setTime(state.timeRemaining);
    hud.setScore(0);
    const baseR = 18 * 1.15 * BUTTON_SCALE * 1.5;
    const pauseCenterX = viewW - UI_MARGIN - baseR;
    const pauseCenterY = UI_MARGIN + baseR;
    const pauseRoot = k.add([k.pos(pauseCenterX, pauseCenterY), k.anchor("center"), k.z(1500)]);
    const baseCol = k.rgb(56, 60, 66);
    const hoverCol = k.rgb(76, 82, 90);
    const ring = pauseRoot.add([k.circle(baseR), k.color(baseCol), k.opacity(0.85), k.area()]);
    const barW = Math.max(3, Math.round(baseR * 0.22));
    const barH = Math.round(baseR * 0.95);
    const gap = Math.round(baseR * 0.22);
    pauseRoot.add([k.rect(barW, barH, { radius: 2 }), k.pos(-gap, 0), k.anchor("center"), k.color(240, 244, 248)]);
    pauseRoot.add([k.rect(barW, barH, { radius: 2 }), k.pos(gap, 0), k.anchor("center"), k.color(240, 244, 248)]);
    ring.onClick?.(() => {
      if (state.phase === "PLAY") setPhase("PAUSED");
    });
    ring.onHover?.(() => {
      ring.color = hoverCol;
    });
    ring.onHoverEnd?.(() => {
      ring.color = baseCol;
    });
    let settingsOpen = false;
    (function setupSettings() {
      const radius = 16 * BUTTON_SCALE * 1.5, ringR = radius + 6;
      const gearCenterX = pauseCenterX - (baseR + ringR + UI_MARGIN) - 10, gearCenterY = UI_MARGIN + ringR;
      createSettingsButton(k, gearCenterX, gearCenterY, radius, 1500, { onOpen: () => {
        settingsOpen = true;
      }, onClose: () => {
        settingsOpen = false;
      } });
    })();
    let resumeBtn = null, menuBtn = null, replayBtn = null, endPanel = null, pauseTitle = null, homeBtn = null;
    function destroyPauseMenu() {
      resumeBtn?.root?.destroy();
      menuBtn?.root?.destroy();
      replayBtn?.root?.destroy();
      pauseTitle?.destroy();
      endPanel?.destroy();
      endPanel = null;
      resumeBtn = null;
      menuBtn = null;
      replayBtn = null;
      pauseTitle = null;
    }
    const GLOBAL_Y_OFFSET = -viewH * 0.05;
    const climberBaseY = wallBottom - segmentH * 1.2 + GLOBAL_Y_OFFSET;
    const climber = spawnClimber(k, wallCenterX, climberBaseY, climberScale, { showPouch: true });
    climber.root.pos.x = wallCenterX;
    function addHoldFromSpec(x, y, spec, z = 1.2) {
      const baseCol2 = k.rgb(32, 34, 36);
      const hiCol = k.rgb(96, 100, 106);
      const root = obstaclesLayer.add([k.pos(x, y), k.anchor("center"), k.z(z)]);
      if (spec.kind === "rect") {
        const w = Math.max(4, Math.round((spec.w ?? 12) * HOLD_SIZE_SCALE));
        const h = Math.max(3, Math.round((spec.h ?? 6) * HOLD_SIZE_SCALE));
        const radius = Math.max(1, Math.round(Math.min(w, h) * 0.25));
        const body = root.add([k.rect(w, h, { radius }), k.pos(0, 0), k.anchor("center"), k.color(baseCol2)]);
        body.angle = spec.rotDeg ?? 0;
        const chipW = Math.max(2, Math.round(w * 0.35));
        const chipH = Math.max(1, Math.round(h * 0.2));
        const chip = root.add([k.rect(chipW, chipH, { radius: Math.max(1, Math.floor(radius * 0.5)) }), k.pos(-w * 0.22, -h * 0.22), k.anchor("center"), k.color(hiCol), k.opacity(0.16)]);
        chip.angle = (spec.rotDeg ?? 0) * 0.5;
      } else {
        const r = Math.max(3, Math.round((spec.r ?? 6) * HOLD_SIZE_SCALE));
        let x2 = Math.floor((spec.r ?? 0) * 9973 + (spec.offsetX ?? 0) * 6151 + (spec.offsetYRatio ?? 0) * 7919 + (spec.rotDeg ?? 0) * 104729) | 0 || 123456789;
        const rng2 = () => {
          x2 ^= x2 << 13;
          x2 ^= x2 >>> 17;
          x2 ^= x2 << 5;
          return (x2 >>> 0) % 1e5 / 1e5;
        };
        const coreR = Math.max(2, Math.round(r * (0.75 + rng2() * 0.1)));
        root.add([k.circle(coreR), k.anchor("center"), k.color(baseCol2)]);
        const lumps = 5 + Math.floor(rng2() * 3);
        for (let i2 = 0; i2 < lumps; i2++) {
          const ang = rng2() * Math.PI * 2;
          const dist = r * (0.18 + rng2() * 0.35);
          const ox = Math.cos(ang) * dist;
          const oy = Math.sin(ang) * dist;
          const mul = 0.5 + rng2() * 0.55;
          const br2 = Math.max(2, Math.round(r * mul * 0.55));
          root.add([k.circle(br2), k.pos(ox, oy), k.anchor("center"), k.color(baseCol2)]);
        }
        const hi = root.add([k.circle(Math.max(1, Math.round(r * 0.55))), k.pos(-r * 0.28, -r * 0.32), k.anchor("center"), k.color(hiCol), k.opacity(0.12)]);
        hi.angle = 0;
      }
      return root;
    }
    const segmentNodes = [];
    function drawSegments() {
      for (const n of segmentNodes) n.destroy();
      segmentNodes.length = 0;
      for (let i2 = 0; i2 < numSegmentsOnScreen + 2; i2++) {
        const seg = state.segments[i2];
        if (!seg || !seg.side) continue;
        const baseY = wallBottom - i2 * segmentH - segmentH / 2;
        let yPos = baseY + INDICATOR_Y_RATIO * segmentH + GLOBAL_Y_OFFSET + HOLD_Y_OFFSET_PX;
        const ensureHold = (side) => {
          seg.holds = seg.holds ?? {};
          const spec = seg.holds[side] ?? generateHoldSpec(rngState.rng);
          seg.holds[side] = spec;
          return spec;
        };
        const placeFromSpec = (spec, side) => {
          const laneX = rock.laneXAt(yPos, side);
          const x = laneX + (spec.offsetX ?? 0);
          const yy = yPos + (spec.offsetYRatio ?? 0) * segmentH;
          return addHoldFromSpec(x, yy, spec, 1.2);
        };
        const dual = seg.eitherAllowed === true;
        if (dual) {
          const specL = ensureHold("left");
          const specR = ensureHold("right");
          const cL = placeFromSpec(specL, "left");
          const cR = placeFromSpec(specR, "right");
          segmentNodes.push(cL, cR);
        } else {
          const spec = ensureHold(seg.side);
          const c = placeFromSpec(spec, seg.side);
          segmentNodes.push(c);
        }
      }
    }
    drawSegments();
    function getTargetY() {
      const s = climber.scale ?? 1;
      const reachTarget = climber.headRadius * 2;
      const armBase = 18 * s;
      const holdOffset = armBase + reachTarget * 0.9;
      return climber.root.pos.y - holdOffset;
    }
    function getNextSegmentIndex() {
      const targetY = getTargetY();
      let bestIdx = 0;
      let bestDelta = Number.POSITIVE_INFINITY;
      for (let i2 = 0; i2 < state.segments.length; i2++) {
        const seg = state.segments[i2];
        if (!seg || !seg.side) continue;
        const baseY = wallBottom - i2 * segmentH - segmentH / 2;
        const yPos = baseY + INDICATOR_Y_RATIO * segmentH + GLOBAL_Y_OFFSET + HOLD_Y_OFFSET_PX;
        const delta = targetY - yPos;
        if (delta > 0 && delta < bestDelta) {
          bestDelta = delta;
          bestIdx = i2;
        }
      }
      return bestIdx;
    }
    const overlay = k.add([k.rect(viewW, viewH), k.pos(0, 0), k.color(0, 0, 0), k.opacity(0.25), k.z(3e3)]);
    overlay.hidden = true;
    const overlayText = k.add([k.text("", { size: 24, width: viewW - 40, align: "center" }), k.pos(viewW / 2, viewH / 2), k.anchor("center"), k.z(3002), k.color(255, 255, 255)]);
    overlayText.hidden = true;
    let startPanel = null;
    function setPhase(phase, reason) {
      state.phase = phase;
      if (phase === "READY") {
        overlay.hidden = true;
        overlayText.hidden = true;
        startPanel?.destroy();
        const padX = 18, padY = 14;
        const msg = "Press Left or Right to Start\n\n- Tap Left/Right (A/D) to climb to the matching side.\n- The time bar drains; climb to refill.\n- Avoid wrong holds unless both sides are shown.";
        const textObj = k.add([k.text(msg, { size: 22, width: Math.min(520, viewW * 0.8), align: "center" }), k.pos(viewW / 2, viewH / 2), k.anchor("center"), k.z(3002), k.color(255, 255, 255)]);
        const w = Math.max(260, textObj.width + padX * 2);
        const h = Math.max(120, (textObj.height ?? 24) + padY * 2);
        startPanel = k.add([k.pos(viewW / 2, viewH / 2), k.anchor("center"), k.z(3001)]);
        const panelBg = startPanel.add([k.rect(w, h, { radius: 12 }), k.color(20, 20, 24), k.opacity(0.8)]);
        startPanel.add([k.rect(w * 1.04, h * 1.2, { radius: 16 }), k.color(28, 120, 200), k.opacity(0.12)]);
        k.onUpdate(() => {
          if (!startPanel.exists?.()) return;
          const s = 1 + Math.sin(k.time() * 1.5) * 0.01;
          panelBg.scale = s;
        });
        startPanel._textRef = textObj;
        showMobileControls();
        endPanel?.destroy();
        endPanel = null;
        homeBtn?.root?.destroy();
        homeBtn = null;
      } else if (phase === "PLAY") {
        overlay.hidden = true;
        overlayText.hidden = true;
        startPanel?.destroy();
        try {
          startPanel?._textRef?.destroy?.();
        } catch {
        }
        startPanel = null;
        destroyPauseMenu();
        climber.facingWall = true;
        showMobileControls();
        endPanel?.destroy();
        endPanel = null;
        homeBtn?.root?.destroy();
        homeBtn = null;
      } else if (phase === "OVER") {
        overlay.hidden = false;
        overlayText.hidden = false;
        const best = Math.max(state.best, state.score);
        if (best !== state.best) {
          state.best = best;
          saveBest(best);
        }
        const wrong = reason && reason.toLowerCase().includes("wrong") ? "Wrong beta!\nBut I'm not tryna spray you..." : reason ?? "Pumped out!";
        overlayText.text = `${wrong}
Score ${state.score}    Best ${state.best}
Press Space/Enter to Replay`;
        const uiScale = GAME_CONFIG.uiScale;
        const padX = Math.round(16 * uiScale);
        const padY = Math.round(12 * uiScale);
        const maxBoxW = Math.min(viewW * 0.9, 560);
        overlayText.width = Math.max(240, maxBoxW - padX * 2);
        overlayText.pos = k.vec2(viewW / 2, viewH / 2 + 40);
        const textSize = 24;
        const lines = String(overlayText.text || "").split("\n").length;
        const approxLineHeight = Math.round(textSize * 1.35);
        const contentH = lines * approxLineHeight;
        const boxW = Math.max(260, overlayText.width + padX * 2);
        const boxH = Math.min(viewH * 0.7, contentH + padY * 2);
        endPanel?.destroy();
        endPanel = k.add([k.pos(viewW / 2 - 245, viewH / 2 - 35), k.anchor("center"), k.z(3001)]);
        endPanel.add([k.rect(boxW, boxH, { radius: 12 }), k.color(20, 20, 24), k.opacity(0.55)]);
        try {
          const jumpDur = 0.22;
          const shakeStep = 0.06;
          const shakeCycles = 4;
          const fallDur = 0.7;
          const y0 = climber.root.pos.y;
          const x0 = climber.root.pos.x;
          const a0 = climber.body.angle ?? 0;
          const jumpH = Math.min(60, Math.max(36, k.height() * 0.06));
          k.tween(y0, y0 - jumpH, jumpDur, (v2) => {
            if (state.phase !== "OVER") return;
            climber.root.pos.y = v2;
          }, k.easings.easeOutCubic);
          k.tween(a0, a0 - 8, jumpDur * 0.9, (v2) => {
            if (state.phase !== "OVER") return;
            climber.body.angle = v2;
          }, k.easings.easeOutCubic).then?.(() => {
            if (state.phase !== "OVER") return;
            for (let i2 = 0; i2 < shakeCycles * 2; i2++) {
              const dir = i2 % 2 === 0 ? 1 : -1;
              k.wait(i2 * shakeStep, () => {
                if (state.phase !== "OVER") return;
                const targetX = x0 + dir * 6;
                const fromA = climber.body.angle ?? 0;
                k.tween(climber.root.pos.x, targetX, shakeStep, (v2) => {
                  if (state.phase !== "OVER") return;
                  climber.root.pos.x = v2;
                }, k.easings.easeInOutSine);
                const half = shakeStep * 0.5;
                const targetA1 = a0 + dir * 7;
                const targetA2 = a0 - dir * 7;
                const twA1 = k.tween(fromA, targetA1, half, (v2) => {
                  if (state.phase !== "OVER") return;
                  climber.body.angle = v2;
                }, k.easings.easeInOutSine);
                twA1.then?.(() => {
                  if (state.phase !== "OVER") return;
                  const curA = climber.body.angle ?? targetA1;
                  k.tween(curA, targetA2, half, (v2) => {
                    if (state.phase !== "OVER") return;
                    climber.body.angle = v2;
                  }, k.easings.easeInOutSine);
                });
              });
            }
            const afterShake = shakeStep * shakeCycles * 2 + 0.02;
            k.wait(afterShake, () => {
              if (state.phase !== "OVER") return;
              const yNow = climber.root.pos.y;
              const xNow = climber.root.pos.x;
              const rotFrom = climber.body.angle ?? 0;
              const rotTo = rotFrom + (Math.random() < 0.5 ? -35 : 35);
              const yOff = k.height() + 120;
              const xDrift = xNow + (Math.random() < 0.5 ? -1 : 1) * 40;
              k.tween(rotFrom, rotTo, fallDur, (v2) => {
                if (state.phase !== "OVER") return;
                climber.body.angle = v2;
              }, k.easings.easeInCubic);
              k.tween(yNow, yOff, fallDur, (v2) => {
                if (state.phase !== "OVER") return;
                climber.root.pos.y = v2;
              }, k.easings.easeInCubic);
              k.tween(xNow, xDrift, fallDur, (v2) => {
                if (state.phase !== "OVER") return;
                climber.root.pos.x = v2;
              }, k.easings.easeInOutSine);
            });
          });
        } catch {
        }
        replayBtn?.root?.destroy();
        replayBtn = null;
        const restartR = 48;
        const homeR = 48;
        const spacing = 36;
        const panelCenterY = viewH / 2 - 35;
        const buttonsY = panelCenterY + boxH / 2 + 24 + Math.max(restartR, homeR) + 60;
        const sep = restartR + homeR + spacing;
        const xRestart = viewW / 2 - sep / 2;
        const xHome = viewW / 2 + sep / 2;
        replayBtn = createCircleButton(k, "", xRestart, buttonsY, restartR, 3100, () => handleStart(), { embossed: true, kind: "text" });
        homeBtn?.root?.destroy();
        homeBtn = createCircleButton(k, "home", xHome, buttonsY, homeR, 3100, () => k.go("menu"), { embossed: true, kind: "home" });
        showMobileControls();
      } else if (phase === "PAUSED") {
        overlay.hidden = false;
        overlayText.hidden = true;
        showPauseMenu();
        hideMobileControls();
        endPanel?.destroy();
        endPanel = null;
        startPanel?.destroy();
        try {
          startPanel?._textRef?.destroy?.();
        } catch {
        }
        startPanel = null;
        homeBtn?.root?.destroy();
        homeBtn = null;
      }
    }
    const onVis = () => {
      if (document.hidden) {
        if (state.phase === "PLAY") setPhase("PAUSED");
      }
    };
    document.addEventListener("visibilitychange", onVis, { passive: true });
    function refillTime() {
      state.timeRemaining = Math.min(GAME_CONFIG.timeBar.maxSeconds, state.timeRemaining + GAME_CONFIG.timeBar.refillOnStepSeconds);
      hud.setTime(state.timeRemaining);
    }
    let isScrolling = false;
    function scrollUp() {
      if (isScrolling) return;
      isScrolling = true;
      const duration = 0.15;
      const startY = obstaclesLayer.pos.y;
      const tw = k.tween(startY, startY + segmentH, duration, (v2) => obstaclesLayer.pos.y = v2, k.easings.linear);
      rock.scrollOnce(duration);
      tw.then?.(() => {
        obstaclesLayer.pos.y = 0;
        state.segments.shift();
        const n = nextObstacle(state.score, state.lastObstacleSide, state.sameSideRun, rngState.rng);
        state.segments.push({ side: n.side, eitherAllowed: n.eitherAllowed });
        state.lastObstacleSide = n.newLast;
        state.sameSideRun = n.newRun;
        drawSegments();
        isScrolling = false;
      });
    }
    function handleMove(side) {
      if (settingsOpen) return;
      if (state.phase === "READY") {
        state.score = 0;
        state.timeRemaining = GAME_CONFIG.timeBar.maxSeconds;
        state.playerSide = "left";
        state.segments = seedInitialSegments(numSegmentsOnScreen + 5, rngState.rng);
        state.sameSideRun = 0;
        state.lastObstacleSide = null;
        hud.setScore(0);
        hud.setTime(state.timeRemaining);
        drawSegments();
        setPhase("PLAY");
        climber.facingWall = false;
      }
      if (state.phase !== "PLAY" || isScrolling) return;
      const now = performance.now();
      if (now < state.inputLockedUntilMs) return;
      state.inputLockedUntilMs = now + GAME_CONFIG.inputLockMs;
      const nextSeg = state.segments[getNextSegmentIndex()];
      const dual = nextSeg && nextSeg.eitherAllowed === true;
      if (nextSeg && !dual && nextSeg.side !== side) {
        setPhase("OVER", `Wrong hold  use ${nextSeg.side}!`);
        return;
      }
      state.playerSide = side;
      climber.facingWall = true;
      reachToSide(k, climber, side);
      state.score += 1;
      hud.setScore(state.score);
      refillTime();
      mountains.scrollVertical(viewH * 15e-4, 0.125);
      if (navigator.vibrate) navigator.vibrate(15);
      scrollUp();
    }
    function handleStart() {
      if (settingsOpen) return;
      if (state.phase === "OVER") {
        state.score = 0;
        state.timeRemaining = GAME_CONFIG.timeBar.maxSeconds;
        state.playerSide = "left";
        state.segments = seedInitialSegments(numSegmentsOnScreen + 5, rngState.rng);
        state.sameSideRun = 0;
        state.lastObstacleSide = null;
        hud.setScore(0);
        hud.setTime(state.timeRemaining);
        drawSegments();
        climber.root.pos.y = climberBaseY;
        climber.root.pos.x = wallCenterX;
        climber.body.angle = 0;
        setPhase("PLAY");
        climber.facingWall = false;
      }
    }
    const detachInput = setupInput(k, { onMove: handleMove, onStart: handleStart });
    k.onClick(() => {
      if (state.phase === "READY") {
        handleStart();
        const mx = k.getCursor?.pos?.x ?? k.mousePos?.().x;
        if (typeof mx === "number") handleMove(mx < viewW / 2 ? "left" : "right");
      }
    });
    k.onUpdate(() => {
      if (state.phase !== "PLAY" || settingsOpen) return;
      const dt = Math.min(GAME_CONFIG.maxDtSeconds, k.dt());
      let drain = dt;
      const rampSlope = GAME_CONFIG.difficulty.rampSlope;
      const rampMax = GAME_CONFIG.difficulty.rampMax;
      const maxDrainMul = GAME_CONFIG.difficulty.maxDrainMultiplier;
      const ramp = Math.min(rampMax, rampSlope * state.score);
      drain *= 1 + ramp;
      drain = Math.min(drain, dt * maxDrainMul);
      state.timeRemaining -= drain;
      hud.setTime(state.timeRemaining);
      if (state.timeRemaining <= 0) setPhase("OVER", "Pumped out!");
    });
    function showPauseMenu() {
      if (resumeBtn) return;
      pauseTitle = k.add([k.text("Paused", { size: 60 }), k.pos(viewW / 2, viewH / 2 - 150), k.anchor("center"), k.color(255, 255, 255), k.z(2100)]);
      const rPlay = 48;
      const rHome = 48;
      const centerY = viewH / 2;
      const gap2 = 28;
      const yResume = centerY - (rPlay + gap2 / 2);
      const yMenu = centerY + (rHome + gap2 / 2);
      resumeBtn = createCircleButton(k, "", viewW / 2, yResume, rPlay, 2100, () => setPhase("PLAY"), { embossed: true, kind: "play" });
      menuBtn = createCircleButton(k, "home", viewW / 2, yMenu, rHome, 2100, () => k.go("menu"), { embossed: true, kind: "home" });
    }
    k.onSceneLeave(() => {
      detachInput();
      hideMobileControls();
    });
  });
}
function defineMenuScene(k) {
  k.scene("menu", () => {
    hideMobileControls();
    const viewW = k.width();
    const viewH = k.height();
    const wallCenterX = viewW / 2;
    const horizonY = viewH * 0.88 - 8;
    const mountSeed = Math.floor(Math.random() * 1e9);
    {
      const mountains = addMountains(k, { horizon: horizonY, seed: mountSeed });
      mountains.setAutoDrift(false);
    }
    spawnBackground(k, k.vec2(viewW, viewH), {
      treeClip: { centerX: wallCenterX, width: GAME_CONFIG.wall.width },
      treeScale: 1.35,
      treeDensityMul: 0.35,
      horizonLevel: horizonY,
      trunkHeightMul: 1.4
    });
    (function addExtraTrees() {
      const treeBaseY = horizonY + 8;
      const wallMinX = wallCenterX - GAME_CONFIG.wall.width / 2;
      const wallMaxX = wallCenterX + GAME_CONFIG.wall.width / 2;
      const leftRange = { min: 10, max: Math.max(20, wallMinX - 12) };
      const rightRange = { min: Math.min(viewW - 20, wallMaxX + 12), max: viewW - 10 };
      const green = (i2) => k.rgb(44 + i2 * 6, 118 + i2 * 4, 82);
      function addExtraTree(x2, scale, variant, heightMul = 1) {
        k.add([
          k.rect(5 * scale, 18 * scale * heightMul, { radius: 2 }),
          k.pos(x2, treeBaseY),
          k.anchor("bot"),
          k.color(84, 60, 44),
          { z: -1.5 }
        ]);
        if (variant === "round") {
          const blobCount = 3 + Math.floor(Math.random() * 3);
          const baseR = 10 * scale * (0.9 + 0.4 * (heightMul - 1));
          for (let i2 = 0; i2 < blobCount; i2++) {
            const r = baseR * (0.85 + Math.random() * 0.5);
            const ox = (Math.random() * 14 - 7) * scale;
            const oy = 18 * scale * heightMul + (Math.random() * 6 - 8) * scale;
            k.add([
              k.circle(r),
              k.pos(x2 + ox, treeBaseY - oy),
              k.anchor("center"),
              k.color(green(i2)),
              { z: -1.45 }
            ]);
          }
          k.add([
            k.circle(Math.max(1, baseR * 0.5)),
            k.pos(x2 + 6 * scale, treeBaseY - (18 * scale * heightMul + 6 * scale)),
            k.anchor("center"),
            k.color(255, 255, 255),
            k.opacity(0.06),
            { z: -1.44 }
          ]);
        } else {
          const stripes = 5;
          for (let sIdx = 0; sIdx < stripes; sIdx++) {
            const frac = (sIdx + 1) / stripes;
            const wobble = Math.sin(frac * Math.PI) * 2 * scale;
            const w = 20 * scale * (0.4 + frac * 0.75);
            const h = 5 * scale * heightMul;
            const y = treeBaseY - 18 * scale * heightMul - sIdx * h + 2 * scale;
            k.add([
              k.rect(w, h, { radius: 3 }),
              k.pos(x2 + wobble * (Math.random() - 0.5), y),
              k.anchor("center"),
              k.color(green(sIdx)),
              { z: -1.45 }
            ]);
          }
        }
      }
      function sampleXs(min, max, count) {
        const out = [];
        if (max - min < 10 || count <= 0) return out;
        const step = (max - min) / (count + 1);
        for (let i2 = 1; i2 <= count; i2++) {
          const base = min + i2 * step;
          out.push(base + (Math.random() * 2 - 1) * step * 0.35);
        }
        return out;
      }
      const xsLeft = sampleXs(leftRange.min, leftRange.max, 2);
      const xsRight = sampleXs(rightRange.min, rightRange.max, 3);
      const xs = [...xsLeft, ...xsRight].slice(0, 5);
      const variants = ["round", "cone", "round", "cone", "round"];
      for (let i2 = 0; i2 < xs.length; i2++) {
        const x2 = xs[i2];
        const sc = (Math.random() * 0.5 + 1.1) * 1;
        const hMul = 0.9 + Math.random() * 0.6;
        addExtraTree(x2, sc, variants[i2 % variants.length], hMul);
      }
    })();
    const bandH = Math.floor(viewH / 7);
    spawnRockWall(k, wallCenterX, viewH, GAME_CONFIG.wall.width, bandH);
    const startScale = 1.8 * 1.1 * 1.3, s = startScale;
    const bodyH = 30 * s;
    const footStack = bodyH / 2 + 34 * s;
    const platformTopY = viewH - 110;
    const heroBaseY = platformTopY - footStack;
    const hero = spawnClimber(k, wallCenterX, heroBaseY, startScale, { showRope: false });
    try {
      hero.hair.z = 12;
    } catch {
    }
    const sprayCans = [];
    (function placeSprayCansOnFloor() {
      const canZ = 5.5;
      const scaleFloor = 14 * s / 22;
      const offsets = [-60 * s, -45 * s];
      for (const off of offsets) {
        const wrapper = k.add([k.pos(wallCenterX + off, platformTopY), k.anchor("bot"), { z: canZ, _isCan: true }]);
        spawnSprayCan(k, wrapper, 0, -18.018, "right", scaleFloor, canZ + 0.01, { bodyColor: k.rgb(28, 120, 200) });
        sprayCans.push(wrapper);
      }
    })();
    function pickupAndSpray() {
      if (!sprayCans.length) return;
      isActing = true;
      const hx = hero.root.pos.x;
      let nearest = sprayCans[0];
      let best = Math.abs(hx - nearest.pos.x);
      for (const c of sprayCans) {
        const d = Math.abs(hx - c.pos.x);
        if (d < best) {
          nearest = c;
          best = d;
        }
      }
      nearest.hidden = true;
      const arm = hero.armRight;
      const canZ = 12.6;
      const bodyH2 = 14 * s;
      const handY = -28 * s;
      const tempRoot = arm.add([k.pos(0, handY), k.anchor("top"), { z: canZ }]);
      k.onUpdate(() => {
        const breathe = Math.sin(Math.PI * k.time());
        const breathOffset = breathe * 2 * 1.1;
        const rp = hero.root.pos;
        const armsBaseY = rp.y + breathOffset - bodyH2 / 2 - 18;
        hero.armLeft.pos.y = armsBaseY - (hero.armReachLeft ?? 0);
        hero.armRight.pos.y = armsBaseY - (hero.armReachRight ?? 0);
      });
      const scaleHand = 14 * s / 22;
      const halfHHand = 22 * scaleHand / 2;
      const canRoot = spawnSprayCan(k, tempRoot, 0, halfHHand, "right", scaleHand, canZ + 0.01, { bodyColor: k.rgb(28, 120, 200) });
      const uprightStrength = 0.9;
      k.onUpdate(() => {
        if (!canRoot.exists?.() || !tempRoot.exists?.()) return;
        const a = arm.angle ?? 0;
        canRoot.angle = -a * uprightStrength;
      });
      const nozzleAnchor = canRoot._nozzleAnchor;
      const tiltFrom = arm.angle ?? 170;
      const tiltTo = 140;
      k.tween(tiltFrom, tiltTo, 0.8, (v2) => arm.angle = v2, easings.easeOutCubic).then?.(() => {
        const emitBurst = () => {
          const burstCount = 10;
          for (let i2 = 0; i2 < burstCount; i2++) {
            const speed = 90 + Math.random() * 90;
            const life = 1 + Math.random() * 0.6;
            const aDeg = canRoot.angle ?? 0;
            const aRad = aDeg * Math.PI / 180;
            const lx = nozzleAnchor.pos.x;
            const ly = nozzleAnchor.pos.y;
            const cx = canRoot.pos.x;
            const cy = canRoot.pos.y;
            const wx = cx + lx * Math.cos(aRad) - ly * Math.sin(aRad);
            const wy = cy + lx * Math.sin(aRad) + ly * Math.cos(aRad);
            const len = Math.max(1e-3, Math.hypot(lx, ly));
            const uxLocal = lx / len;
            const uyLocal = ly / len;
            let ux = uxLocal * Math.cos(aRad) - uyLocal * Math.sin(aRad);
            let uy = uxLocal * Math.sin(aRad) + uyLocal * Math.cos(aRad);
            const biasRad = 50 * Math.PI / 180;
            const jitterRad = (Math.random() * 16 - 8) * Math.PI / 180 + biasRad;
            const cosj = Math.cos(jitterRad), sinj = Math.sin(jitterRad);
            const jx = ux * cosj - uy * sinj;
            const jy = ux * sinj + uy * cosj;
            const p = tempRoot.add([
              k.rect(3, 2, { radius: 1 }),
              k.pos(wx, wy),
              k.anchor("center"),
              k.color(240, 244, 248),
              k.opacity(0.9),
              { vx: jx * speed, vy: jy * speed, t: 0, life }
            ]);
            k.onUpdate(() => {
              if (!p.exists()) return;
              p.t += k.dt();
              p.pos.x += p.vx * k.dt();
              p.pos.y += p.vy * k.dt();
              p.opacity = Math.max(0, 0.9 * (1 - p.t / life));
              if (p.t >= life) p.destroy();
            });
          }
        };
        const sprayWindow = 1.4;
        for (let a = 0; a <= sprayWindow; a += 0.2) {
          k.wait(a, emitBurst);
        }
        k.wait(sprayWindow, () => {
          k.tween(arm.angle ?? tiltTo, 170, 0.8, (v2) => arm.angle = v2, easings.easeInCubic).then?.(() => {
            tempRoot.destroy();
            nearest.hidden = false;
            isActing = false;
            scheduleNext();
          });
        });
      });
    }
    let isActing = false;
    let cooldown = 1.5 + Math.random() * 1.5;
    const scheduleNext = () => {
      cooldown = 2 + Math.random() * 3;
    };
    const easings = k.easings;
    const neutralPose = () => {
      const rp = hero.root.pos;
      const armsBaseY = rp.y - bodyH / 2 + 2 * s;
      hero.armLeft.pos = k.vec2(rp.x - 11 * s, armsBaseY);
      hero.armRight.pos = k.vec2(rp.x + 11 * s, armsBaseY);
      hero.armLeft.angle = 190;
      hero.armRight.angle = 170;
      hero.head.angle = 0;
      hero.hair.angle = 0;
      hero.body.angle = 0;
    };
    function waveOnce(side) {
      isActing = true;
      const arm = side === "left" ? hero.armLeft : hero.armRight;
      const rp = hero.root.pos;
      const yBase = rp.y - bodyH / 2 + 4 * s;
      const xOff = side === "left" ? -11 * s : 11 * s;
      const raiseA = side === "left" ? -20 : 20;
      const highA = side === "left" ? -50 : 50;
      hero[side === "left" ? "armLeft" : "armRight"].pos = k.vec2(rp.x + xOff, yBase - 6 * s);
      const fromA = arm.angle ?? (side === "left" ? 190 : 170);
      const tw1 = k.tween(fromA, raiseA, 0.18, (v2) => arm.angle = v2, easings.easeOutCubic);
      tw1.then?.(() => {
        const tw2 = k.tween(arm.angle ?? raiseA, highA, 0.16, (v2) => arm.angle = v2, easings.easeInOutSine);
        tw2.then?.(() => {
          const tw3 = k.tween(arm.angle ?? highA, raiseA, 0.16, (v2) => arm.angle = v2, easings.easeInOutSine);
          tw3.then?.(() => {
            const tw4 = k.tween(arm.angle ?? raiseA, side === "left" ? 190 : 170, 0.18, (v2) => arm.angle = v2, easings.easeInCubic);
            tw4.then?.(() => {
              isActing = false;
              scheduleNext();
            });
          });
        });
      });
    }
    function stepSide(dir) {
      isActing = true;
      const x0 = hero.root.pos.x;
      const x1 = x0 + dir * 18 * s;
      const half = 0.34;
      const tw = k.tween(x0, x1, half, (v2) => hero.root.pos.x = v2, easings.easeInOutSine);
      tw.then?.(() => {
        k.tween(x1, x0, half, (v2) => hero.root.pos.x = v2, easings.easeInOutSine).then?.(() => {
          isActing = false;
          scheduleNext();
        });
      });
      const angL0 = hero.legLeft.angle ?? 0;
      const angR0 = hero.legRight.angle ?? 0;
      const swing = 12 * dir;
      const swingBack = -12 * dir;
      k.tween(angL0, swing, half, (v2) => hero.legLeft.angle = v2, easings.easeInOutSine).then?.(() => {
        k.tween(hero.legLeft.angle ?? swing, 0, half, (v2) => hero.legLeft.angle = v2, easings.easeInOutSine);
      });
      k.tween(angR0, swingBack, half, (v2) => hero.legRight.angle = v2, easings.easeInOutSine).then?.(() => {
        k.tween(hero.legRight.angle ?? swingBack, 0, half, (v2) => hero.legRight.angle = v2, easings.easeInOutSine);
      });
    }
    function adjustLegs() {
      isActing = true;
      const l0 = hero.legLeft.angle ?? 0;
      const r0 = hero.legRight.angle ?? 0;
      const twA = k.tween(l0, l0 + 8, 0.18, (v2) => hero.legLeft.angle = v2, easings.easeOutSine);
      const twB = k.tween(r0, r0 - 8, 0.18, (v2) => hero.legRight.angle = v2, easings.easeOutSine);
      twA.then?.(() => {
        k.tween(hero.legLeft.angle ?? 0, 0, 0.22, (v2) => hero.legLeft.angle = v2, easings.easeInOutSine);
      });
      twB.then?.(() => {
        k.tween(hero.legRight.angle ?? 0, 0, 0.22, (v2) => hero.legRight.angle = v2, easings.easeInOutSine).then?.(() => {
          isActing = false;
          scheduleNext();
        });
      });
    }
    function maybeDoIdleAction(dt) {
      if (isActing) return;
      cooldown -= dt;
      if (cooldown > 0) return;
      const r = Math.random();
      if (r < 0.35) waveOnce(Math.random() < 0.5 ? "right" : "left");
      else if (r < 0.6) stepSide(Math.random() < 0.5 ? -1 : 1);
      else if (r < 0.8) adjustLegs();
      else pickupAndSpray();
    }
    k.onUpdate(() => {
      if (!isActing) neutralPose();
      maybeDoIdleAction(k.dt());
      const rp = hero.root.pos;
      const legTopL = { x: rp.x - 7 * s, y: rp.y + bodyH / 2 };
      const legTopR = { x: rp.x + 7 * s, y: rp.y + bodyH / 2 };
      const len = 28 * s;
      const deg2rad = (d) => d * Math.PI / 180;
      const aL = hero.legLeft.angle ?? 0;
      const aR = hero.legRight.angle ?? 0;
      const lx = legTopL.x + Math.sin(deg2rad(aL)) * len;
      const ly = legTopL.y + Math.cos(deg2rad(aL)) * len;
      const rx = legTopR.x + Math.sin(deg2rad(aR)) * len;
      const ry = legTopR.y + Math.cos(deg2rad(aR)) * len;
      hero.footLeft.pos = k.vec2(lx, ly);
      hero.footRight.pos = k.vec2(rx, ry);
      hero.footLeft.angle = aL;
      hero.footRight.angle = aR;
    });
    const platformZ = 4.5;
    const ledgeWidth = Math.min(viewW * 0.72, 420);
    const ledgeHeight = Math.max(30, Math.floor(viewH * 0.08));
    const ledgeY = platformTopY + ledgeHeight / 2;
    k.add([
      k.rect(ledgeWidth, ledgeHeight, { radius: 10 }),
      k.pos(viewW / 2, ledgeY),
      k.anchor("center"),
      k.color(88, 72, 64),
      { z: platformZ }
    ]);
    k.add([
      k.rect(ledgeWidth * 0.75, ledgeHeight * 0.7, { radius: 10 }),
      k.pos(viewW / 2 - ledgeWidth * 0.12, ledgeY + ledgeHeight * 0.08),
      k.anchor("center"),
      k.color(74, 60, 54),
      { z: platformZ + 0.01 }
    ]);
    k.add([
      k.rect(ledgeWidth * 0.46, ledgeHeight * 0.5, { radius: 8 }),
      k.pos(viewW / 2 + ledgeWidth * 0.08, ledgeY + ledgeHeight * 0.25),
      k.anchor("center"),
      k.color(64, 50, 45),
      { z: platformZ + 0.02 }
    ]);
    const fgZ = platformZ + 0.05;
    const addGrassPatch = (x2, y, count, scaleMul = 1) => {
      for (let i2 = 0; i2 < count; i2++) {
        const sBlade = (0.9 + Math.random() * 0.6) * s * scaleMul;
        const h = 10 * sBlade + Math.random() * 10 * sBlade;
        const w = 2 * Math.max(0.8, Math.random()) * (sBlade * 0.5);
        const ox = (Math.random() * 16 - 8) * s * 0.6;
        const tilt = Math.random() * 20 - 10;
        const blade = k.add([
          k.rect(w, h, { radius: 1 }),
          k.pos(x2 + ox, y),
          k.anchor("bot"),
          k.color(68 + Math.random() * 20, 130 + Math.random() * 30, 80 + Math.random() * 15),
          k.z(fgZ),
          k.rotate(tilt)
        ]);
        blade.add([k.rect(w * 0.7, 1), k.pos(0, -h * 0.6), k.anchor("center"), k.color(255, 255, 255), k.opacity(0.06)]);
      }
    };
    const addFlower = (x2, y, hue, scaleMul = 1) => {
      const stemH = 14 * s * scaleMul;
      const stem = k.add([
        k.rect(2, stemH, { radius: 1 }),
        k.pos(x2, y),
        k.anchor("bot"),
        k.color(70, 140, 86),
        k.z(fgZ + 0.01)
      ]);
      const petalR = 3.5 * s * scaleMul;
      const col = hue === "red" ? k.rgb(220, 70, 70) : hue === "yellow" ? k.rgb(240, 210, 72) : k.rgb(90, 150, 230);
      stem.add([k.circle(petalR), k.pos(0, -stemH), k.anchor("center"), k.color(col), k.z(fgZ + 0.02)]);
      stem.add([k.circle(petalR * 0.45), k.pos(0, -stemH), k.anchor("center"), k.color(255, 230, 140), k.z(fgZ + 0.03)]);
    };
    const leftEdge = viewW / 2 - ledgeWidth / 2;
    const rightEdge = viewW / 2 + ledgeWidth / 2;
    const topY = platformTopY;
    addGrassPatch(leftEdge + 28, topY, 8, 0.9);
    addGrassPatch(leftEdge + 80, topY, 6, 0.8);
    addGrassPatch(rightEdge - 28, topY, 8, 0.9);
    addGrassPatch(rightEdge - 80, topY, 6, 0.8);
    addFlower(leftEdge + 42, topY, "yellow");
    addFlower(leftEdge + 92, topY, "red", 1.1);
    addFlower(rightEdge - 42, topY, "blue");
    addFlower(rightEdge - 92, topY, "yellow", 1.1);
    (function addMenuDog() {
      const hx = hero.root.pos.x;
      const margin = 16 * s;
      let roamMin = Math.max(hx + 24 * s, viewW / 2 + margin);
      let roamMax = rightEdge - margin;
      if (roamMax - roamMin < 24) {
        roamMin = Math.max(leftEdge + ledgeWidth * 0.6, rightEdge - 60);
        roamMax = rightEdge - margin;
      }
      const startX2 = (roamMin + roamMax) / 2;
      const band = Math.max(20, (roamMax - roamMin) * 0.25);
      roamMin = Math.max(roamMin, startX2 - band * 0.5);
      roamMax = Math.min(roamMax, startX2 + band * 0.5);
      spawnMalteseDog(k, {
        x: startX2,
        groundY: platformTopY,
        z: platformZ + 0.8,
        scale: 0.9 * 2.2,
        roamMinX: roamMin,
        roamMaxX: roamMax
      });
    })();
    const eyeCol = k.rgb(30, 30, 30);
    const eyeSize = 3 * s;
    const mouthW = 7 * s;
    const mouthH = 2 * s;
    const mouthCol = k.rgb(60, 40, 40);
    k.rgb(250, 215, 170);
    hero.head.add([k.rect(eyeSize, eyeSize, { radius: 1 * s }), k.pos(-3 * s, -2 * s), k.anchor("center"), k.color(eyeCol), k.z(13.5)]);
    hero.head.add([k.rect(eyeSize, eyeSize, { radius: 1 * s }), k.pos(3 * s, -2 * s), k.anchor("center"), k.color(eyeCol), k.z(13.5)]);
    hero.head.add([k.rect(mouthW, mouthH, { radius: 1 * s }), k.pos(0, 4 * s), k.anchor("center"), k.color(mouthCol), k.z(13.6)]);
    const titleStr = "betaspray";
    const baseY = viewH * 0.18;
    const size = Math.round(64 * GAME_CONFIG.uiScale);
    const letterSpacing = Math.round(size * 0.12);
    const blue = k.rgb(28, 120, 200);
    const letters = [];
    function addOutlinedLetter(ch) {
      const root = k.add([k.pos(0, 0), k.anchor("center"), k.z(2001)]);
      const outlineOffsets = [
        [-2, 0],
        [2, 0],
        [0, -2],
        [0, 2],
        [-2, -2],
        [2, -2],
        [-2, 2],
        [2, 2]
      ];
      for (const [ox, oy] of outlineOffsets) {
        root.add([k.text(ch, { size }), k.pos(ox, oy), k.anchor("center"), k.color(255, 255, 255)]);
      }
      const main = root.add([k.text(ch, { size }), k.anchor("center"), k.color(blue)]);
      return { root, main };
    }
    let totalWidth = 0;
    const advances = [];
    for (const ch of titleStr.split("")) {
      const l = addOutlinedLetter(ch);
      letters.push(l);
      const w = l.main.width ?? size * 0.6;
      const adv = w + letterSpacing;
      advances.push(adv);
      totalWidth += adv;
    }
    const startX = viewW / 2 - totalWidth / 2;
    let x = startX;
    for (let i2 = 0; i2 < letters.length; i2++) {
      const l = letters[i2];
      const adv = advances[i2];
      l.root.pos = k.vec2(x + adv / 2, baseY);
      x += adv;
    }
    k.onUpdate(() => {
      const t = k.time();
      for (let i2 = 0; i2 < letters.length; i2++) {
        const l = letters[i2];
        const dy = Math.sin(t * 3 + i2 * 0.5) * (size * 0.08);
        l.root.pos.y = baseY + dy;
      }
    });
    k.add([
      k.rect(viewW * 0.92, 66, { radius: 20 }),
      k.pos(viewW / 2, viewH - 36),
      k.anchor("center"),
      k.color(60, 50, 46),
      k.opacity(0.95),
      k.z(1999)
    ]);
    k.add([
      k.text("Tap Space/Enter to Start", { size: 28, width: viewW - 40, align: "center" }),
      k.pos(viewW / 2, viewH - 40),
      k.anchor("center"),
      k.color(255, 255, 255),
      k.z(2e3)
    ]);
    function playWithExitAnim() {
      if (playWithExitAnim._running) return;
      playWithExitAnim._running = true;
      isActing = true;
      const rp = hero.root.pos;
      const x0 = rp.x;
      const x1 = wallCenterX;
      const duration = 1;
      k.tween(hero.body.angle ?? 0, 8, duration * 0.5, (v2) => hero.body.angle = v2, easings.easeInOutSine);
      k.tween(hero.armLeft.angle ?? 190, 210, duration * 0.5, (v2) => hero.armLeft.angle = v2, easings.easeInOutSine);
      k.tween(hero.armRight.angle ?? 170, 150, duration * 0.5, (v2) => hero.armRight.angle = v2, easings.easeInOutSine);
      const stepCycles = 2;
      const half = duration / (stepCycles * 2);
      const walkOne = (dir, onDone) => {
        k.tween(hero.root.pos.x, hero.root.pos.x + dir * 6 * s, half, (v2) => hero.root.pos.x = v2, easings.easeInOutSine).then?.(() => {
          k.tween(hero.root.pos.x, hero.root.pos.x - dir * 6 * s, half, (v2) => hero.root.pos.x = v2, easings.easeInOutSine).then?.(() => onDone?.());
        });
        k.tween(hero.legLeft.angle ?? 0, 10 * dir, half, (v2) => hero.legLeft.angle = v2, easings.easeOutSine).then?.(() => {
          k.tween(hero.legLeft.angle ?? 0, 0, half, (v2) => hero.legLeft.angle = v2, easings.easeInSine);
        });
        k.tween(hero.legRight.angle ?? 0, -10 * dir, half, (v2) => hero.legRight.angle = v2, easings.easeOutSine).then?.(() => {
          k.tween(hero.legRight.angle ?? 0, 0, half, (v2) => hero.legRight.angle = v2, easings.easeInSine);
        });
      };
      k.tween(x0, x1, duration, (v2) => hero.root.pos.x = v2, easings.easeInOutSine);
      walkOne(1, () => walkOne(-1, () => {
        isActing = false;
        k.go("game", mountSeed);
      }));
    }
    (function setupSettings() {
      const radius = 16 * BUTTON_SCALE * 2;
      const ringR = radius + 6;
      const gearCenterX = viewW - UI_MARGIN - ringR;
      const gearCenterY = UI_MARGIN + ringR;
      createSettingsButton(k, gearCenterX, gearCenterY, radius, 2100);
    })();
    const start = () => playWithExitAnim();
    createCircleButton(k, "", viewW / 2, viewH / 2, 56, 2100, start, { glow: true, embossed: true });
    ["space", "enter", "left", "right", "a", "d"].forEach((key) => k.onKeyPress(key, start));
  });
}
function boot() {
  const { k } = initKaboom();
  defineGameScene(k);
  defineMenuScene(k);
  k.go("menu");
}
if (document.readyState === "loading") window.addEventListener("DOMContentLoaded", boot, { once: true });
else boot();</script>
  </head>
  <body>
    <div id="app"></div>
    <div id="mobile-controls" aria-hidden="true" role="group" aria-label="Climb controls">
      <button id="btn-left" class="btn rock-btn rock-left" aria-label="Move left"></button>
      <div id="spacer" aria-hidden="true"></div>
      <button id="btn-right" class="btn rock-btn rock-right" aria-label="Move right"></button>
    </div>
  </body>
  </html>
